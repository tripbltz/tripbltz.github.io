<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-touch-fullscreen" content="yes" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap"
			rel="stylesheet"
		/>
		<title>Astronomican 2.2</title>
		<style>
			:root {
				--bg: #0d0f12;
				--panel: #151a20;
				--panel-2: #1b2129;
				--text: #e6ebf2;
				--muted: #9fb0c3;
				--accent: #62d3ff;
				--accent-2: #ffd166;
				--danger: #ff6b6b;
				--ok: #2ecc71;
				--border: #26303b;
			}
			* {
				box-sizing: border-box;
			}
			html,
			body {
				height: 100%;
			}
			body {
				margin: 0;
				font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
					Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
				background: linear-gradient(180deg, #0b0e12, #0a0d11 30%, #0b0e12);
				color: var(--text);
			}
			.container {
				max-width: 1400px;
				margin: 0 auto;
				padding: 16px;
			}
			header {
				display: flex;
				gap: 12px;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 12px;
			}
			.app-title {
				font-weight: 800;
				letter-spacing: 0.5px;
				cursor: pointer;
			}
			.pirata-one-regular {
				font-family: "Pirata One", system-ui;
				font-weight: 400;
				font-style: normal;
			}
			/* Stratagems */
			.strat-card {
				border: 1px solid var(--border);
				background: #121820;
				border-radius: 10px;
				padding: 10px;
				margin: 8px 0;
			}
			.strat-head {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 8px;
				margin-bottom: 4px;
			}
			.cp-badge {
				font-size: 12px;
				padding: 2px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #14222c;
				color: #bfe9ff;
			}
			.chips {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.chip {
				font-size: 11px;
				border: 1px solid var(--border);
				border-radius: 999px;
				padding: 2px 6px;
				color: var(--muted);
				background: #0f141a;
			}
			.strat-section-title {
				margin: 10px 0 4px 0;
				font-size: 13px;
				color: #d9e6f7;
			}
			.faction-name {
				font-family: "Pirata One", system-ui;
				font-weight: 400;
				font-style: normal;
				font-size: 30px;
				color: #e6ebf2;
			}
			.badge {
				padding: 2px 8px;
				border: 1px solid var(--border);
				border-radius: 999px;
				background: var(--panel);
				color: var(--muted);
				font-size: 12px;
			}
			.row {
				display: grid;
				gap: 12px;
			}
			@media (min-width: 1100px) {
				.row {
					grid-template-columns: 1fr 1fr;
				}
			}
			@media (max-width: 1099px) {
				.row {
					grid-template-columns: 1fr;
				}
			}

			.panel {
				background: linear-gradient(180deg, var(--panel), var(--panel-2));
				border: 1px solid var(--border);
				border-radius: 12px;
				padding: 12px;
			}
			.panel h3 {
				margin: 0 0 8px 0;
				font-size: 16px;
				color: var(--text);
			}
			.sub {
				font-size: 12px;
				color: var(--muted);
			}

			.controls {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				align-items: center;
			}
			.controls .group {
				display: flex;
				gap: 6px;
				align-items: center;
			}
			input[type="text"],
			input[type="number"],
			select,
			textarea {
				background: #0f141a;
				border: 1px solid var(--border);
				color: var(--text);
				padding: 8px 10px;
				border-radius: 8px;
				outline: none;
				min-width: 0;
			}
			textarea {
				width: 100%;
				min-height: 80px;
			}
			button {
				background: var(--panel-2);
				color: var(--text);
				border: 1px solid var(--border);
				padding: 8px 10px;
				border-radius: 8px;
				cursor: pointer;
			}
			button:hover {
				border-color: #3a495b;
			}
			button.primary {
				background: linear-gradient(180deg, #0c2730, #0a3b4b);
				border-color: #294a5a;
				color: #dff6ff;
			}
			button.danger {
				background: linear-gradient(180deg, #361414, #2c0e0e);
				border-color: #623434;
				color: #ffd0d0;
			}
			button.ghost {
				background: transparent;
			}

			/* Sleek select and custom file uploader */
			.input-row {
				display: flex;
				gap: 10px;
				align-items: stretch;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.select-wrap {
				position: relative;
				flex: 0 0 180px;
			}
			.select-wrap select.custom-select {
				appearance: none;
				-webkit-appearance: none;
				-moz-appearance: none;
				width: 100%;
				height: 38px;
				background: #0f141a;
				border: 1px solid var(--border);
				color: var(--text);
				padding: 8px 36px 8px 10px;
				border-radius: 8px;
				outline: none;
				cursor: pointer;
			}
			.select-wrap::after {
				content: "▾";
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
				pointer-events: none;
				color: var(--muted);
				font-size: 14px;
			}
			.file-uploader {
				display: inline-flex;
				align-items: center;
				gap: 8px;
				flex: 1 1 auto;
			}
			.file-uploader .filename-pill {
				display: inline-flex;
				align-items: center;
				max-width: 100%;
				padding: 6px 10px;
				border: 1px dashed var(--border);
				color: var(--muted);
				border-radius: 8px;
				min-height: 38px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			.file-uploader .btn-choose {
				height: 38px;
			}
			.player-import-row {
				display: flex;
				align-items: center;
				gap: 10px;
				flex-wrap: wrap;
			}
			.player-import-row input[type="text"] {
				flex: 1 1 240px;
				min-width: 180px;
			}
			.visually-hidden {
				position: absolute !important;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0 0 0 0);
				white-space: nowrap;
				border: 0;
			}

			.grid-2 {
				display: grid;
				gap: 10px;
				grid-template-columns: 1fr 1fr;
			}
			.grid-3 {
				display: grid;
				gap: 10px;
				grid-template-columns: repeat(3, 1fr);
			}

			.unit-card {
				border: 1px solid var(--border);
				border-radius: 10px;
				padding: 10px;
				background: #12171d;
				display: flex;
				gap: 10px;
				align-items: flex-start;
				align-self: start;
				/* Prevent splitting; enable masonry flow */
				break-inside: avoid;
				-webkit-column-break-inside: avoid;
				page-break-inside: avoid;
				margin: 0;
				min-width: 0;

				/* Grid-friendly: cards are grid items, no inline-block needed */
				width: 100%;
				transition: background 300ms ease, border-color 300ms ease,
					box-shadow 300ms ease;
			}

			.unit-card.expanded {
				background: linear-gradient(180deg, #151d25, #1a2530);
				border-color: #2d3b4b;
				box-shadow: inset 0 0 0 1px rgba(45, 59, 75, 0.35);
			}
			.unit-name {
				cursor: pointer;
			}
			.unit-details {
				/* smoother sliding reveal using inline max-height */
				max-height: 0;
				overflow: hidden;
				opacity: 0;
				transform: translateY(-6px);
				/* padding handled by inner wrapper to avoid end snap */
				will-change: max-height, opacity, transform;
				transition: max-height 600ms cubic-bezier(0.22, 1, 0.36, 1),
					opacity 600ms ease, transform 600ms ease;
				margin-top: 8px;
				border-top: 1px solid var(--border);
			}
			.unit-details.active {
				/* max-height is set inline by JS to the element's scrollHeight */
				opacity: 1;
				transform: translateY(0);
			}

			.unit-details-inner {
				padding: 8px 0; /* constant padding so the outer height animation doesn't "snap" at the end */
			}

			/* Respect users who prefer reduced motion */
			@media (prefers-reduced-motion: reduce) {
				.unit-details,
				.unit-details.active {
					transition: none !important;
					max-height: none !important;
					opacity: 1 !important;
					transform: none !important;
				}
			}
			.statline {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				margin: 6px 0;
			}
			.statline .tag {
				background: #0f141a;
			}
			.composition {
				font-size: 12px;
				color: var(--muted);
			}
			.weapon-grid {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.weapon-link {
				display: inline-flex;
				align-items: center;
				gap: 6px;
				padding: 4px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #121820;
				color: #cfe4ff;
				font-size: 12px;
				cursor: pointer;
			}
			.weapon-link:hover {
				border-color: #2d3b4b;
				background: #101720;
			}
			.weapon-panel {
				margin-top: 8px;
				border-top: 1px solid var(--border);
				padding-top: 8px;
				contain: layout;
			}
			.weapon-panel.hidden {
				display: none;
			}
			.weapon-table {
				width: 100%;
				border-collapse: collapse;
				font-size: 12px;
				table-layout: fixed;
			}
			.weapon-table th,
			.weapon-table td {
				border: 1px solid var(--border);
				padding: 6px 8px;
				text-align: left;
				background: #0f141a;
				overflow: hidden; /* keep cells from growing */
				text-overflow: clip; /* don't ellipsis; we'll autoshrink via JS */
				white-space: nowrap; /* keep single-line for stat cells */
				font-variant-numeric: tabular-nums; /* nicer alignment for numbers */
			}
			.weapon-table th {
				background: #121820;
				color: #eaf6ff;
			}
			.weapon-table .abilities-row td {
				white-space: normal; /* allow wrapping for long ability text */
				overflow: visible; /* show full content */
			}
			.unit-meta {
				flex: 1;
				min-width: 0;
			}
			.unit-name {
				font-weight: 700;
			}
			.kw {
				font-size: 11px;
				color: var(--muted);
				border: 1px solid var(--border);
				padding: 2px 6px;
				border-radius: 999px;
				margin-right: 4px;
			}
			.wounds {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-top: 6px;
			}
			.bar {
				position: relative;
				flex: 1;
				height: 10px;
				background: red;
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: hidden;
			}
			.bar > span {
				position: absolute;
				left: 0;
				top: 0;
				bottom: 0;
				background: linear-gradient(90deg, #1f815a, #1b9d74, #1ea77c);
			}
			.cnt {
				font-variant-numeric: tabular-nums;
			}

			/* Phase Help specific tweaks */
			#phaseModal .modal-dialog {
				width: 520px;
				max-width: 90vw;
			}
			#phaseHelpBody p {
				margin: 8px 0;
			}
			#phaseHelpBody ul {
				margin: 8px 0 0 18px;
			}

			.effect-chip {
				display: inline-flex;
				gap: 6px;
				align-items: center;
				border: 1px solid var(--border);
				background: #121820;
				padding: 4px 8px;
				border-radius: 999px;
				font-size: 12px;
				color: #cfe4ff;
				margin: 4px 6px 0 0;
			}
			.effect-chip small {
				color: #9fc4ff;
			}
			.effect-chip button {
				border: none;
				background: transparent;
				color: #ffd0d0;
				cursor: pointer;
			}

			.section-title {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin: 6px 0;
			}

			.phase {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
			}
			.phase .pill {
				padding: 6px 10px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #121820;
				color: var(--muted);
				font-size: 12px;
			}
			.phase .pill.active {
				background: linear-gradient(180deg, #172330, #0f1a24);
				color: #eaf6ff;
				border-color: #2d3b4b;
				font-weight: bold;
			}

			/* Two fixed columns; each column manages its own vertical flow */
			.players {
				display: grid;
				gap: 12px;
				align-items: start; /* no stretching */
				grid-template-columns: 1fr; /* 1 col on small screens */
			}
			@media (min-width: 700px) {
				.players {
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
				}
			}
			.player-col {
				display: grid; /* simple vertical stack */
				gap: 12px; /* space between unit cards in the same column */
				align-content: start;
				min-width: 0;
			}
			.card-title {
				display: flex;
				gap: 8px;
				align-items: center;
				justify-content: space-between;
			}
			.faction-row {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: 6px 0 12px 0;
			}
			.faction-row img {
				max-height: 150px;
				width: auto;
				border-radius: 8px;
				border: 1px solid var(--border);
				background: #0f141a;
			}
			.counter {
				display: inline-flex;
				gap: 6px;
				align-items: center;
			}
			.counter input {
				width: 70px;
				text-align: center;
			}
			.counter button {
				width: 34px;
			}

			.footer {
				margin-top: 16px;
				color: var(--muted);
				font-size: 12px;
				text-align: center;
			}

			.log {
				max-height: 220px;
				overflow: auto;
				border: 1px dashed var(--border);
				padding: 8px;
				border-radius: 8px;
				background: #0e1419;
			}
			.log .item {
				font-size: 12px;
				color: #c8d6e5;
				padding: 4px 0;
				border-bottom: 1px dashed #213042;
			}
			.log .item:last-child {
				border-bottom: none;
			}

			.tag {
				font-size: 11px;
				border: 1px solid var(--border);
				padding: 2px 6px;
				border-radius: 999px;
				color: #cfd8e3;
			}
			.muted {
				color: var(--muted);
			}
			.divider {
				height: 1px;
				background: var(--border);
				margin: 8px 0;
			}

			.hidden {
				display: none !important;
			}

			/* Modal */
			.modal-backdrop {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.6);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 1000;
			}
			.modal-backdrop.active {
				display: flex;
			}
			.modal-dialog {
				width: 50vw; /* ~50% of page width */
				max-width: 900px;
				min-width: 320px;
				max-height: 85vh;
				overflow: auto;
				border-radius: 12px;
				background: linear-gradient(180deg, var(--panel), var(--panel-2));
				border: 1px solid var(--border);
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
			}
			.modal-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 10px 12px;
				border-bottom: 1px solid var(--border);
			}
			.modal-body {
				padding: 12px;
			}
			.modal-footer {
				display: flex;
				align-items: center;
				justify-content: flex-end;
				padding: 10px 12px;
				border-top: 1px solid var(--border);
				gap: 8px;
			}
			.modal-footer .hint {
				margin-right: auto;
				font-size: 12px;
				color: var(--muted);
			}
			.modal-close {
				background: transparent;
				border: none;
				color: var(--muted);
				font-size: 20px;
				cursor: pointer;
			}
			.btn-x {
				background: transparent;
				color: var(--danger);
				border: 1px solid var(--border);
				width: 28px;
				height: 28px;
				padding: 0;
				border-radius: 6px;
				font-size: 16px;
				line-height: 1;
				cursor: pointer;
			}
			.btn-x:hover {
				background: #2c0e0e;
				border-color: #623434;
				color: #ffd0d0;
			}
			.dice-anim {
				display: flex;
				gap: 10px; /* give bigger dice some breathing room */
				flex-wrap: wrap;
				align-items: center;
			}
			.die {
				width: 112px; /* 4x bigger */
				height: 112px; /* 4x bigger */
				border-radius: 24px; /* keep the same rounded proportion */
				border: 1px solid var(--border);
				background: #0f141a;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 700;
				font-size: 48px; /* scale the face value so it’s readable */
			}
			.die.spin {
				animation: dice-spin 300ms linear infinite;
			}
			@keyframes dice-spin {
				0% {
					transform: rotate(0);
				}
				50% {
					transform: rotate(10deg);
				}
				100% {
					transform: rotate(0);
				}
			}
			.more-badge {
				font-size: 11px;
				color: var(--muted);
				border: 1px dashed var(--border);
				border-radius: 999px;
				padding: 2px 6px;
			}
			/* Missions */
			.mission-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
				gap: 10px;
			}
			.mission-card {
				border: 1px solid var(--border);
				border-radius: 10px;
				background: #121820;
				padding: 10px;
				cursor: pointer;
			}
			.mission-card:hover {
				border-color: #2d3b4b;
				background: #101720;
			}
			.mission-card.selected {
				outline: 2px solid var(--accent);
			}
			.mission-meta {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.mission-meta .chip {
				font-size: 11px;
				border: 1px solid var(--border);
				border-radius: 999px;
				padding: 2px 6px;
				color: var(--muted);
				background: #0f141a;
			}
		</style>
		<!-- Prevent local favicon warning -->
		<link rel="icon" href="data:," />

		<!-- PDF.js for client-side PDF text extraction (no SRI to avoid hash mismatch across CDNs) -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
		<script>
			(function () {
				const lib = window.pdfjsLib || window["pdfjs-dist/build/pdf"];
				if (lib && lib.GlobalWorkerOptions) {
					lib.GlobalWorkerOptions.workerSrc =
						"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
					window.__pdfjs = lib;
				}
			})();
		</script>
		<script src="data.js"></script>
	</head>
	<body>
		<div class="container">
			<header>
				<div style="display: flex; align-items: center; gap: 10px">
					<div
						id="appTitle"
						class="app-title pirata-one-regular"
						title="About Astronomican"
					>
						⚙️ Astronomican <br /><span class="badge">10th Edition</span>
					</div>
					<span class="badge" id="roundBadge">Round 1</span>
					<span class="badge" id="turnBadge"
						>Turn: <strong id="turnPlayerBadge">Player 1</strong></span
					>
				</div>
				<div class="controls">
					<div class="group">
						<div class="phase" id="phasePills"></div>
					</div>
					<div class="group">
						<button class="primary" id="btnNextPhase" style="margin-left: 10px">
							Next Phase ➜
						</button>
					</div>
				</div>
				<div class="group">
					<button id="btnDice" class="ghost" title="Open dice roller">
						🎲
					</button>
					<button id="btnHelp" class="ghost" title="Open help">Help</button>
					<button id="btnSetup" class="primary" title="Open setup & tools">
						Setup
					</button>
					<button id="btnNewGame" class="danger" title="Start a new battle">
						New Game
					</button>
				</div>
			</header>

			<!-- Start Game Modal -->
			<div id="startModal" class="modal-backdrop">
				<div class="modal-dialog">
					<div class="modal-header">
						<strong class="faction-name">Start Game</strong>
						<button
							id="startClose"
							class="modal-close"
							aria-label="Close"
							style="display: none"
						>
							✕
						</button>
					</div>
					<div class="modal-body">
						<section class="panel" id="startPanel">
							<div class="grid-2">
								<!-- Player Names -->
								<div>
									<div class="card-title"><strong>Players</strong></div>
									<div class="player-import">
										<!-- Row: Player 1 -->
										<div class="player-import-row" style="margin-top: 6px">
											<input id="p1Name" type="text" value="Player 1" />
											<button
												id="btnImportP1"
												type="button"
												class="primary btn-choose"
											>
												Import army
											</button>
											<span id="armyFileNameP1" class="filename-pill sub"
												>Upload a Battleforge (40k App) PDF army list</span
											>
											<input
												type="file"
												id="armyFileP1"
												accept=".pdf,application/pdf"
												class="visually-hidden"
												aria-hidden="true"
											/>
										</div>

										<!-- Row: Player 2 -->
										<div class="player-import-row" style="margin-top: 6px">
											<input id="p2Name" type="text" value="Player 2" />
											<button
												id="btnImportP2"
												type="button"
												class="primary btn-choose"
											>
												Import army
											</button>
											<span id="armyFileNameP2" class="filename-pill sub"
												>Upload a Battleforge (40k App) PDF army list</span
											>
											<input
												type="file"
												id="armyFileP2"
												accept=".pdf,application/pdf"
												class="visually-hidden"
												aria-hidden="true"
											/>
										</div>
									</div>
								</div>
							</div>

							<div class="divider"></div>

							<!-- Mission Setup -->
							<div class="card-title"><strong>Mission Setup</strong></div>
							<div class="sub" style="margin-top: 6px">
								Choose a mission pack at random or pick one.
							</div>

							<div class="grid-2" style="margin-top: 8px">
								<div>
									<div
										style="
											margin-top: 8px;
											display: flex;
											gap: 8px;
											flex-wrap: wrap;
										"
									>
										<button id="btnMissionRandom">🎴 Draw Random</button>
										<button id="btnMissionChoose">📜 Choose Mission</button>
									</div>
								</div>
								<div>
									<div class="sub"><strong>Selected Mission</strong></div>
									<div id="missionSelected" class="sub" style="margin-top: 6px">
										None selected.
									</div>
								</div>
							</div>

							<div id="missionChooser" class="hidden" style="margin-top: 10px">
								<div class="card-title">
									<strong>Choose a Mission</strong>
									<button id="btnMissionChooserClose" class="ghost">
										Close
									</button>
								</div>
								<div id="missionGrid" class="mission-grid"></div>
							</div>

							<div class="divider"></div>

							<!-- Saved states (Load ONLY) -->
							<div class="card-title"><strong>Saved states</strong></div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 12px;
									flex-wrap: wrap;
								"
							>
								<button id="btnLoad">📂 Load</button>
								<input
									id="loadState"
									type="file"
									accept="application/json"
									style="display: none"
								/>
							</div>
						</section>
					</div>
					<!-- closes .modal-body -->
					<div class="modal-footer">
						<span class="hint"
							>Upload both army lists and select a mission to begin.</span
						>
						<button id="btnStartBattle" class="btn btn-primary">
							Start battle!
						</button>
					</div>
				</div>
			</div>

			<!-- Setup & Tools Modal -->
			<div id="setupModal" class="modal-backdrop">
				<div class="modal-dialog">
					<div class="modal-header">
						<strong class="faction-name">Setup & Tools</strong>
						<button id="setupClose" class="modal-close" aria-label="Close">
							✕
						</button>
					</div>
					<div class="modal-body">
						<section class="panel" id="importPanel">
							<div class="grid-2">
								<div>
									<div class="card-title"><strong>CP / VP</strong></div>
									<div class="grid-2" style="margin-top: 6px">
										<div class="counter">
											<span class="tag">P1 CP</span
											><button data-cp="p1" data-delta="-1">−</button
											><input id="p1CP" type="number" value="0" /><button
												data-cp="p1"
												data-delta="1"
											>
												＋
											</button>
										</div>
										<div class="counter">
											<span class="tag">P1 VP</span
											><button data-vp="p1" data-delta="-1">−</button
											><input id="p1VP" type="number" value="0" /><button
												data-vp="p1"
												data-delta="1"
											>
												＋
											</button>
										</div>
										<div class="counter">
											<span class="tag">P2 CP</span
											><button data-cp="p2" data-delta="-1">−</button
											><input id="p2CP" type="number" value="0" /><button
												data-cp="p2"
												data-delta="1"
											>
												＋
											</button>
										</div>
										<div class="counter">
											<span class="tag">P2 VP</span
											><button data-vp="p2" data-delta="-1">−</button
											><input id="p2VP" type="number" value="0" /><button
												data-vp="p2"
												data-delta="1"
											>
												＋
											</button>
										</div>
									</div>
								</div>
							</div>

							<div class="divider"></div>
							<div class="card-title">
								<strong>Game Settings</strong>
							</div>
							<div class="sub" style="margin-top: 6px">
								<label
									><input type="checkbox" id="autoCP" checked /> Auto +1 CP at
									Command phase</label
								>
							</div>

							<!-- Tools section -->
							<div class="divider"></div>
							<div class="card-title"><strong>Tools</strong></div>
							<div class="sub" style="margin-top: 6px">
								If phase moved forward by mistake
							</div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 8px;
									flex-wrap: wrap;
								"
							>
								<button class="ghost" id="btnPrevPhase">◀︎ Prev Phase</button>
							</div>

							<div class="divider"></div>
							<div class="card-title"><strong>Saved states</strong></div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 12px;
									flex-wrap: wrap;
								"
							>
								<button id="btnSave">💾 Save</button>
							</div>
						</section>
					</div>
				</div>
			</div>

			<div class="row">
				<!-- Players only: two columns -->
				<section class="panel">
					<div class="card-title">
						<h3 id="p1Header">Player 1 Army</h3>
					</div>
					<div class="faction-row">
						<div id="p1Faction" class="faction-name"></div>
						<button id="p1Strats">Stratagems</button>
						<button id="p1Mission">Mission</button>
						<img id="p1FactionImg" alt="Faction" class="hidden" />
					</div>
					<div id="p1Units" class="players">
						<div class="player-col" id="p1UnitsCol1"></div>
						<div class="player-col" id="p1UnitsCol2"></div>
					</div>
				</section>
				<section class="panel">
					<div class="card-title">
						<h3 id="p2Header">Player 2 Army</h3>
					</div>
					<div class="faction-row">
						<div id="p2Faction" class="faction-name"></div>
						<button id="p2Strats">Stratagems</button>
						<button id="p2Mission">Mission</button>
						<img id="p2FactionImg" alt="Faction" class="hidden" />
					</div>
					<div id="p2Units" class="players">
						<div class="player-col" id="p2UnitsCol1"></div>
						<div class="player-col" id="p2UnitsCol2"></div>
					</div>
				</section>
			</div>

			<div class="footer">
				State is auto-saved locally. You can export/import to continue later.
			</div>
		</div>

		<template id="unitTemplate">
			<div class="unit-card" data-unit-id>
				<div class="unit-meta">
					<div class="unit-name"></div>
					<div class="sub keywords"></div>
					<div class="wounds">
						<div class="bar"><span></span></div>
						<div class="cnt" data-wounds></div>
						<button data-dmg="1">−</button>
						<button data-dmg="-1">＋</button>
					</div>
					<div class="sub" data-models></div>
					<div class="section-title">
						<strong>Effects</strong> <button data-add-effect>＋ Add</button>
					</div>
					<div class="effects" data-effects></div>
					<div class="unit-details" data-details>
						<div class="unit-details-inner">
							<div class="section-title"><strong>Unit Details</strong></div>
							<div class="statline" data-statline></div>
							<div class="composition" data-composition></div>
							<div class="section-title" style="margin-top: 8px">
								<strong>Weapons</strong>
							</div>
							<div class="weapon-grid" data-weapons></div>
							<div class="weapon-panel hidden" data-weapon-panel></div>
						</div>
					</div>
				</div>
				<div>
					<button class="btn-x" data-remove aria-label="Remove">✕</button>
				</div>
			</div>
		</template>

		<!-- Phase Help Modal -->
		<div id="phaseModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="phaseHelpTitle">Phase Help</strong>
					<button id="phaseHelpClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div id="phaseHelpBody" class="modal-body"></div>
			</div>
		</div>

		<!-- Dice Roller Modal -->
		<div id="diceModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Dice Roller</strong>
					<button id="diceClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div class="modal-body">
					<div
						style="
							display: flex;
							gap: 8px;
							align-items: center;
							flex-wrap: wrap;
						"
					>
						<input id="diceExpr" type="text" placeholder="e.g. 6d6+2" />
						<button id="btnRoll">Roll</button>
					</div>

					<div class="sub" id="diceHelp" style="margin-top: 6px">
						Examples: <br /><code>d6</code> (roll one D6),
						<code>6d6+2</code> (roll six D6 and add 2), <code>3d10-1</code>, or
						just <code>20</code> (roll twenty D6).
					</div>

					<div
						id="diceAnim"
						class="dice-anim"
						aria-hidden="true"
						style="margin-top: 10px"
					></div>
					<div id="diceOut" class="sub" style="margin-top: 10px"></div>
				</div>
			</div>
		</div>

		<!-- Help Modal -->
		<div id="helpModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Help</strong>
					<button id="helpClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div class="modal-body">
					<section class="panel">
						<div class="card-title"><strong>Getting Started</strong></div>
						<div class="sub">
							<p>
								Import your army list as a PDF, then click unit names to expand
								details. Use the phase pills at the top to step through your
								turn.
							</p>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title"><strong>Common Actions</strong></div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li>
									Click a unit name to view its M/T/Sv/W/Ld/OC and composition.
								</li>
								<ul>
									<li>
										Click a weapon name to view its profile, abilities, and
										rolls.
									</li>
								</ul>
								<li>
									Use the − / ＋ buttons on a unit to apply damage or healing.
								</li>
								<li>
									Use the ✕ button to remove a unit (or confirm when it reaches
									0W).
								</li>
								<li>
									Open <em>Setup</em> to rename players, import armies, and
									manage saves.
								</li>
							</ul>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title"><strong>Dice Notation</strong></div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li><code>8</code> – roll eight six-sided die.</li>
								<li><code>d6</code> – roll one six-sided die.</li>
								<li><code>6d6+2</code> – roll six D6 and add 2.</li>
								<li><code>3d10-1</code> – roll three D10 and subtract 1.</li>
							</ul>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title">
							<strong>Terrain (10th Edition)</strong>
						</div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li>
									<strong>Light Cover</strong> – models wholly on/within gain
									the <em>Benefit of Cover</em> against ranged attacks.
								</li>
								<li>
									<strong>Heavy Cover</strong> – as Light Cover; in addition, if
									Charged through Heavy Cover, charging units do not receive the
									charge bonus to melee Attacks (where applicable).
								</li>
								<li>
									<strong>Difficult Ground</strong> – subtract 2" from Move,
									Advance and Charge moves made through it.
								</li>
								<li>
									<strong>Obscuring</strong> – blocks line of sight through it
									for non-AIRCRAFT outside and targets behind (with usual
									exceptions like models on/within or towering).
								</li>
								<li>
									<strong>Benefit of Cover</strong> – add 1 to Saving Throws
									(not Invulnerable saves) against ranged attacks; does not
									apply while the target is within Engagement Range of any enemy
									models.
								</li>
							</ul>
						</div>
					</section>
				</div>
			</div>
		</div>

		<!-- Stratagems Modal -->
		<div id="stratModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="stratTitle" class="faction-name">Stratagems</strong>
					<button id="stratClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div id="stratBody" class="modal-body">
					<div class="sub" id="stratContext"></div>
					<div id="stratList"></div>
				</div>
			</div>
		</div>

		<!-- About / Astronomican Modal -->
		<div id="aboutModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Astronomican</strong>
					<button id="aboutClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div class="modal-body" style="text-align: center">
					<img
						src="god-emperor-chris.jpeg"
						alt="God-Emperor Chris"
						style="
							max-width: 100%;
							height: auto;
							border-radius: 8px;
							border: 1px solid var(--border);
							background: #0f141a;
						"
					/>
					<div class="sub" style="margin-top: 10px">
						Helping dyslexics play 40k since 2025
					</div>
				</div>
			</div>
		</div>

		<!-- Mission Modal -->
		<div id="missionModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="missionTitle" class="faction-name">Mission</strong>
					<button id="missionClose" class="modal-close" aria-label="Close">
						✕
					</button>
				</div>
				<div id="missionBody" class="modal-body"></div>
			</div>
		</div>

		<script>
			const PHASE_HELP = {
				Command: `
					<p><strong>Command phase:</strong> Gain 1CP, resolve any "start of your Command phase" abilities and effects, select targets for army rules/stratagems as appropriate, and take any required Battle-shock tests as instructed by rules (many 10th edition rules check for below Half-strength here).</p>
				`,
				Movement: `
					<p><strong>Movement phase:</strong> Select units to move. Each unit can Normal Move, Advance (add D6 to Move and cannot shoot certain weapons or charge), or Fall Back (cannot shoot or charge unless a rule allows). Aircraft and other special moves follow their datasheet rules.</p>
				`,
				Shooting: `
					<p><strong>Shooting phase:</strong> Choose eligible units to shoot, select targets in range and line of sight, resolve attacks weapon-by-weapon (Hit → Wound → Saves → Damage), and apply abilities like Rapid Fire, Blast, etc.</p>
				`,
				Charge: `
					<p><strong>Charge phase:</strong> Declare targets with units eligible to charge (not Advanced or Fell Back unless a rule allows), resolve Overwatch/defensive rules as applicable, roll charge distances, and make charge moves into Engagement Range.</p>
				`,
				Fight: `
					<p><strong>Fight phase:</strong> Units in Engagement Range fight in alternating order. Pile-In → Make Attacks → Remove Casualties → Consolidate. Apply abilities such as Fights First/Last and modifiers from stratagems.</p>
				`,
				Battleshock: `
					<p><strong>Battle-shock step:</strong> Resolve any end-of-turn checks or effects tied to Battle-shock and mission rules. In 10th edition, many Battle-shock tests are taken at the start of the Command phase when a unit is below Half-strength; use this step to track ongoing Battle-shock effects and clean up end-of-turn abilities.</p>
				`,
			};

			function openPhaseModal(title, html) {
				const m = document.getElementById("phaseModal");
				const t = document.getElementById("phaseHelpTitle");
				const b = document.getElementById("phaseHelpBody");
				if (t) t.textContent = title || "Phase Help";
				if (b) b.innerHTML = html || "";
				if (m) m.classList.add("active");
			}
			function closePhaseModal() {
				const m = document.getElementById("phaseModal");
				if (m) m.classList.remove("active");
			}
			// ------------------------------
			// Weapon helpers (uses window.weaponProfiles defined in data.js)
			// ------------------------------
			function getWeaponProfilesMap() {
				const db = window.weaponProfiles || {};
				// build a map by lowercase name for fuzzy matching from composition text
				const byName = new Map();
				for (const [key, prof] of Object.entries(db)) {
					const name =
						prof && prof.name
							? String(prof.name).toLowerCase().trim()
							: String(key).toLowerCase().trim();
					byName.set(name, { key, prof });
				}
				return { byName, byKey: db };
			}

			function extractWeaponsFromComposition(lines) {
				if (!Array.isArray(lines) || !lines.length) return [];
				const { byName } = getWeaponProfilesMap();

				// Build a list of { name, key } and sort by longest name first.
				const nameEntries = Array.from(byName.entries())
					.map(([nm, v]) => ({ name: nm, key: v.key }))
					.sort((a, b) => b.name.length - a.name.length);

				const foundKeys = new Set();

				// Escape regex helper
				const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

				for (const raw of lines) {
					let remaining = String(raw).toLowerCase();
					if (!remaining) continue;

					for (const { name, key } of nameEntries) {
						if (name.length < 3) continue; // ignore extremely short names
						// Whole-word match for the weapon name (case-insensitive)
						const re = new RegExp(`\\b${esc(name)}\\b`, "i");
						if (re.test(remaining)) {
							foundKeys.add(key);
							// Remove matched text from this line so shorter names contained within
							// (e.g., "scything talons" inside "gargantuan scything talons")
							// won't also match on the same line.
							// Replace all occurrences (use loop because of dynamic regex without /g flag capture)
							let m;
							while ((m = re.exec(remaining))) {
								const start = m.index;
								const end = start + m[0].length;
								remaining = `${remaining.slice(0, start)}${" ".repeat(
									m[0].length
								)}${remaining.slice(end)}`;
							}
						}
					}
				}

				return Array.from(foundKeys);
			}

			function renderWeaponProfileHTML(key) {
				const db = window.weaponProfiles || {};
				const p = db[key];
				if (!p) return '<div class="sub">No profile found.</div>';
				const isMelee = String(p.range).toLowerCase() === "melee";
				const accLabel = isMelee ? "WS" : "BS";
				const acc = isMelee ? p.ws ?? "-" : p.bs ?? "-";
				const abil =
					Array.isArray(p.abilities) && p.abilities.length
						? p.abilities.join(", ")
						: "—";
				return `
  <div class="sub" style="margin-bottom:6px"><strong>${
		p.name || key
	}</strong></div>
  <table class="weapon-table">
    <thead>
      <tr>
        <th>Rng</th><th>A</th><th>${accLabel}</th><th>S</th><th>AP</th><th>D</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>${p.range}</td>
        <td>${p.attacks ?? "-"}</td>
        <td>${acc}</td>
        <td>${p.strength ?? "-"}</td>
        <td>${p.ap ?? 0}</td>
        <td>${p.damage ?? "-"}</td>
      </tr>
      <tr class="abilities-row">
        <td colspan="6"><span class="muted">Abilities:</span> ${abil}</td>
      </tr>
    </tbody>
  </table>
`;
			}

			function renderWeaponsForUnit(unit, listEl, panelEl) {
				if (!listEl || !panelEl) return;
				const keys = extractWeaponsFromComposition(unit.composition || []);
				listEl.innerHTML = "";
				panelEl.innerHTML = "";
				panelEl.classList.add("hidden");
				const grid = panelEl.closest(".players");
				relayoutMasonry(grid);

				if (!keys.length) {
					listEl.innerHTML =
						'<span class="sub">No weapons detected from PDF.</span>';
					return;
				}

				// Build buttons
				keys.forEach((key) => {
					const p =
						(window.weaponProfiles && window.weaponProfiles[key]) || null;
					const btn = document.createElement("button");
					btn.className = "weapon-link";
					btn.type = "button";
					btn.setAttribute("data-weapon-key", key);
					btn.textContent = p ? p.name || key : key;
					btn.addEventListener("click", () => {
						const current = panelEl.getAttribute("data-open-key") || "";
						if (current === key && !panelEl.classList.contains("hidden")) {
							// toggle close
							panelEl.classList.add("hidden");
							panelEl.removeAttribute("data-open-key");
							panelEl.innerHTML = "";
						} else {
							panelEl.innerHTML = renderWeaponProfileHTML(key);
							panelEl.classList.remove("hidden");
							panelEl.setAttribute("data-open-key", key);
							// After injecting the table, shrink any too-long values to fit
							autoshrinkWeaponTable(panelEl);
						}

						// ✨ Recompute masonry span after height changes
						const grid = panelEl.closest(".players");
						relayoutMasonry(grid);
					});
					listEl.appendChild(btn);
				});
			}

			// --- Auto-shrink long values inside weapon tables so they don't ellipsis ---
			function isOverflowing(el) {
				return el && el.scrollWidth > el.clientWidth;
			}

			/**
			 * Reduce font-size inside a cell until the content fits on one line,
			 * without changing table layout. Falls back gracefully at a minimum size.
			 */
			function fitTextToCell(td, minPx = 9, maxPx = 12) {
				if (!td) return;
				// Start from computed (or cap at max)
				const computed = parseFloat(getComputedStyle(td).fontSize) || maxPx;
				let size = Math.min(computed, maxPx);

				// Reset any previous tweaks
				td.style.fontSize = size + "px";
				td.style.letterSpacing = "";

				// Shrink stepwise while overflowing
				while (isOverflowing(td) && size > minPx) {
					size -= 1;
					td.style.fontSize = size + "px";
					// Tighten tracking a touch when very small
					if (size <= minPx + 1) td.style.letterSpacing = "-0.2px";
				}
			}

			/**
			 * Apply autoshrink to all stat cells of a freshly-rendered weapon table.
			 * (Skips the abilities row which wraps by design.)
			 */
			function autoshrinkWeaponTable(root) {
				if (!root) return;
				const cells = root.querySelectorAll(
					".weapon-table tbody tr:not(.abilities-row) td"
				);
				cells.forEach((td) => fitTextToCell(td));
			}

			// ------------------------------
			// Data Models
			// ------------------------------
			/** @typedef {{name:string, models?:number, woundsPerModel?:number, keywords?:string[], abilities?:string[]}} ImportedUnit */

			const PHASES = [
				"Command",
				"Movement",
				"Shooting",
				"Charge",
				"Fight",
				"Battleshock",
			];

			const defaultArmy = () => ({ faction: "", units: [] });

			function deepClone(o) {
				return JSON.parse(JSON.stringify(o));
			}

			function makeId() {
				return Math.random().toString(36).slice(2, 9);
			}

			function nowISO() {
				return new Date().toISOString();
			}

			function log(msg) {
				const el = document.getElementById("log");
				if (!el) return; // no log panel present; skip
				const div = document.createElement("div");
				div.className = "item";
				div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
				el.prepend(div);
				while (el.children.length > 200) el.removeChild(el.lastChild);
			}

			function findUnitOwner(unitId) {
				for (let pi = 0; pi < State.players.length; pi++) {
					const arr = State.players[pi].units || [];
					const idx = arr.findIndex((u) => u.id === unitId);
					if (idx > -1) return { playerIdx: pi, index: idx, arr };
				}
				return null;
			}
			function removeUnitById(unitId) {
				const owner = findUnitOwner(unitId);
				if (!owner) return false;
				const unit = owner.arr[owner.index];
				owner.arr.splice(owner.index, 1);
				log(`Removed ${unit.name} from the battlefield.`);
				return true;
			}

			// Modal helpers
			function openSetupModal() {
				const m = document.getElementById("setupModal");
				if (m) m.classList.add("active");
			}
			function closeSetupModal() {
				const m = document.getElementById("setupModal");
				if (m) m.classList.remove("active");
			}
			function openStartModal() {
				const m = document.getElementById("startModal");
				if (m) m.classList.add("active");
			}
			function closeStartModal() {
				const m = document.getElementById("startModal");
				if (m) m.classList.remove("active");
			}
			function isStartReady() {
				const p1Ready = !!(
					State.players[0] &&
					Array.isArray(State.players[0].units) &&
					State.players[0].units.length > 0
				);
				const p2Ready = !!(
					State.players[1] &&
					Array.isArray(State.players[1].units) &&
					State.players[1].units.length > 0
				);
				const missionReady = !!State.mission;
				return p1Ready && p2Ready && missionReady;
			}
			function updateStartBattleButton() {
				const btn = document.getElementById("btnStartBattle");
				const hint = document.querySelector("#startModal .modal-footer .hint");
				if (!btn) return;
				const ready = isStartReady();
				btn.disabled = !ready;
				btn.classList.toggle("primary", ready);
				if (hint) {
					hint.textContent = ready
						? "All set. Begin the battle!"
						: "Upload both army lists and select a mission to begin.";
				}
			}
			function resetStateForNewGame() {
				State.round = 1;
				State.currentPlayer = 0;
				State.phaseIndex = 0;
				State.autoGainCP = true;
				State.players = [
					{ name: "Player 1", cp: 0, vp: 0, army: defaultArmy(), units: [] },
					{ name: "Player 2", cp: 0, vp: 0, army: defaultArmy(), units: [] },
				];
				localStorage.removeItem("wh40k_tracker_state_v1");
				log("New game started.");
			}

			/** Game state */
			const State = {
				round: 1,
				currentPlayer: 0, // 0 = p1, 1 = p2
				phaseIndex: 0,
				autoGainCP: true,
				mission: null, // shared mission for this battle
				players: [
					{ name: "Player 1", cp: 0, vp: 0, army: defaultArmy(), units: [] },
					{ name: "Player 2", cp: 0, vp: 0, army: defaultArmy(), units: [] },
				],
				// A flat, serialisable unit model stored per player
				/** @returns {{round:number, player:number}} */
				turnId() {
					return { round: this.round, player: this.currentPlayer };
				},
			};

			function saveLocal() {
				localStorage.setItem("wh40k_tracker_state_v1", JSON.stringify(State));
			}
			function loadLocal() {
				const raw = localStorage.getItem("wh40k_tracker_state_v1");
				if (!raw) return;
				try {
					const data = JSON.parse(raw);
					// Basic migration guard
					if (!Array.isArray(data.players) || data.players.length !== 2) return;
					Object.assign(State, data);
				} catch (e) {
					console.warn("Failed to load local state", e);
				}
			}

			// ------------------------------
			// External data lookups (unitDatabase from data.js)
			// ------------------------------
			function canonicaliseFactionName(f) {
				if (!f || typeof f !== "string") return "";
				const s = f
					.toLowerCase()
					.replace(/[^a-z0-9\s\-']/g, "")
					.trim();
				// try exact keys as-is
				if (window.unitDatabase && window.unitDatabase[s]) return s;
				// normalise spaces -> dashes, drop apostrophes
				const k = s.replace(/\s+/g, "-").replace(/'+/g, "");
				if (window.unitDatabase && window.unitDatabase[k]) return k;
				// fuzzy: find any key that appears inside the text (e.g., "astra militarum" -> "imperial-guard" via alias keys created in data.js)
				if (window.unitDatabase) {
					const keys = Object.keys(window.unitDatabase);
					for (const key of keys) {
						if (s.includes(key)) return key;
					}
				}
				return k; // best effort
			}

			function findUnitProfileByName(name, factionHint) {
				if (!window.unitDatabase) return null;
				const n = (name || "").toLowerCase().trim();
				const fKey = canonicaliseFactionName(factionHint || "");

				const tryMatch = (arr) => {
					if (!Array.isArray(arr)) return null;
					// exact name first
					let prof = arr.find((u) => (u.name || "").toLowerCase() === n);
					if (prof) return prof;
					// loose contains (e.g., handle punctuation/case differences)
					prof = arr.find((u) => n.includes((u.name || "").toLowerCase()));
					return prof || null;
				};

				// 1) search within hinted faction (including aliases added in data.js)
				if (fKey && window.unitDatabase[fKey]) {
					const p = tryMatch(window.unitDatabase[fKey]);
					if (p) return p;
				}
				// 2) search across all factions as fallback
				for (const key of Object.keys(window.unitDatabase)) {
					const p = tryMatch(window.unitDatabase[key]);
					if (p) return p;
				}
				return null;
			}
			function renderCompositionHTML(lines) {
				if (!Array.isArray(lines) || !lines.length) {
					return '<span class="sub">No composition detected from PDF.</span>';
				}

				// Build HTML with proper nesting:
				// • Top level bullet opens a <li> (kept open until we see what's next)
				// ◦ Sub-bullets are nested inside a <ul> under the last <li>
				const out = [];
				out.push('<ul style="margin:6px 0 6px 18px">');

				let liOpen = false;
				let subOpen = false;

				const BULLET_TOP = /^[•●*\-]\s*/; // solid bullets & dashes
				const BULLET_SUB = /^(?:◦|○|°|∙|·|∘|o)\s*/i; // hollow/small bullets & 'o'

				const isTop = (s) => BULLET_TOP.test(s);
				const isSub = (s) => BULLET_SUB.test(s);

				for (const raw of lines) {
					const s = String(raw).trim();
					if (!s) continue;

					if (isTop(s)) {
						// Close previous sublist and li if needed
						if (subOpen) {
							out.push("</ul>");
							subOpen = false;
						}
						if (liOpen) {
							out.push("</li>");
							liOpen = false;
						}
						// Open new top-level li
						const text = s.replace(BULLET_TOP, "");
						out.push("<li>" + text);
						liOpen = true;
					} else if (isSub(s)) {
						// Ensure we have a parent <li>
						if (!liOpen) {
							out.push("<li>");
							liOpen = true;
						}
						// Open a nested <ul> if not already open
						if (!subOpen) {
							out.push('<ul style="margin:4px 0 4px 18px">');
							subOpen = true;
						}
						const text = s.replace(BULLET_SUB, "");
						out.push("<li>" + text + "</li>");
					}
				}

				// Close any open tags
				if (subOpen) out.push("</ul>");
				if (liOpen) out.push("</li>");
				out.push("</ul>");

				return out.join("");
			}
			// Layout helpers (no-op now that each column is independent)
			function relayoutMasonry(_) {
				/* no-op */
			}
			function relayoutAllGrids() {
				/* no-op */
			}
			// No resize listener needed anymore
			// ------------------------------
			// Helper for smooth expand/collapse of unit details
			function smoothToggle(el) {
				if (!el) return;
				const card = el.closest(".unit-card");
				const isOpening = !el.classList.contains("active");

				if (isOpening) {
					// Prepare: set to current height (0), then measure and animate to scrollHeight
					el.classList.add("active");
					if (card) card.classList.add("expanded");
					el.style.maxHeight = "0px"; // ensure we start collapsed
					// Next frame to allow transition
					requestAnimationFrame(() => {
						const target = el.scrollHeight;
						el.style.maxHeight = target + "px";
						const gridEarly = el.closest(".players");
						relayoutMasonry(gridEarly);
					});

					const onEnd = (e) => {
						if (e.propertyName === "max-height") {
							// Allow content growth while open
							el.style.maxHeight = "none";
							const grid = el.closest(".players");
							relayoutMasonry(grid);
							el.removeEventListener("transitionend", onEnd);
						}
					};
					el.addEventListener("transitionend", onEnd);
				} else {
					if (card) card.classList.remove("expanded");
					// Closing: set a fixed height first, then animate to 0
					const current = el.scrollHeight;
					el.style.maxHeight = current + "px";
					// force reflow to apply the fixed height before collapsing
					void el.offsetHeight; // reflow
					el.classList.remove("active");
					requestAnimationFrame(() => {
						el.style.maxHeight = "0px";
					});

					const onEnd = (e) => {
						if (e.propertyName === "max-height") {
							// Cleanup inline style when fully collapsed
							el.style.maxHeight = "";

							// ✨ Recompute the grid span now that we’re actually collapsed
							const grid = el.closest(".players");
							relayoutMasonry(grid);

							el.removeEventListener("transitionend", onEnd);
						}
					};
					el.addEventListener("transitionend", onEnd);
				}
			}
			// Units / Effects helpers
			// ------------------------------
			/** Create a tracked unit from an imported unit */
			function createUnit(u) {
				// pull wounds per model from data.js (unitDatabase) when available
				const factionHint =
					u.__faction || (State && State._importFactionHint) || "";
				const models = Number(u.models || 1);

				const profile = findUnitProfileByName(u.name || "Unit", factionHint);
				const wpmFromProfile = profile && Number(profile.wounds);

				const wpm = Number.isFinite(wpmFromProfile)
					? wpmFromProfile
					: Number(u.woundsPerModel || 1);

				const totalW = models * wpm;
				return {
					id: makeId(),
					name: u.name || "Unit",
					models,
					woundsPerModel: wpm,
					totalWounds: totalW,
					remainingWounds: totalW,
					keywords: Array.isArray(u.keywords)
						? u.keywords
						: typeof u.keywords === "string"
						? u.keywords
								.split(/[,;]+/)
								.map((s) => s.trim())
								.filter(Boolean)
						: profile && profile.role
						? [profile.role]
						: [],
					abilities: Array.isArray(u.abilities)
						? u.abilities
						: typeof u.abilities === "string"
						? u.abilities
								.split(/[,;]+/)
								.map((s) => s.trim())
								.filter(Boolean)
						: [],
					effects: [],
					composition: Array.isArray(u.composition) ? u.composition : [],
					stats: profile
						? {
								M: profile.movement,
								T: profile.toughness,
								Sv: profile.save,
								W: Number(profile.wounds),
								Ld: profile.leadership,
								OC: profile.oc,
						  }
						: null,
				};
			}

			function applyDamage(unit, delta) {
				const before = unit.remainingWounds;
				unit.remainingWounds = Math.max(
					0,
					Math.min(unit.totalWounds, unit.remainingWounds - delta)
				);
				const after = unit.remainingWounds;
				const change = after - before;

				if (change !== 0) {
					log(
						`${unit.name}: ${
							change < 0 ? `took ${-change}` : `healed ${change}`
						} wound(s). ${Math.max(after, 0)}/${unit.totalWounds} remain.`
					);
				}

				// When a unit reaches 0 wounds, offer to remove it. If cancelled, keep it at 1W.
				if (after === 0) {
					const ok = confirm(
						`${unit.name} has 0 wounds remaining.\nRemove it from the battlefield?`
					);
					if (ok) {
						// remove from state
						removeUnitById(unit.id);
					} else {
						// restore to 1W in case the reduction was a mistake
						unit.remainingWounds = 1;
						log(`${unit.name}: kept on the table at 1 wound.`);
					}
				}
			}

			function currentPhase() {
				return PHASES[State.phaseIndex];
			}

			function nextPhase() {
				const oldPhase = State.phaseIndex;
				const oldTurn = { round: State.round, player: State.currentPlayer };
				// advance
				if (State.phaseIndex < PHASES.length - 1) {
					State.phaseIndex++;
					expireEffects({
						phaseAdvanced: true,
						turnChanged: false,
						oldTurn,
						oldPhase,
					});
					onPhaseStart();
				} else {
					// Leaving Battleshock -> next player's Command
					State.phaseIndex = 0;
					State.currentPlayer = State.currentPlayer === 0 ? 1 : 0;
					if (State.currentPlayer === 0) State.round++;
					expireEffects({
						phaseAdvanced: true,
						turnChanged: true,
						oldTurn,
						oldPhase,
					});
					onPhaseStart();
				}
				render();
				saveLocal();
				// If stratagems modal is open, refresh its contents for the new context
				if (__openStratForPlayer !== null) {
					const listEl = document.getElementById("stratList");
					if (listEl) renderStratListInto(listEl, __openStratForPlayer);
				}
			}

			function prevPhase() {
				if (State.phaseIndex > 0) {
					State.phaseIndex--;
					render();
					saveLocal();
					return;
				}
				// going back from Command -> previous player's Battleshock
				if (State.round === 1 && State.currentPlayer === 0) return; // at start
				State.phaseIndex = PHASES.length - 1;
				State.currentPlayer = State.currentPlayer === 0 ? 1 : 0;
				if (State.currentPlayer === 1)
					State.round = Math.max(1, State.round - 1);
				render();
				saveLocal();
				// If stratagems modal is open, refresh its contents for the new context
				if (__openStratForPlayer !== null) {
					const listEl = document.getElementById("stratList");
					if (listEl) renderStratListInto(listEl, __openStratForPlayer);
				}
			}

			function onPhaseStart() {
				if (State.phaseIndex === 0 && State.autoGainCP) {
					const p = State.players[State.currentPlayer];
					p.cp += 1;
					log(`${p.name} gains +1 CP (Command phase).`);
				}
			}

			function expireEffects(ctx) {
				// ctx: {phaseAdvanced:boolean, turnChanged:boolean, oldTurn:{round,player}, oldPhase:number}
				for (const player of State.players) {
					for (const unit of player.units) {
						const keep = [];
						for (const ef of unit.effects || []) {
							let remove = false;
							if (ef.expiry === "phase" && ctx.phaseAdvanced) {
								// Remove on any phase advance after creation phase within the same turn
								if (
									ef.createdAt.round === ctx.oldTurn.round &&
									ef.createdAt.player === ctx.oldTurn.player
								) {
									remove = true;
								}
							} else if (ef.expiry === "turn" && ctx.turnChanged) {
								if (
									ef.createdAt.round === ctx.oldTurn.round &&
									ef.createdAt.player === ctx.oldTurn.player
								) {
									remove = true;
								}
							} else if (ef.expiry === "opponentTurn" && ctx.turnChanged) {
								// Opponent's turn just ended if new current player equals ef.createdAt.player
								const newPlayer = ctx.oldTurn.player === 0 ? 1 : 0;
								if (newPlayer === ef.createdAt.player) {
									remove = true;
								}
							} else if (ef.expiry === "rounds") {
								if (State.round >= ef.createdAt.round + (ef.rounds || 1))
									remove = true;
							}
							if (remove) {
								log(`${unit.name}: Effect ended — ${ef.name}`);
							}
							if (!remove) keep.push(ef);
						}
						unit.effects = keep;
					}
				}
			}

			// ------------------------------
			// PDF Import Helpers (Battlescribe/Wahapedia style lists)
			// ------------------------------
			async function readPdfText(file) {
				const pdfjs =
					window.__pdfjs || window.pdfjsLib || window["pdfjs-dist/build/pdf"];
				if (!pdfjs) throw new Error("PDF.js not loaded");
				const buf = await file.arrayBuffer();
				const doc = await pdfjs.getDocument({ data: buf }).promise;
				let text = "";
				for (let p = 1; p <= doc.numPages; p++) {
					const page = await doc.getPage(p);
					const content = await page.getTextContent();

					// Reconstruct lines using hasEOL so bullets and their text stay together.
					let line = "";
					const pageLines = [];
					for (const it of content.items) {
						const s = "str" in it ? it.str : it?.unicode || "";
						line += s;
						if (it.hasEOL) {
							pageLines.push(line.trim());
							line = "";
						} else {
							line += " ";
						}
					}
					if (line.trim()) pageLines.push(line.trim());

					text += pageLines.join("\n") + "\n";
				}
				return text;
			}

			function parseArmyPdfText(raw) {
				// Normalize whitespace and split lines
				const text = raw
					.replace(/\u00A0/g, " ")
					.replace(/[\r\t]+/g, " ")
					.replace(/ +/g, " ")
					.trim();
				const lines = text
					.split(/\n+/)
					.map((s) => s.trim())
					.filter(Boolean);

				const SECTION_HEADERS = new Set([
					"CHARACTERS",
					"BATTLELINE",
					"DEDICATED TRANSPORTS",
					"OTHER DATASHEETS",
					"ALLIED UNITS",
					"LORD OF WAR",
					"ELITES",
					"FAST ATTACK",
					"HEAVY SUPPORT",
					"FLYER",
				]);

				// Try to infer faction and army name from the first 20 lines
				let faction = "";
				let army_name = "";
				for (let i = 0; i < Math.min(20, lines.length); i++) {
					const L = lines[i];
					if (!army_name && /Points\)/i.test(L))
						army_name = L.replace(/\s*\(.*$/, "").trim();
					if (
						!faction &&
						/(Astra Militarum|Space Marines|Chaos|Tyranids|Adept[a]? Sororitas|Orks|Adeptus Mechanicus|Necrons|T'au|Eldar|Leagues of Votann|Genestealer Cults)/i.test(
							L
						)
					)
						faction = L;
				}

				// --- Helper: model line detection and tokens ---
				const WEAPON_TOKENS = [
					"lasgun",
					"lascannon",
					"plasma",
					"melta",
					"flamer",
					"grenade",
					"missile",
					"launcher",
					"bolter",
					"bolt",
					"pistol",
					"rifle",
					"cannon",
					"stubber",
					"mortar",
					"autocannon",
					"autogun",
					"sword",
					"chainsword",
					"knife",
					"power",
					"gauntlet",
					"spitter",
					"devourer",
					"claw",
					"talon",
					"talons",
					"bonesword",
					"barbed",
					"hammer",
					"maul",
					"blade",
					"carbine",
					"shotgun",
					"volley",
					"hot-shot",
					"hot‑shot",
					"hot–shot",
					"vox",
					"vox-caster",
					"voxcaster",
					"weapon",
				];
				function isProbablyModelLine(s) {
					const line = s.trim();
					// Ignore sub-bullets (wargear) like "◦  9x Close combat weapon"
					if (line.startsWith("◦")) return false;
					// Only count top-level bullets that start with •, -, or *
					const m = line.match(/^[•\-*]\s*(\d+)x\s+([A-Za-z][A-Za-z\-\s'’]+)/);
					if (!m) return false;
					const text = m[2].toLowerCase();
					// Filter typical wargear/weapon words
					if (text.includes("weapon")) return false;
					if (WEAPON_TOKENS.some((tok) => text.includes(tok))) return false;
					return true;
				}

				// Identify unit headers like "Kasrkin (110 Points)" or "Hormagaunts (65 Points)"
				const unitHeader = /^(.*)\((\d+) Points\)$/i;
				let seenSectionHeader = false;
				const units = [];
				for (let i = 0; i < lines.length; i++) {
					const L = lines[i];
					if (SECTION_HEADERS.has(L.toUpperCase())) {
						seenSectionHeader = true;
						continue;
					}
					// Only consider unit headers after we have seen at least one section header
					const m = seenSectionHeader ? L.match(unitHeader) : null;
					if (m) {
						const name = m[1].trim();
						// Collect following lines until next header or section
						const block = [];
						let j = i + 1;
						for (; j < lines.length; j++) {
							const nL = lines[j];
							if (SECTION_HEADERS.has(nL.toUpperCase()) || unitHeader.test(nL))
								break;
							block.push(nL);
						}
						i = j - 1;
						// Merge bullet-only lines with the next NON-empty text line.
						// Some PDFs render bullets (• / ◦) on their own line, then the content on a later line.
						// We also skip over empty spacer lines before merging.
						const merged = [];
						const isTopBulletOnly = (s) => /^[•●*\-]\s*$/.test(s);
						const isSubBulletOnly = (s) => /^(?:◦|○|°|∙|·|∘|o)\s*$/i.test(s);
						const isBulletOnly = (s) =>
							isTopBulletOnly(s) || isSubBulletOnly(s);
						const hasBulletWithText = (s) =>
							/^(?:[•●*\-]|[◦○°∙·∘o])\s+/.test(s);

						for (let k = 0; k < block.length; k++) {
							const a = (block[k] || "").trim();

							if (isBulletOnly(a)) {
								// Seek forward to the next non-empty line
								let m = k + 1;
								while (m < block.length && !(block[m] || "").trim()) m++;
								if (m < block.length) {
									const next = (block[m] || "").trim();
									if (hasBulletWithText(next)) {
										// The next line already has a bullet + text; just use that instead of the lone bullet
										merged.push(next);
									} else {
										// Append the text to the bullet symbol we saw on its own
										merged.push(a + " " + next);
									}
									k = m; // skip the consumed line(s)
								} else {
									// Nothing to merge with; keep the bullet so it is visible
									merged.push(a);
								}
								continue;
							}

							// Normal line
							merged.push(a);
						}

						// Capture composition bullets from the merged block
						const comp = [];
						for (const tRaw of merged) {
							const t = (tRaw || "").trim();
							if (/^(?:[•●*\-]|[◦○°∙·∘o])\s*/i.test(t)) comp.push(t);
						}
						// Count models like "10x Hormagaunt", "1x Sergeant", etc., but only likely model lines
						let models = 0;
						for (const b of block) {
							if (!isProbablyModelLine(b)) continue;
							const mx = b.match(/(\d+)x\s+/i);
							if (mx) models += parseInt(mx[1], 10);
						}
						if (!models) models = 1; // Vehicles/solitary models default to 1
						units.push({
							name,
							models,
							woundsPerModel: 1,
							keywords: [],
							abilities: [],
							composition: comp,
						});
					}
				}

				return { faction, army_name: army_name || "Imported PDF", units };
			}

			async function processArmyFileForPlayer(f, targetIdx) {
				try {
					if (!(f.type === "application/pdf" || /\.pdf$/i.test(f.name))) {
						alert("Please upload a PDF army list.");
						return;
					}
					const raw = await readPdfText(f);
					const army = parseArmyPdfText(raw);

					State.players[targetIdx].army = {
						faction: army.faction || "",
						army_name: army.army_name || "",
						units: [],
					};
					State._importFactionHint = army.faction || "";
					const _factionHint = army.faction || "";

					State.players[targetIdx].units = (army.units || []).map((u) =>
						createUnit({ ...u, __faction: _factionHint })
					);

					updateStartBattleButton();
					log(
						`${State.players[targetIdx].name}: Imported ${army.units.length} unit(s) from PDF.`
					);
					render();
					saveLocal();
				} catch (err) {
					console.error(err);
					alert("Import failed: " + (err.message || err));
				}
			}

			// ------------------------------
			// Dice Roller
			// ------------------------------
			function parseDiceExpr(expr) {
				// Supports: NdM+K / NdM-K / d6 / 6 / 6d6
				expr = (expr || "").toString().trim();
				if (!expr) return null;
				const m =
					expr.match(/^(\d+)?d(\d+)([+-]\d+)?$/i) || expr.match(/^(\d+)$/);
				if (!m) return null;
				if (m[0].includes("d")) {
					const num = parseInt(m[1] || "1", 10);
					const sides = parseInt(m[2], 10);
					const mod = m[3] ? parseInt(m[3], 10) : 0;
					return { num, sides, mod };
				} else {
					const num = parseInt(m[1], 10);
					return { num, sides: 6, mod: 0 };
				}
			}

			function rollDice(num, sides) {
				const out = [];
				for (let i = 0; i < num; i++)
					out.push(1 + Math.floor(Math.random() * sides));
				return out;
			}

			function doRoll(expr, tn) {
				const spec = parseDiceExpr(expr);
				if (!spec) return { err: "Bad expression" };
				const rolls = rollDice(spec.num, spec.sides);
				const total = rolls.reduce((a, b) => a + b, 0) + spec.mod;
				let successes = null;
				if (tn && Number.isFinite(tn))
					successes = rolls.filter((v) => v >= tn).length;
				return { spec, rolls, total, successes };
			}
			function renderDiceFaces(container, num, sides) {
				container.innerHTML = "";
				const maxShow = Math.min(num, 10);
				for (let i = 0; i < maxShow; i++) {
					const d = document.createElement("div");
					d.className = "die spin";
					d.textContent =
						1 + Math.floor(Math.random() * Math.max(2, Math.min(20, sides)));
					container.appendChild(d);
				}
				if (num > maxShow) {
					const more = document.createElement("span");
					more.className = "more-badge";
					more.textContent = `+${num - maxShow} more`;
					container.appendChild(more);
				}
			}

			function tickDiceFaces(container, sides) {
				container.querySelectorAll(".die").forEach((el) => {
					el.textContent =
						1 + Math.floor(Math.random() * Math.max(2, Math.min(20, sides)));
				});
			}

			function runDiceAnimation(spec, finalRolls) {
				return new Promise((resolve) => {
					const anim = document.getElementById("diceAnim");
					if (!anim) return resolve();

					// Build spinning dice placeholders
					renderDiceFaces(anim, spec.num, spec.sides);

					const start = performance.now();
					const duration = Math.min(1500, 400 + spec.num * 80);
					const interval = setInterval(
						() => tickDiceFaces(anim, spec.sides),
						90
					);

					function end() {
						clearInterval(interval);
						// Pin the visible dice to the actual rolled results
						const diceEls = anim.querySelectorAll(".die");
						const show = Math.min(spec.num, diceEls.length);
						for (let i = 0; i < show; i++) {
							diceEls[i].textContent = finalRolls[i];
						}
						diceEls.forEach((d) => d.classList.remove("spin"));
						resolve();
					}
					function raf(t) {
						if (t - start >= duration) return end();
						requestAnimationFrame(raf);
					}
					requestAnimationFrame(raf);
				});
			}
			// ------------------------------
			// Stratagems UI (Core + Faction)
			// Expects: window.getStratagemsForContext(faction, phase, whoseTurn)
			// and (optionally) window.coreStratagems for tagging.
			// ------------------------------
			let __openStratForPlayer = null; // remember which player's list is open

			function stratagemTurnLabel(playerIdx) {
				return State.currentPlayer === playerIdx
					? "your turn"
					: "opponent's turn";
			}
			function humanPhaseLabel() {
				return PHASES[State.phaseIndex] || "";
			}
			function renderStratListInto(container, playerIdx) {
				if (!container) return;

				const faction =
					(State.players[playerIdx].army &&
						State.players[playerIdx].army.faction) ||
					"";
				const whose =
					State.currentPlayer === playerIdx ? "current" : "opponent";
				const phase = humanPhaseLabel();

				let list = [];
				if (typeof window.getStratagemsForContext === "function") {
					try {
						list = window.getStratagemsForContext(faction, phase, whose) || [];
					} catch (e) {
						console.warn("getStratagemsForContext failed:", e);
					}
				}

				const coreSet = new Set(
					(window.coreStratagems || []).map((s) =>
						(s.key || s.name || "").toLowerCase()
					)
				);
				const groups = { faction: [], core: [] };

				for (const s of list) {
					const key = (s.key || s.name || "").toLowerCase();
					if (s.source === "core" || coreSet.has(key)) groups.core.push(s);
					else groups.faction.push(s);
				}

				const mkCard = (s) => {
					const phases = Array.isArray(s.phases)
						? s.phases.join(", ")
						: s.phase || s.phases || "any";
					const timing = s.timing ? `<div class="muted">${s.timing}</div>` : "";
					const type = s.type ? `<span class="chip">${s.type}</span>` : "";
					const turn = s.turn ? `<span class="chip">${s.turn}</span>` : "";
					const phaseChip = phases
						? `<span class="chip">Phase: ${phases}</span>`
						: "";
					const target = s.target
						? `<span class="chip">Target: ${s.target}</span>`
						: "";
					const cost = s.cost != null ? s.cost : 1;
					return `
			   <div class="strat-card">
			     <div class="strat-head">
			       <strong>${s.name || s.key}</strong>
			       <span class="cp-badge">${cost} CP</span>
			     </div>
			     ${timing}
			     <div class="sub" style="margin-top:4px">${s.description || ""}</div>
			     <div class="chips">
			       ${phaseChip}
			       ${type}
			       ${turn}
			       ${target}
			     </div>
			   </div>
			 `;
				};

				const ctxText = `Showing stratagems for ${phase} • ${stratagemTurnLabel(
					playerIdx
				)} • ${faction || "Faction"}`;
				const ctxEl = document.getElementById("stratContext");
				if (ctxEl) ctxEl.textContent = ctxText;

				const parts = [];
				if (groups.faction.length) {
					parts.push(
						`<div class="strat-section-title">Faction Stratagems</div>`
					);
					parts.push(groups.faction.map(mkCard).join(""));
				}
				if (groups.core.length) {
					parts.push(`<div class="strat-section-title">Core Stratagems</div>`);
					parts.push(groups.core.map(mkCard).join(""));
				}
				if (!parts.length) {
					parts.push(
						'<div class="sub">No stratagems found for this context. (Make sure data.js defines coreStratagems and getStratagemsForContext.)</div>'
					);
				}
				container.innerHTML = parts.join("");
			}

			function openStratModalFor(playerIdx) {
				__openStratForPlayer = playerIdx;
				const m = document.getElementById("stratModal");
				const t = document.getElementById("stratTitle");
				if (t) {
					const pname =
						State.players[playerIdx].name || `Player ${playerIdx + 1}`;
					t.textContent = `Stratagems — ${pname}`;
				}
				const listEl = document.getElementById("stratList");
				renderStratListInto(listEl, playerIdx);
				if (m) m.classList.add("active");
			}
			function closeStratModal() {
				__openStratForPlayer = null;
				const m = document.getElementById("stratModal");
				if (m) m.classList.remove("active");
			}
			// ------------------------------
			// Missions (10th Edition) — placeholder until data.js is updated
			// Expects window.missions = [{key,name,pack,type,summary,primary,deployment,notes}]
			// ------------------------------
			function getAvailableMissions() {
				if (Array.isArray(window.missions) && window.missions.length)
					return window.missions;
				// Temporary placeholders (we’ll replace with real data from data.js)
				return [
					{
						key: "scorched-earth",
						name: "Scorched Earth",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Primary: hold objectives; burn in opponent territory.",
						deployment: "Dawn of War",
					},
					{
						key: "take-and-hold",
						name: "Take and Hold",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Primary: hold more at the end of each round.",
						deployment: "Hammer and Anvil",
					},
					{
						key: "supply-drop",
						name: "Supply Drop",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Late-game shifting objectives with endgame scoring.",
						deployment: "Search and Destroy",
					},
				];
			}
			function pickRandomMission() {
				const list = getAvailableMissions();
				if (!list.length) return null;
				return list[Math.floor(Math.random() * list.length)];
			}
			function missionDisplayName(m) {
				return m ? m.name || m.key || "Mission" : "None";
			}
			function renderMissionSelected() {
				const el = document.getElementById("missionSelected");
				if (!el) return;
				if (!State.mission) {
					el.textContent = "None selected.";
					return;
				}
				const m = State.mission;
				el.innerHTML = `<strong>${missionDisplayName(
					m
				)}</strong><br><span class="sub">${m.pack || ""}${
					m.type ? " • " + m.type : ""
				}</span>`;
			}
			function renderMissionCardsInto(container) {
				const list = getAvailableMissions();
				container.innerHTML = "";
				list.forEach((m) => {
					const card = document.createElement("div");
					card.className =
						"mission-card" +
						(State.mission && State.mission.key === m.key ? " selected" : "");
					card.innerHTML = `
			   <div><strong>${m.name || m.key}</strong></div>
			   <div class="mission-meta">
			     ${m.pack ? `<span class="chip">${m.pack}</span>` : ""}
			     ${m.type ? `<span class="chip">${m.type}</span>` : ""}
			     ${m.deployment ? `<span class="chip">${m.deployment}</span>` : ""}
			   </div>
			   <div class="sub" style="margin-top:6px">${m.summary || ""}</div>
			 `;
					card.addEventListener("click", () => {
						State.mission = m;
						log(`Mission selected: ${missionDisplayName(m)}`);
						saveLocal();
						renderMissionSelected();
						updateStartBattleButton();
						renderMissionCardsInto(container); // refresh highlight
					});
					container.appendChild(card);
				});
			}
			function openMissionModal() {
				const m = document.getElementById("missionModal");
				if (!m) return;
				const body = document.getElementById("missionBody");
				const title = document.getElementById("missionTitle");
				const mis = State.mission;
				if (!mis) {
					title.textContent = "Mission";
					body.innerHTML =
						'<div class="sub">No mission selected. Open <em>Setup</em> → Mission Setup to draw or choose one.</div>';
				} else {
					title.textContent = mis.name || mis.key || "Mission";
					body.innerHTML = `
			   <div class="panel">
			     <div class="card-title">
			       <strong>${mis.name || mis.key}</strong>
			       ${mis.pack ? `<span class="badge">${mis.pack}</span>` : ""}
			     </div>
			     <div class="sub">
			       ${mis.type ? `<strong>Type:</strong> ${mis.type}<br>` : ""}
			       ${
								mis.deployment
									? `<strong>Deployment:</strong> ${mis.deployment}<br>`
									: ""
							}
			       ${mis.summary ? `<strong>Summary:</strong> ${mis.summary}` : ""}
			     </div>
			   </div>
			 `;
				}
				m.classList.add("active");
			}
			// ------------------------------
			// Faction helpers
			// ------------------------------
			function getFactionImage(factionText) {
				const key = canonicaliseFactionName(factionText || "");
				// Map using canonical keys (lowercase, hyphenated) + common raw labels as fallbacks
				const map = {
					// Astra Militarum / Imperial Guard
					"imperial-guard": "Imperial-Guard.jpg",
					"astra-militarum": "Imperial-Guard.jpg",
					"astra militarum": "Imperial-Guard.jpg",

					// Chaos Space Marines
					"chaos-marines": "chaos-marine.jpg",
					"chaos space marines": "chaos-marine.jpg",

					// Adepta Sororitas
					sisters: "sisters-of-battle.jpg",
					"adepta-sororitas": "sisters-of-battle.jpg",
					"adepta sororitas": "sisters-of-battle.jpg",

					// Space Marines
					"space-marines": "space-marines.jpg",
					"space marines": "space-marines.jpg",

					// Tyranids
					tyranids: "tyranids.jpeg",

					// Orks
					orks: "orks.jpg",

					// Eldar
					eldar: "Eldar.jpeg",
					Aeldari: "Eldar.jpeg",

					// Necron
					necron: "necron.jpg",
					necrons: "necron.jpg",
				};

				// Try canonical key first, then a lowercase raw fallback
				const rawLower = (factionText || "").toLowerCase().trim();
				return map[key] || map[rawLower] || null;
			}
			function getFactionLabel(factionText) {
				// Prefer the text from the import if present; otherwise map common keys to display names
				if (factionText && factionText.trim()) return factionText.trim();
				return "";
			}
			// ------------------------------
			// Rendering
			// ------------------------------
			function render() {
				document.getElementById("p1Name").value = State.players[0].name;
				document.getElementById("p2Name").value = State.players[1].name;
				document.getElementById("p1CP").value = State.players[0].cp;
				document.getElementById("p2CP").value = State.players[1].cp;
				document.getElementById("p1VP").value = State.players[0].vp;
				document.getElementById("p2VP").value = State.players[1].vp;

				document.getElementById(
					"roundBadge"
				).textContent = `Round ${State.round}`;
				document.getElementById("turnPlayerBadge").textContent =
					State.players[State.currentPlayer].name;

				// Phases
				const pills = document.getElementById("phasePills");
				pills.innerHTML = "";
				PHASES.forEach((p, idx) => {
					const span = document.createElement("span");
					span.className = "pill" + (idx === State.phaseIndex ? " active" : "");
					span.textContent = p;
					span.style.cursor = "help";
					span.title = "Click for phase help";
					span.addEventListener("click", () => {
						const html = PHASE_HELP[p] || "<p>No help available.</p>";
						openPhaseModal(p, html);
					});
					pills.appendChild(span);
				});

				// Headers
				document.getElementById(
					"p1Header"
				).textContent = `${State.players[0].name}`;
				document.getElementById(
					"p2Header"
				).textContent = `${State.players[1].name}`;

				// Faction meta (name + image)
				[0, 1].forEach((idx) => {
					const factionText =
						(State.players[idx].army && State.players[idx].army.faction) || "";
					const label = getFactionLabel(factionText);
					const imgFile = getFactionImage(factionText);
					const nameEl = document.getElementById(
						idx === 0 ? "p1Faction" : "p2Faction"
					);
					const imgEl = document.getElementById(
						idx === 0 ? "p1FactionImg" : "p2FactionImg"
					);
					if (nameEl) nameEl.textContent = label;
					if (imgEl) {
						if (imgFile) {
							imgEl.src = imgFile;
							imgEl.classList.remove("hidden");
							imgEl.alt = label || "Faction";
						} else {
							imgEl.removeAttribute("src");
							imgEl.classList.add("hidden");
						}
					}
				});

				// Units
				const mount = (playerIdx, rootId) => {
					const root = document.getElementById(rootId);
					const col1 = document.getElementById(rootId + "Col1");
					const col2 = document.getElementById(rootId + "Col2");
					if (!root || !col1 || !col2) return;

					// Clear both columns and alternate cards into them
					col1.innerHTML = "";
					col2.innerHTML = "";
					let colNext = 1;

					for (const unit of State.players[playerIdx].units) {
						const tpl = document.getElementById("unitTemplate");
						const node = tpl.content.cloneNode(true);
						const wrap = node.querySelector("[data-unit-id]");
						wrap.dataset.unitId = unit.id;

						// No data-col or grid-row spanning — columns are real, independent containers now

						wrap.querySelector(".unit-name").textContent = unit.name;
						const nameEl = wrap.querySelector(".unit-name");
						const detailsEl = wrap.querySelector("[data-details]");
						if (nameEl && detailsEl) {
							nameEl.setAttribute("role", "button");
							nameEl.setAttribute("tabindex", "0");
							nameEl.setAttribute("aria-expanded", "false");

							const doToggle = () => {
								const willOpen = !detailsEl.classList.contains("active");
								smoothToggle(detailsEl);
								nameEl.setAttribute(
									"aria-expanded",
									willOpen ? "true" : "false"
								);
							};

							nameEl.addEventListener("click", doToggle);
							nameEl.addEventListener("keydown", (ev) => {
								if (ev.key === "Enter" || ev.key === " ") {
									ev.preventDefault();
									doToggle();
								}
							});
						}

						const kw =
							unit.keywords && unit.keywords.length
								? unit.keywords.join(" • ")
								: "";
						wrap.querySelector(".keywords").textContent = kw;
						wrap.querySelector("[data-models]").textContent =
							unit.models && unit.woundsPerModel
								? `${unit.models} model(s) • ${unit.woundsPerModel}W each`
								: "";

						const pct =
							unit.totalWounds === 0
								? 0
								: Math.max(
										0,
										Math.min(
											100,
											Math.round(
												(100 * unit.remainingWounds) / unit.totalWounds
											)
										)
								  );
						wrap.querySelector(".bar > span").style.width = pct + "%";
						wrap.querySelector(
							"[data-wounds]"
						).textContent = `${unit.remainingWounds}/${unit.totalWounds}`;

						wrap.querySelectorAll("[data-dmg]").forEach((btn) => {
							btn.addEventListener("click", () => {
								const d = Number(btn.getAttribute("data-dmg"));
								applyDamage(unit, d);
								saveLocal();
								render();
							});
						});

						wrap
							.querySelector("[data-remove]")
							.addEventListener("click", () => {
								if (confirm(`Remove ${unit.name}?`)) {
									const arr = State.players[playerIdx].units;
									const idx = arr.findIndex((x) => x.id === unit.id);
									if (idx > -1) {
										arr.splice(idx, 1);
										saveLocal();
										render();
									}
								}
							});

						const efRoot = wrap.querySelector("[data-effects]");
						efRoot.innerHTML = "";
						(unit.effects || []).forEach((ef) => {
							const chip = document.createElement("span");
							chip.className = "effect-chip";
							const exp =
								ef.expiry === "persistent"
									? "∞"
									: ef.expiry === "phase"
									? "end of phase"
									: ef.expiry === "turn"
									? "end of turn"
									: ef.expiry === "opponentTurn"
									? "end of opponent's turn"
									: `+${ef.rounds || 1} round(s)`;
							chip.innerHTML = `${ef.name} <small>(${exp})</small> <button title="Remove">✕</button>`;
							chip.querySelector("button").addEventListener("click", () => {
								unit.effects = (unit.effects || []).filter(
									(x) => x.id !== ef.id
								);
								log(`${unit.name}: Removed effect — ${ef.name}`);
								saveLocal();
								render();
							});
							efRoot.appendChild(chip);
						});

						// Weapons UI hookup
						const listEl = wrap.querySelector("[data-weapons]");
						const panelEl = wrap.querySelector("[data-weapon-panel]");
						renderWeaponsForUnit(unit, listEl, panelEl);

						// Append the card into the current column, alternating 1,2,1,2…
						const targetCol = colNext === 1 ? col1 : col2;
						colNext = colNext === 1 ? 2 : 1;
						targetCol.appendChild(node);

						// Add effect
						wrap
							.querySelector("[data-add-effect]")
							.addEventListener("click", () => {
								promptAddEffect(unit);
							});
						const statRoot = wrap.querySelector("[data-statline]");
						if (statRoot) {
							statRoot.innerHTML = "";
							const s = unit.stats;
							if (s) {
								const mk = (label, val) => {
									const sp = document.createElement("span");
									sp.className = "tag";
									sp.textContent = `${label}: ${val ?? "-"}`;
									return sp;
								};
								statRoot.appendChild(mk("M", s.M));
								statRoot.appendChild(mk("T", s.T));
								statRoot.appendChild(mk("Sv", s.Sv != null ? s.Sv + "+" : "-"));
								statRoot.appendChild(mk("W", s.W));
								statRoot.appendChild(mk("Ld", s.Ld != null ? s.Ld + "+" : "-"));
								statRoot.appendChild(mk("OC", s.OC));
							} else {
								statRoot.innerHTML =
									'<span class="sub">No stats found in data.js for this unit.</span>';
							}
						}
						const compRoot = wrap.querySelector("[data-composition]");
						if (compRoot)
							compRoot.innerHTML = renderCompositionHTML(unit.composition);
						// Weapons list + details panel
						const wListEl = wrap.querySelector("[data-weapons]");
						const wPanelEl = wrap.querySelector("[data-weapon-panel]");
						renderWeaponsForUnit(unit, wListEl, wPanelEl);
						root.appendChild(node);
					}
				};
				// Update selected mission preview in Setup
				renderMissionSelected();
				mount(0, "p1Units");
				mount(1, "p2Units");
				updateStartBattleButton();
				relayoutAllGrids();
			}

			function promptAddEffect(unit) {
				const name = prompt(
					"Effect name (e.g., Transhuman, Cover, Battle-shock):"
				);
				if (!name) return;
				const opts = prompt(
					"Expiry: phase | turn | opponentTurn | rounds | persistent",
					"turn"
				);
				if (!opts) return;
				let expiry = opts.trim();
				let rounds = 1;
				if (expiry === "rounds") {
					const r = Number(prompt("How many rounds?", "1"));
					if (Number.isFinite(r) && r > 0) rounds = r;
					else rounds = 1;
				}
				const ef = {
					id: makeId(),
					name: name.trim(),
					expiry,
					rounds,
					createdAt: {
						round: State.round,
						player: State.currentPlayer,
						phaseIndex: State.phaseIndex,
						iso: nowISO(),
					},
				};
				if (!unit.effects) unit.effects = [];
				unit.effects.push(ef);
				log(
					`${unit.name}: Added effect — ${ef.name} (${
						expiry === "persistent" ? "∞" : expiry
					})`
				);
				saveLocal();
				render();
			}

			// ------------------------------
			// Bootstrap / Events
			// ------------------------------
			function bind() {
				// Names
				document.getElementById("p1Name").addEventListener("input", (e) => {
					State.players[0].name = e.target.value;
					render();
					updateStartBattleButton();
					saveLocal();
				});
				document.getElementById("p2Name").addEventListener("input", (e) => {
					State.players[1].name = e.target.value;
					render();
					saveLocal();
				});

				// CP / VP buttons
				document.querySelectorAll("[data-cp]").forEach((btn) => {
					btn.addEventListener("click", () => {
						const who = btn.getAttribute("data-cp") === "p1" ? 0 : 1;
						const delta = Number(btn.getAttribute("data-delta"));
						State.players[who].cp = Math.max(
							0,
							Number(State.players[who].cp) + delta
						);
						saveLocal();
						render();
					});
				});
				document.querySelectorAll("[data-vp]").forEach((btn) => {
					btn.addEventListener("click", () => {
						const who = btn.getAttribute("data-vp") === "p1" ? 0 : 1;
						const delta = Number(btn.getAttribute("data-delta"));
						State.players[who].vp = Math.max(
							0,
							Number(State.players[who].vp) + delta
						);
						saveLocal();
						render();
					});
				});
				document.getElementById("p1CP").addEventListener("input", (e) => {
					State.players[0].cp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p2CP").addEventListener("input", (e) => {
					State.players[1].cp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p1VP").addEventListener("input", (e) => {
					State.players[0].vp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p2VP").addEventListener("input", (e) => {
					State.players[1].vp = Number(e.target.value || 0);
					saveLocal();
				});

				// Phase controls
				document
					.getElementById("btnNextPhase")
					.addEventListener("click", nextPhase);
				document
					.getElementById("btnPrevPhase")
					.addEventListener("click", prevPhase);
				document.getElementById("autoCP").addEventListener("change", (e) => {
					State.autoGainCP = !!e.target.checked;
					saveLocal();
				});

				// Save / Load
				document.getElementById("btnSave").addEventListener("click", () => {
					const blob = new Blob([JSON.stringify(State, null, 2)], {
						type: "application/json",
					});
					const a = document.createElement("a");
					a.href = URL.createObjectURL(blob);
					const d = new Date();
					a.download = `40k_tracker_round${State.round}_${d
						.toISOString()
						.slice(0, 10)}.json`;
					document.body.appendChild(a);
					a.click();
					a.remove();
				});
				document.getElementById("btnLoad").addEventListener("click", () => {
					document.getElementById("loadState").click();
				});
				document
					.getElementById("loadState")
					.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (!f) return;
						const text = await f.text();
						try {
							const data = JSON.parse(text);
							Object.assign(State, data);
							log("Loaded saved game state.");
							render();
							saveLocal();
						} catch (err) {
							alert("Bad state file.");
						}
					});

				// Setup modal toggles
				const btnSetup = document.getElementById("btnSetup");
				if (btnSetup) btnSetup.addEventListener("click", openSetupModal);
				const setupClose = document.getElementById("setupClose");
				if (setupClose) setupClose.addEventListener("click", closeSetupModal);
				// Close when clicking backdrop (outside dialog)
				const setupModal = document.getElementById("setupModal");
				if (setupModal) {
					setupModal.addEventListener("click", (e) => {
						if (e.target === setupModal) closeSetupModal();
					});
				}

				// Mission setup controls
				const btnMissionChoose = document.getElementById("btnMissionChoose");
				const missionChooser = document.getElementById("missionChooser");
				const missionGrid = document.getElementById("missionGrid");
				const btnMissionChooserClose = document.getElementById(
					"btnMissionChooserClose"
				);

				const btnMissionRandom = document.getElementById("btnMissionRandom");
				const modeRandom = document.getElementById("missionModeRandom");
				const modeChoose = document.getElementById("missionModeChoose");

				if (btnMissionRandom) {
					btnMissionRandom.addEventListener("click", () => {
						if (modeRandom) modeRandom.checked = true;
						const m = pickRandomMission();
						if (m) {
							State.mission = m;
							renderMissionSelected();
							updateStartBattleButton();
							saveLocal();
							log(`Random mission drawn: ${missionDisplayName(m)}`);
							if (missionChooser) missionChooser.classList.add("hidden");
						} else {
							alert(
								"No missions available yet. Add them to data.js as window.missions."
							);
						}
					});
				}

				if (btnMissionChoose) {
					btnMissionChoose.addEventListener("click", () => {
						if (modeChoose) modeChoose.checked = true;
						if (missionChooser) missionChooser.classList.remove("hidden");
						if (missionGrid) renderMissionCardsInto(missionGrid);
					});
				}

				if (btnMissionChooserClose) {
					btnMissionChooserClose.addEventListener("click", () => {
						if (missionChooser) missionChooser.classList.add("hidden");
					});
				}
				// Stratagems buttons (null-safe)
				const p1StratsBtn = document.getElementById("p1Strats");
				const p2StratsBtn = document.getElementById("p2Strats");
				if (p1StratsBtn)
					p1StratsBtn.addEventListener("click", () => openStratModalFor(0));
				if (p2StratsBtn)
					p2StratsBtn.addEventListener("click", () => openStratModalFor(1));

				// Stratagems modal close & backdrop (null-safe)
				const stratModal = document.getElementById("stratModal");
				const stratClose = document.getElementById("stratClose");
				if (stratClose) stratClose.addEventListener("click", closeStratModal);
				if (stratModal) {
					stratModal.addEventListener("click", (e) => {
						if (e.target === stratModal) closeStratModal();
					});
				}

				// Mission buttons (view; shared mission) — null-safe
				const p1MissionBtn = document.getElementById("p1Mission");
				const p2MissionBtn = document.getElementById("p2Mission");
				if (p1MissionBtn)
					p1MissionBtn.addEventListener("click", openMissionModal);
				if (p2MissionBtn)
					p2MissionBtn.addEventListener("click", openMissionModal);

				// Mission modal close & backdrop — null-safe
				const missionModal = document.getElementById("missionModal");
				const missionClose = document.getElementById("missionClose");
				if (missionClose) {
					missionClose.addEventListener("click", () => {
						if (missionModal) missionModal.classList.remove("active");
					});
				}
				if (missionModal) {
					missionModal.addEventListener("click", (e) => {
						if (e.target === missionModal)
							missionModal.classList.remove("active");
					});
				}

				// Start Game modal toggles
				const startModal = document.getElementById("startModal");
				const btnStartBattle = document.getElementById("btnStartBattle");
				// Keep the header close button hidden/disabled
				const startClose = document.getElementById("startClose");
				if (startClose) {
					startClose.style.display = "none";
					startClose.onclick = null;
				}
				if (btnStartBattle) {
					btnStartBattle.addEventListener("click", () => {
						if (!isStartReady()) return; // double-guard
						closeStartModal();
					});
				}
				if (startModal) {
					// Only allow backdrop-click close if setup is complete
					startModal.addEventListener("click", (e) => {
						if (e.target === startModal && isStartReady()) {
							closeStartModal();
						}
					});
				} // Phase Help modal toggles
				const phaseHelpClose = document.getElementById("phaseHelpClose");
				if (phaseHelpClose)
					phaseHelpClose.addEventListener("click", closePhaseModal);
				const phaseModal = document.getElementById("phaseModal");
				if (phaseModal) {
					phaseModal.addEventListener("click", (e) => {
						if (e.target === phaseModal) closePhaseModal();
					});
				}
				// Dice modal toggles
				const btnDice = document.getElementById("btnDice");
				if (btnDice)
					btnDice.addEventListener("click", () => {
						const m = document.getElementById("diceModal");
						if (m) m.classList.add("active");
						// Focus the dice expression input when opening the modal
						const diceExpr = document.getElementById("diceExpr");
						if (diceExpr) setTimeout(() => diceExpr.focus(), 0);
					});
				const diceClose = document.getElementById("diceClose");
				if (diceClose)
					diceClose.addEventListener("click", () => {
						const m = document.getElementById("diceModal");
						if (m) m.classList.remove("active");
					});
				const diceModal = document.getElementById("diceModal");
				if (diceModal) {
					diceModal.addEventListener("click", (e) => {
						if (e.target === diceModal) diceModal.classList.remove("active");
					});
				}

				// Help modal toggles
				const btnHelp = document.getElementById("btnHelp");
				if (btnHelp)
					btnHelp.addEventListener("click", () => {
						const m = document.getElementById("helpModal");
						if (m) m.classList.add("active");
					});
				const helpClose = document.getElementById("helpClose");
				if (helpClose)
					helpClose.addEventListener("click", () => {
						const m = document.getElementById("helpModal");
						if (m) m.classList.remove("active");
					});
				const helpModal = document.getElementById("helpModal");
				if (helpModal) {
					helpModal.addEventListener("click", (e) => {
						if (e.target === helpModal) helpModal.classList.remove("active");
					});
				}

				// About / Astronomican modal
				const appTitle = document.getElementById("appTitle");
				if (appTitle) {
					appTitle.addEventListener("click", () => {
						const m = document.getElementById("aboutModal");
						if (m) m.classList.add("active");
					});
				}
				const aboutClose = document.getElementById("aboutClose");
				if (aboutClose) {
					aboutClose.addEventListener("click", () => {
						const m = document.getElementById("aboutModal");
						if (m) m.classList.remove("active");
					});
				}
				const aboutModal = document.getElementById("aboutModal");
				if (aboutModal) {
					aboutModal.addEventListener("click", (e) => {
						if (e.target === aboutModal) aboutModal.classList.remove("active");
					});
				}
				// New Game
				const btnNewGame = document.getElementById("btnNewGame");
				if (btnNewGame) {
					btnNewGame.addEventListener("click", () => {
						if (
							confirm("Start a new battle? This will wipe the current state.")
						) {
							resetStateForNewGame();
							render();
							saveLocal();
							openStartModal();
						}
					});
				}
				// Importers (per-player)
				const btnImportP1 = document.getElementById("btnImportP1");
				const btnImportP2 = document.getElementById("btnImportP2");
				const fileP1 = document.getElementById("armyFileP1");
				const fileP2 = document.getElementById("armyFileP2");
				const fileNameP1 = document.getElementById("armyFileNameP1");
				const fileNameP2 = document.getElementById("armyFileNameP2");

				if (btnImportP1 && fileP1) {
					btnImportP1.addEventListener("click", () => fileP1.click());
					fileP1.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (fileNameP1)
							fileNameP1.textContent = f ? f.name : "No file chosen";
						if (!f) return;
						await processArmyFileForPlayer(f, 0); // ➜ Player 1
						e.target.value = ""; // reset
					});
				}

				if (btnImportP2 && fileP2) {
					btnImportP2.addEventListener("click", () => fileP2.click());
					fileP2.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (fileNameP2)
							fileNameP2.textContent = f ? f.name : "No file chosen";
						if (!f) return;
						await processArmyFileForPlayer(f, 1); // ➜ Player 2
						e.target.value = ""; // reset
					});
				}

				// Dice
				document
					.getElementById("btnRoll")
					.addEventListener("click", async () => {
						const expr = document.getElementById("diceExpr").value;
						const spec = parseDiceExpr(expr);
						if (!spec) {
							document.getElementById("diceOut").textContent =
								"Invalid expression. Use NdM+K (e.g. 6d6+2) or a single number (e.g. 20).";
							return;
						}

						// Roll ONCE and reuse for both animation + summary
						const res = doRoll(expr, null);

						// Animate, then lock the faces to the actual results
						await runDiceAnimation(res.spec, res.rolls);

						const parts = [
							`${res.spec.num}d${res.spec.sides}${
								res.spec.mod
									? res.spec.mod > 0
										? "+" + res.spec.mod
										: res.spec.mod
									: ""
							}`,
							`Rolls: [${res.rolls.join(", ")}]`,
							`Total: ${res.total}`,
						];
						const txt = parts.join(" • ");
						document.getElementById("diceOut").textContent = txt;
						log(`🎲 ${txt}`);
					});
				// Add Enter key handler for diceExpr input (null-safe)
				(function () {
					const diceExprEl = document.getElementById("diceExpr");
					const rollBtn = document.getElementById("btnRoll");
					if (diceExprEl && rollBtn) {
						diceExprEl.addEventListener("keydown", (e) => {
							if (e.key === "Enter") {
								e.preventDefault();
								rollBtn.click();
							}
						});
					}
				})();
				// Log (null-safe)
				const clearLogBtn = document.getElementById("btnClearLog");
				if (clearLogBtn) {
					clearLogBtn.addEventListener("click", () => {
						const logEl = document.getElementById("log");
						if (logEl) logEl.innerHTML = "";
					});
				}

				// Global Escape key closes any open modal (backdrops use the `active` class)
				document.addEventListener("keydown", (e) => {
					if (e.key === "Escape") {
						const sm = document.getElementById("startModal");
						if (sm && sm.classList.contains("active") && !isStartReady()) {
							// Block closing the Start Game modal until requirements are met
							return;
						}
						[
							"setupModal",
							"diceModal",
							"helpModal",
							"phaseModal",
							"aboutModal",
							"stratModal",
							"missionModal",
							"startModal",
						].forEach((id) => {
							const m = document.getElementById(id);
							if (m && m.classList.contains("active"))
								m.classList.remove("active");
						});
					}
				});
			}

			// ------------------------------
			// Init
			// ------------------------------
			loadLocal();
			bind();
			render();
			// Open Start Game on first load (no saved state yet)
			try {
				const raw = localStorage.getItem("wh40k_tracker_state_v1");
				if (!raw) openStartModal();
			} catch (_) {
				openStartModal();
			}
			onPhaseStart();
			// If no saved state (or no units), prompt setup — but never over the blocking Start Game modal
			try {
				const saved = localStorage.getItem("wh40k_tracker_state_v1");
				const noUnits =
					!State.players[0].units.length && !State.players[1].units.length;
				const sm = document.getElementById("startModal");
				const startBlocking =
					sm && sm.classList.contains("active") && !isStartReady();
				if (!startBlocking && (!saved || noUnits)) {
					openSetupModal();
				}
			} catch (e) {
				/* ignore */
			}
		</script>
	</body>
</html>
