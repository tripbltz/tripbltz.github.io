<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-touch-fullscreen" content="yes" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap"
			rel="stylesheet"
		/>
		<title>Astronomican 3.4</title>
		<style>
			:root {
				--bg: #0d0f12;
				--panel: #151a20;
				--panel-2: #1b2129;
				--text: #e6ebf2;
				--muted: #9fb0c3;
				--accent: #62d3ff;
				--accent-2: #ffd166;
				--danger: #ff6b6b;
				--ok: #2ecc71;
				--border: #26303b;
			}
			* {
				box-sizing: border-box;
			}
			html,
			body {
				height: 100%;
			}
			body {
				margin: 0;
				font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
					Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
				background: linear-gradient(180deg, #0b0e12, #0a0d11 30%, #0b0e12);
				color: var(--text);
			}
			.container {
				max-width: 1400px;
				margin: 0 auto;
				padding: 16px;
			}
			header {
				display: flex;
				gap: 12px;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 12px;
			}
			.app-title {
				font-weight: 800;
				letter-spacing: 0.5px;
				cursor: pointer;
			}
			.pirata-one-regular {
				font-family: "Pirata One", system-ui;
				font-weight: 400;
				font-style: normal;
			}
			/* === Imperial Terminal look for PoolHouseAI modal === */
			.imperial-terminal {
				font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
					"Liberation Mono", "Courier New", monospace;
			}

			/* CRT frame */
			.imperial-terminal .modal-dialog {
				position: relative;
				max-width: 720px;
				background: radial-gradient(
						circle at 50% -10%,
						rgba(46, 255, 134, 0.25),
						transparent 55%
					),
					#020b04;
				border: 1px solid #26ff6b;
				box-shadow: 0 0 30px rgba(38, 255, 107, 0.4);
				color: #caffd2;
			}

			/* scanline overlay */
			.imperial-terminal .modal-dialog::before {
				content: "";
				pointer-events: none;
				position: absolute;
				inset: 0;
				background-image: repeating-linear-gradient(
					to bottom,
					rgba(0, 0, 0, 0) 0,
					rgba(0, 0, 0, 0) 1px,
					rgba(0, 255, 90, 0.08) 2px
				);
				opacity: 0.6;
			}

			/* header block */
			.imperial-terminal .modal-header {
				border-bottom: 1px solid rgba(38, 255, 107, 0.35);
				background: rgba(0, 0, 0, 0.4);
			}

			.imperial-terminal .terminal-heading {
				text-align: center;
				width: 100%;
			}

			.imperial-terminal .terminal-title {
				font-size: 22px;
				letter-spacing: 0.3em;
				text-transform: uppercase;
				color: #26ff6b;
			}

			.imperial-terminal .terminal-subtitle {
				font-size: 11px;
				letter-spacing: 0.22em;
				text-transform: uppercase;
				color: #98ffb8;
				margin-top: 4px;
			}

			/* override old faction font inside this modal */
			.imperial-terminal .faction-name {
				font-family: inherit;
				font-size: 14px;
				text-transform: none;
				letter-spacing: 0;
			}

			/* panel + log */
			.imperial-terminal .panel {
				background: rgba(0, 0, 0, 0.45);
				border: 1px solid rgba(38, 255, 107, 0.4);
			}

			.imperial-terminal .card-title strong,
			.imperial-terminal .sub,
			.imperial-terminal #aiStatus {
				color: #baffc9;
			}

			.imperial-terminal .log {
				background: rgba(0, 0, 0, 0.55);
				border-color: rgba(38, 255, 107, 0.4);
				color: #a6ffc9;
			}

			.imperial-terminal .log .item {
				color: #a6ffc9;
				border-bottom-color: rgba(38, 255, 107, 0.25);
			}

			/* inputs + buttons */
			.imperial-terminal input[type="text"],
			.imperial-terminal textarea {
				background: rgba(0, 0, 0, 0.7);
				border: 1px solid rgba(38, 255, 107, 0.55);
				color: #e8ffe8;
			}

			.imperial-terminal button {
				background: transparent;
				border: 1px solid rgba(38, 255, 107, 0.6);
				color: #caffd2;
			}

			.imperial-terminal button.primary {
				background: rgba(12, 50, 20, 0.9);
				box-shadow: 0 0 10px rgba(38, 255, 107, 0.4);
			}

			.imperial-terminal button:hover {
				background: rgba(38, 255, 107, 0.1);
				box-shadow: 0 0 12px rgba(38, 255, 107, 0.55);
			}

			/* close button */
			.imperial-terminal .modal-close {
				border-radius: 50%;
				border-color: rgba(38, 255, 107, 0.6);
				color: #26ff6b;
			}
			.imperial-terminal .modal-close:hover {
				background: rgba(38, 255, 107, 0.15);
			}
			/* Stratagems */
			.strat-card {
				border: 1px solid var(--border);
				background: #121820;
				border-radius: 10px;
				padding: 10px;
				margin: 8px 0;
				cursor: pointer;
				transition: border-color 0.2s ease, background 0.2s ease;
			}
			.strat-card:hover {
				border-color: #38bdf8;
				background: #0f141a;
			}
			.strat-card.selected {
				border-color: #38bdf8;
				box-shadow: 0 0 0 1px #38bdf8;
				background: #0c121a;
			}
			.strat-head {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 8px;
				margin-bottom: 4px;
			}
			.cp-badge {
				font-size: 12px;
				padding: 2px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #14222c;
				color: #bfe9ff;
			}
			.chips {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.chip {
				font-size: 11px;
				border: 1px solid var(--border);
				border-radius: 999px;
				padding: 2px 6px;
				color: var(--muted);
				background: #0f141a;
			}
			.strat-body {
				display: none;
				margin-top: 6px;
			}
			.strat-card.expanded .strat-body {
				display: block;
			}
			.strat-card .subtle-hint {
				font-size: 11px;
				color: var(--muted);
			}
			.strat-footer {
				display: flex;
				justify-content: flex-start;
				align-items: center;
				gap: 10px;
				margin-top: 10px;
			}
			.strat-section-title {
				margin: 10px 0 4px 0;
				font-size: 13px;
				color: #d9e6f7;
			}
			.faction-name {
				font-family: "Pirata One", system-ui;
				font-weight: 400;
				font-style: normal;
				font-size: 30px;
				color: #e6ebf2;
			}
			.badge {
				padding: 2px 8px;
				border: 1px solid var(--border);
				border-radius: 999px;
				background: var(--panel);
				color: var(--muted);
				font-size: 12px;
			}
			.row {
				display: grid;
				gap: 12px;
			}
			@media (min-width: 1100px) {
				.row {
					grid-template-columns: 1fr 1fr;
				}
			}
			@media (max-width: 1099px) {
				.row {
					grid-template-columns: 1fr;
				}
			}

			.panel {
				background: linear-gradient(180deg, var(--panel), var(--panel-2));
				border: 1px solid var(--border);
				border-radius: 12px;
				padding: 12px;
			}
			.panel h3 {
				margin: 0 0 8px 0;
				font-size: 16px;
				color: var(--text);
			}
			.sub {
				font-size: 12px;
				color: var(--muted);
			}

			.controls {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				align-items: center;
			}
			.controls .group {
				display: flex;
				gap: 6px;
				align-items: center;
			}
			input[type="text"],
			input[type="number"],
			select,
			textarea {
				background: #0f141a;
				border: 1px solid var(--border);
				color: var(--text);
				padding: 8px 10px;
				border-radius: 8px;
				outline: none;
				min-width: 0;
			}
			textarea {
				width: 100%;
				min-height: 80px;
			}
			button {
				background: var(--panel-2);
				color: var(--text);
				border: 1px solid var(--border);
				padding: 8px 10px;
				border-radius: 8px;
				cursor: pointer;
			}
			button:hover {
				border-color: #3a495b;
			}
			button.primary {
				background: linear-gradient(180deg, #0c2730, #0a3b4b);
				border-color: #294a5a;
				color: #dff6ff;
			}
			button.danger {
				background: linear-gradient(180deg, #361414, #2c0e0e);
				border-color: #623434;
				color: #ffd0d0;
			}
			button.ghost {
				background: transparent;
			}

			/* Sleek select and custom file uploader */
			.input-row {
				display: flex;
				gap: 10px;
				align-items: stretch;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.select-wrap {
				position: relative;
				flex: 0 0 180px;
			}
			.select-wrap select.custom-select {
				appearance: none;
				-webkit-appearance: none;
				-moz-appearance: none;
				width: 100%;
				height: 38px;
				background: #0f141a;
				border: 1px solid var(--border);
				color: var(--text);
				padding: 8px 36px 8px 10px;
				border-radius: 8px;
				outline: none;
				cursor: pointer;
			}
			.select-wrap::after {
				content: "‚ñæ";
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
				pointer-events: none;
				color: var(--muted);
				font-size: 14px;
			}
			.file-uploader {
				display: inline-flex;
				align-items: center;
				gap: 8px;
				flex: 1 1 auto;
			}
			.file-uploader .filename-pill {
				display: inline-flex;
				align-items: center;
				max-width: 100%;
				padding: 6px 10px;
				border: 1px dashed var(--border);
				color: var(--muted);
				border-radius: 8px;
				min-height: 38px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			.file-uploader .btn-choose {
				height: 38px;
			}
			.player-import-row {
				display: flex;
				align-items: center;
				gap: 10px;
				flex-wrap: wrap;
			}
			.player-import-row input[type="text"] {
				flex: 1 1 240px;
				min-width: 180px;
			}
			.visually-hidden {
				position: absolute !important;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0 0 0 0);
				white-space: nowrap;
				border: 0;
			}

			.grid-2 {
				display: grid;
				gap: 10px;
				grid-template-columns: 1fr 1fr;
			}
			.grid-3 {
				display: grid;
				gap: 10px;
				grid-template-columns: repeat(3, 1fr);
			}

			.unit-card {
				border: 1px solid var(--border);
				border-radius: 10px;
				padding: 10px;
				background: #12171d;
				display: flex;
				gap: 10px;
				align-items: flex-start;
				align-self: start;
				/* Prevent splitting; enable masonry flow */
				break-inside: avoid;
				-webkit-column-break-inside: avoid;
				page-break-inside: avoid;
				margin: 0;
				min-width: 0;

				/* Grid-friendly: cards are grid items, no inline-block needed */
				width: 100%;
				transition: background 300ms ease, border-color 300ms ease,
					box-shadow 300ms ease;
			}

			.unit-card.expanded {
				background: linear-gradient(180deg, #151d25, #1a2530);
				border-color: #2d3b4b;
				box-shadow: inset 0 0 0 1px rgba(45, 59, 75, 0.35);
			}
			.unit-name {
				cursor: pointer;
			}
			.unit-details {
				/* smoother sliding reveal using inline max-height */
				max-height: 0;
				overflow: hidden;
				opacity: 0;
				transform: translateY(-6px);
				/* padding handled by inner wrapper to avoid end snap */
				will-change: max-height, opacity, transform;
				transition: max-height 600ms cubic-bezier(0.22, 1, 0.36, 1),
					opacity 600ms ease, transform 600ms ease;
				margin-top: 8px;
				border-top: 1px solid var(--border);
			}
			.unit-details.active {
				/* max-height is set inline by JS to the element's scrollHeight */
				opacity: 1;
				transform: translateY(0);
			}

			.unit-details-inner {
				padding: 8px 0; /* constant padding so the outer height animation doesn't "snap" at the end */
			}

			/* Respect users who prefer reduced motion */
			@media (prefers-reduced-motion: reduce) {
				.unit-details,
				.unit-details.active {
					transition: none !important;
					max-height: none !important;
					opacity: 1 !important;
					transform: none !important;
				}
			}
			.statline {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				margin: 6px 0;
			}
			.statline .tag {
				background: #0f141a;
			}
			.composition {
				font-size: 12px;
				color: var(--muted);
			}
			.weapon-grid {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.weapon-link {
				display: inline-flex;
				align-items: center;
				gap: 6px;
				padding: 4px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #121820;
				color: #cfe4ff;
				font-size: 12px;
				cursor: pointer;
			}
			.weapon-link:hover {
				border-color: #2d3b4b;
				background: #101720;
			}
			.weapon-panel {
				margin-top: 8px;
				border-top: 1px solid var(--border);
				padding-top: 8px;
				contain: layout;
			}
			.weapon-panel.hidden {
				display: none;
			}
			.weapon-table {
				width: 100%;
				border-collapse: collapse;
				font-size: 12px;
				table-layout: fixed;
			}
			.weapon-table th,
			.weapon-table td {
				border: 1px solid var(--border);
				padding: 6px 8px;
				text-align: left;
				background: #0f141a;
				overflow: hidden; /* keep cells from growing */
				text-overflow: clip; /* don't ellipsis; we'll autoshrink via JS */
				white-space: nowrap; /* keep single-line for stat cells */
				font-variant-numeric: tabular-nums; /* nicer alignment for numbers */
			}
			.weapon-table th {
				background: #121820;
				color: #eaf6ff;
			}
			.weapon-table .abilities-row td {
				white-space: normal; /* allow wrapping for long ability text */
				overflow: visible; /* show full content */
			}
			.unit-meta {
				flex: 1;
				min-width: 0;
			}
			.unit-name {
				font-weight: 700;
			}
			.kw {
				font-size: 11px;
				color: var(--muted);
				border: 1px solid var(--border);
				padding: 2px 6px;
				border-radius: 999px;
				margin-right: 4px;
			}
			.wounds {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-top: 6px;
			}
			.bar {
				position: relative;
				flex: 1;
				height: 10px;
				background: red;
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: hidden;
			}
			.bar > span {
				position: absolute;
				left: 0;
				top: 0;
				bottom: 0;
				background: linear-gradient(90deg, #1f815a, #1b9d74, #1ea77c);
			}
			.cnt {
				font-variant-numeric: tabular-nums;
			}

			/* Phase Help specific tweaks */
			#phaseModal .modal-dialog {
				width: 520px;
				max-width: 90vw;
			}
			#phaseHelpBody p {
				margin: 8px 0;
			}
			#phaseHelpBody ul {
				margin: 8px 0 0 18px;
			}

			.effect-chip {
				display: inline-flex;
				gap: 6px;
				align-items: center;
				border: 1px solid var(--border);
				background: #121820;
				padding: 4px 8px;
				border-radius: 999px;
				font-size: 12px;
				color: #cfe4ff;
				margin: 4px 6px 0 0;
			}
			.effect-chip small {
				color: #9fc4ff;
			}
			.effect-chip button {
				border: none;
				background: transparent;
				color: #ffd0d0;
				cursor: pointer;
			}

			.section-title {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin: 6px 0;
			}

			.phase {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
			}
			.phase .pill {
				padding: 6px 10px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #121820;
				color: var(--muted);
				font-size: 12px;
			}
			.phase .pill.active {
				background: linear-gradient(180deg, #172330, #0f1a24);
				color: #eaf6ff;
				border-color: #2d3b4b;
				font-weight: bold;
			}

			/* Two fixed columns; each column manages its own vertical flow */
			.players {
				display: grid;
				gap: 12px;
				align-items: start; /* no stretching */
				grid-template-columns: 1fr; /* 1 col on small screens */
			}
			@media (min-width: 700px) {
				.players {
					grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
				}
			}
			.player-col {
				display: grid; /* simple vertical stack */
				gap: 12px; /* space between unit cards in the same column */
				align-content: start;
				min-width: 0;
			}
			.card-title {
				display: flex;
				gap: 8px;
				align-items: center;
				justify-content: space-between;
			}
			.faction-row {
				display: flex;
				align-items: center;
				gap: 10px;
				margin: 6px 0 12px 0;
			}
			.faction-row button:disabled {
				opacity: 0.35;
				cursor: not-allowed;
			}
			.faction-row img {
				max-height: 150px;
				width: auto;
				border-radius: 8px;
				border: 1px solid var(--border);
				background: #0f141a;
			}
			.counter {
				display: inline-flex;
				gap: 6px;
				align-items: center;
			}
			.counter input {
				width: 70px;
				text-align: center;
			}
			.counter button {
				width: 34px;
			}

			.footer {
				margin-top: 16px;
				color: var(--muted);
				font-size: 12px;
				text-align: center;
			}

			.log {
				max-height: 220px;
				overflow: auto;
				border: 1px dashed var(--border);
				padding: 8px;
				border-radius: 8px;
				background: #0e1419;
			}
			.log .item {
				font-size: 12px;
				color: #c8d6e5;
				padding: 4px 0;
				border-bottom: 1px dashed #213042;
			}
			.log .item:last-child {
				border-bottom: none;
			}

			.tag {
				font-size: 11px;
				border: 1px solid var(--border);
				padding: 2px 6px;
				border-radius: 999px;
				color: #cfd8e3;
			}
			.muted {
				color: var(--muted);
			}
			.divider {
				height: 1px;
				background: var(--border);
				margin: 8px 0;
			}

			.hidden {
				display: none !important;
			}

			/* Modal */
			.modal-backdrop {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.6);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 1000;
			}
			.modal-backdrop.active {
				display: flex;
			}
			.modal-dialog {
				width: 50vw; /* ~50% of page width */
				max-width: 900px;
				min-width: 320px;
				max-height: 85vh;
				overflow: auto;
				border-radius: 12px;
				background: linear-gradient(180deg, var(--panel), var(--panel-2));
				border: 1px solid var(--border);
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
			}
			.modal-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 10px 12px;
				border-bottom: 1px solid var(--border);
			}
			.modal-body {
				padding: 12px;
			}
			.modal-footer {
				display: flex;
				align-items: center;
				justify-content: flex-end;
				padding: 10px 12px;
				border-top: 1px solid var(--border);
				gap: 8px;
			}
			.modal-footer .hint {
				margin-right: auto;
				font-size: 12px;
				color: var(--muted);
			}
			.modal-close {
				background: transparent;
				border: none;
				color: var(--muted);
				font-size: 20px;
				cursor: pointer;
			}
			/* Command modal */
			.command-modal {
				align-items: flex-start;
				padding: 18px;
			}
			.command-modal .modal-dialog {
				width: 480px;
				max-width: min(520px, 96vw);
			}
			.command-modal .modal-body {
				display: grid;
				gap: 10px;
			}
			.command-list {
				display: grid;
				gap: 8px;
			}
			.command-option {
				text-align: left;
				border: 1px solid var(--border);
				background: #0f141a;
				border-radius: 10px;
				padding: 10px;
				cursor: pointer;
				color: var(--text);
				transition: border-color 0.15s, background 0.15s;
			}
			.command-option:hover {
				border-color: #3a495b;
				background: #121a23;
			}
			.command-option.active {
				border-color: #2d94c7;
				box-shadow: 0 0 0 1px rgba(98, 211, 255, 0.15);
				background: linear-gradient(180deg, #0f1d27, #0b1218);
			}
			.btn-x {
				background: transparent;
				color: var(--danger);
				border: 1px solid var(--border);
				width: 28px;
				height: 28px;
				padding: 0;
				border-radius: 6px;
				font-size: 16px;
				line-height: 1;
				cursor: pointer;
			}
			.btn-x:hover {
				background: #2c0e0e;
				border-color: #623434;
				color: #ffd0d0;
			}
			.dice-anim {
				display: flex;
				gap: 10px; /* give bigger dice some breathing room */
				flex-wrap: wrap;
				align-items: center;
				justify-content: center;
			}
			.die {
				/* default sizing (overridden inline via --die-size when rolling many dice) */
				width: var(--die-size, 32px);
				height: var(--die-size, 32px);
				border-radius: 8px; /* keep the same rounded proportion */
				border: 1px solid var(--border);
				background: #0f141a;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 700;
				font-size: calc(var(--die-size, 32px) * 0.6); /* scale text with size */
			}
			.die.spin {
				animation: dice-spin 300ms linear infinite;
			}
			@keyframes dice-spin {
				0% {
					transform: rotate(0);
				}
				50% {
					transform: rotate(10deg);
				}
				100% {
					transform: rotate(0);
				}
			}
			.more-badge {
				font-size: 11px;
				color: var(--muted);
				border: 1px dashed var(--border);
				border-radius: 999px;
				padding: 2px 6px;
			}
			.dice-success-badge {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 6px;
				margin-left: 8px;
				padding: 4px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #131a23;
				font-weight: 700;
				color: #e6ebf2;
			}

			/* --- Saving Roll checker (S vs T) --- */
			.saving-checker {
				margin-top: 14px;
				padding-top: 10px;
				border-top: 1px solid var(--border);
				font-size: 14px;
			}
			.saving-checker .saving-inputs {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				margin: 8px 0;
			}
			.saving-checker label {
				display: flex;
				flex-direction: column;
				font-size: 13px;
				color: var(--muted);
				flex: 1;
				min-width: 120px;
			}
			.saving-checker input[type="number"] {
				margin-top: 4px;
				padding: 6px 8px;
				border-radius: 6px;
				border: 1px solid var(--border);
				background: #0e1419;
				color: var(--text);
				font-size: 14px;
				font-family: inherit;
			}
			.saving-result {
				font-weight: 700;
				font-size: 16px;
				color: var(--accent);
			}
			.saving-rule {
				font-size: 12px;
				color: var(--muted);
				margin-top: 4px;
			}
			.saving-table {
				margin-top: 8px;
				border: 1px solid var(--border);
				border-radius: 8px;
				overflow: hidden;
				font-size: 11px;
				display: none;
			}
			.saving-table.visible {
				display: block;
			}
			.saving-table-toggle {
				margin-top: 8px;
			}
			#woundTableToggle {
				border: 1px solid var(--border);
				background: #0e1419;
				color: var(--text);
				padding: 6px 10px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 13px;
			}
			#woundTableToggle:hover {
				background: #121820;
				border-color: #2d3b4b;
			}
			.saving-table .row {
				display: grid;
				grid-template-columns: repeat(11, minmax(22px, 1fr));
				border-bottom: 1px solid var(--border);
			}
			.saving-table .row:last-child {
				border-bottom: none;
			}
			.saving-table .cell {
				padding: 4px;
				text-align: center;
			}
			.saving-table .head {
				background: #121820;
				font-weight: 700;
			}
			.saving-table .muted {
				color: var(--muted);
			}
			/* Missions */
			.mission-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
				gap: 10px;
			}
			.mission-card {
				border: 1px solid var(--border);
				border-radius: 10px;
				background: #121820;
				padding: 10px;
				cursor: pointer;
			}
			.mission-card:hover {
				border-color: #2d3b4b;
				background: #101720;
			}
			.mission-card.selected {
				outline: 2px solid var(--accent);
			}
			.mission-meta {
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				margin-top: 6px;
			}
			.mission-meta .chip {
				font-size: 11px;
				border: 1px solid var(--border);
				border-radius: 999px;
				padding: 2px 6px;
				color: var(--muted);
				background: #0f141a;
			}
			.dice-highlight {
				background: #9cff9c !important;
				border-color: #28a428 !important;
				color: #000;
				font-weight: 600;
			}
			.dice-summary {
				margin-top: 6px;
				font-size: 14px;
				opacity: 0.9;
			}
			#floatingDiceBtn {
				position: fixed;
				right: 20px;
				top: 50%;
				transform: translateY(-50%);

				width: 52px;
				height: 52px;

				border-radius: 50%;
				border: none;

				background: #1e1f22;
				color: white;
				font-size: 26px;
				cursor: pointer;

				display: flex;
				align-items: center;
				justify-content: center;

				box-shadow: 0 4px 14px rgba(0, 0, 0, 0.35);
				opacity: 0.85;
				z-index: 999999; /* Always on top */

				transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
			}

			#floatingDiceBtn:hover {
				opacity: 1;
				transform: translateY(-50%) scale(1.08);
				box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
			}
			/* --- IMPERIAL TERMINAL THEME --- */
			.imperial-terminal .modal-dialog {
				background: #0a0d0f;
				border: 2px solid #3b3f46;
				box-shadow: 0 0 25px rgba(0, 255, 100, 0.15),
					inset 0 0 40px rgba(0, 255, 150, 0.05);
				font-family: "Share Tech Mono", monospace;
				position: relative;
				overflow: hidden;
			}

			/* CRT scanlines */
			.imperial-terminal .modal-dialog::before {
				content: "";
				pointer-events: none;
				position: absolute;
				inset: 0;
				background: repeating-linear-gradient(
					to bottom,
					rgba(0, 0, 0, 0),
					rgba(0, 0, 0, 0) 2px,
					rgba(0, 255, 120, 0.03) 3px
				);
				mix-blend-mode: overlay;
			}

			/* Terminal header */
			.imperial-terminal .modal-header {
				background: #101417;
				border-bottom: 1px solid #293036;
				color: #8fffb4;
				text-transform: uppercase;
				letter-spacing: 2px;
			}

			/* Terminal body */
			.imperial-terminal .modal-body {
				background: #0a0d0f;
				color: #8fffb4;
				padding: 15px;
				font-size: 14px;
			}

			/* Text ‚Äúscreen‚Äù window */
			.imperial-terminal #aiConversation {
				background: #000;
				border: 1px solid #233026;
				padding: 10px;
				height: 280px;
				overflow-y: auto;
				color: #8fffb4;
				box-shadow: inset 0 0 20px rgba(0, 255, 150, 0.15);
			}

			.imperial-terminal #aiConversation .user {
				color: #d1ffea;
			}
			.imperial-terminal #aiConversation .assistant {
				color: #8fffb4;
			}

			/* Input row */
			.imperial-terminal #aiInput {
				background: #000;
				border: 1px solid #2e3c30;
				color: #8fffb4;
				padding: 8px;
				font-family: inherit;
				width: 100%;
			}

			/* Voice/Send Buttons */
			.imperial-terminal button {
				background: #111;
				color: #8fffb4;
				border: 1px solid #2d3c33;
			}
			.imperial-terminal button:hover {
				background: #14221c;
				border-color: #47fba5;
			}

			/* Blinking cogitator cursor */
			@keyframes cogCursor {
				0% {
					opacity: 1;
				}
				50% {
					opacity: 0.1;
				}
				100% {
					opacity: 1;
				}
			}

			.imperial-terminal #aiInput::placeholder {
				color: #1c3a2b;
			}

			.imperial-terminal .cursor {
				animation: cogCursor 0.7s steps(1) infinite;
				color: #8fffb4;
			}
			/* ============================================================
   IMPERIAL TERMINAL (Servo-Skull Cogitator UI)
   ============================================================ */

			#aiModal {
				backdrop-filter: blur(3px);
				position: fixed !important;
				inset: 0 !important;
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 10000 !important;
			}
			#aiModal.active {
				display: flex !important;
			}

			/* Terminal Frame */
			.ai-terminal {
				background: #0b0d0c;
				border: 3px solid #3a3a3a;
				border-radius: 8px;
				padding: 18px;
				box-shadow: 0 0 60px rgba(0, 255, 70, 0.08),
					inset 0 0 40px rgba(0, 255, 50, 0.07);
				position: relative;
				overflow: hidden;
			}

			/* Radar grid background */
			.ai-terminal::before {
				content: "";
				position: absolute;
				inset: 0;
				background: linear-gradient(rgba(0, 255, 50, 0.06) 1px, transparent 1px),
					linear-gradient(90deg, rgba(0, 255, 50, 0.06) 1px, transparent 1px);
				background-size: 28px 28px;
				pointer-events: none;
			}

			/* CRT scanlines */
			.ai-terminal::after {
				content: "";
				position: absolute;
				inset: 0;
				background: repeating-linear-gradient(
					to bottom,
					rgba(0, 0, 0, 0) 0,
					rgba(0, 0, 0, 0) 2px,
					rgba(0, 255, 80, 0.05) 3px
				);
				pointer-events: none;
				animation: crtFlicker 3s infinite ease-in-out;
			}

			@keyframes crtFlicker {
				0%,
				100% {
					opacity: 0.7;
				}
				50% {
					opacity: 0.9;
				}
			}

			/* Terminal text */
			#aiMessages .item {
				font-family: "Courier New", monospace;
				color: #24ff6f;
				font-size: 14px;
				padding: 4px 0;
				text-shadow: 0 0 4px rgba(36, 255, 111, 0.6),
					0 0 10px rgba(36, 255, 111, 0.3);
			}

			/* User text slightly different green */
			#aiMessages .user {
				color: #82ffb2;
			}

			/* AI text stronger green */
			#aiMessages .ai {
				color: #24ff6f;
			}

			/* Status line */
			#aiStatus {
				font-family: "Courier New", monospace;
				color: #1cff4b;
				text-shadow: 0 0 6px rgba(0, 255, 80, 0.8);
			}

			/* Imperial header bar */
			.ai-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				border-bottom: 2px solid #24ff6f;
				padding-bottom: 8px;
				margin-bottom: 12px;
			}

			/* Cog Mechanicus icon */
			.ai-header .skull {
				width: 36px;
				height: 36px;
				filter: drop-shadow(0 0 6px rgba(0, 255, 80, 0.6));
			}

			/* Close button imperial style */
			#aiClose {
				font-family: "Courier New", monospace;
				border: 1px solid #24ff6f;
				background: rgba(0, 255, 50, 0.07);
				color: #24ff6f;
				padding: 4px 10px;
				border-radius: 4px;
				cursor: pointer;
				text-shadow: 0 0 6px rgba(0, 255, 80, 0.8);
			}

			#aiClose:hover {
				background: rgba(0, 255, 50, 0.15);
			}

			/* Talk button styled as red Mechanicus Rune button */
			#aiTalkButton {
				border: 2px solid #b30000;
				background: #4a0000;
				color: #ff5c5c;
				font-family: "Courier New", monospace;
				box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.6),
					0 0 10px rgba(255, 0, 0, 0.4);
			}

			/* Listening mode = glowing */
			#aiTalkButton.primary {
				background: #159933;
				border-color: #00ff5e;
				color: black;
				text-shadow: none;
				box-shadow: inset 0 0 18px rgba(0, 255, 80, 0.8),
					0 0 14px rgba(0, 255, 50, 0.7);
			}

			/* Dot indicator */
			#aiTalkDot {
				width: 12px;
				height: 12px;
				border-radius: 50%;
			}

			/* Scroll container */
			#aiMessages {
				max-height: 55vh;
				overflow-y: auto;
				padding-right: 6px;
			}

			/* Force AI lines to break like terminal output instead of a single long row */
			#aiMessages .item.ai {
				white-space: pre-wrap;
				line-height: 1.35;
				font-family: "VT323", monospace;
				font-size: 15px;
			}

			/* Scrollbar neon green */
			#aiMessages::-webkit-scrollbar {
				width: 6px;
			}
			#aiMessages::-webkit-scrollbar-thumb {
				background: #23ff5a;
				box-shadow: 0 0 6px rgba(36, 255, 111, 0.7);
			}
			/* ============================================================
   IMPERIAL TERMINAL ‚Äì HOLO-BINARIC RAIN
   ============================================================ */
			#aiModal.imperial-terminal {
				overflow: hidden;
			}

			/* Background binary rain canvas */
			#binaryRain {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				z-index: -1;
				opacity: 0.08; /* subtle */
				pointer-events: none;
			}

			/* ============================================================
   AI TYPING ANIMATION
   ============================================================ */
			.ai-typing {
				width: fit-content;
				overflow: hidden;
				border-right: 2px solid rgba(0, 255, 255, 0.5);
				white-space: nowrap;
				animation: aiTyping 3.2s steps(40, end), aiCaret 0.75s step-end infinite;
			}

			@keyframes aiTyping {
				from {
					width: 0;
				}
				to {
					width: 100%;
				}
			}

			@keyframes aiCaret {
				from,
				to {
					border-color: transparent;
				}
				50% {
					border-color: rgba(0, 255, 255, 0.7);
				}
			}

			/* ============================================================
   CRT STATIC FLICKER & INTERFERENCE
   ============================================================ */

			/* Transparent noise overlay */
			.ai-static {
				position: absolute;
				inset: 0;
				pointer-events: none;
				background-image: url("static-noise.gif");
				opacity: 0.15;
				mix-blend-mode: screen;
				z-index: 999;
			}

			/* Subtle flicker */
			@keyframes crtFlicker {
				0% {
					opacity: 0.7;
				}
				50% {
					opacity: 0.85;
				}
				100% {
					opacity: 0.7;
				}
			}

			.ai-terminal {
				animation: crtFlicker 4s infinite ease-in-out;
			}
			/* Prevent AI typing wrapper from being treated like wounds bars, roll bars, etc */
			#aiMessages .item .ai-typing {
				background: none !important;
				padding: 0 !important;
				height: auto !important;
				min-height: 0 !important;
				border-radius: 0 !important;
				box-shadow: none !important;
				display: inline-block !important;
				color: #00ff99 !important; /* or whatever green you prefer */
				font-family: "VT323", monospace !important;
				font-size: 15px !important;
				white-space: pre-wrap !important;
			}
			#aiMessages .item {
				background: none !important;
			}
		</style>
		<!-- Prevent local favicon warning -->
		<link rel="icon" href="data:," />

		<!-- PDF.js for client-side PDF text extraction (no SRI to avoid hash mismatch across CDNs) -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
		<script>
			(function () {
				const lib = window.pdfjsLib || window["pdfjs-dist/build/pdf"];
				if (lib && lib.GlobalWorkerOptions) {
					lib.GlobalWorkerOptions.workerSrc =
						"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
					window.__pdfjs = lib;
				}
			})();
		</script>
	</head>
	<body>
		<div class="container">
			<header>
				<div style="display: flex; align-items: center; gap: 10px">
					<div
						id="appTitle"
						class="app-title pirata-one-regular"
						title="About Astronomican"
					>
						‚öôÔ∏è Astronomican <br /><span class="badge">10th Edition</span>
					</div>
					<span class="badge" id="roundBadge">Round 1</span>
					<span class="badge" id="turnBadge"
						>Turn: <strong id="turnPlayerBadge">Player 1</strong></span
					>
				</div>
				<div class="controls">
					<div class="group">
						<div class="phase" id="phasePills"></div>
					</div>
					<div class="group">
						<button class="primary" id="btnNextPhase" style="margin-left: 10px">
							Next Phase ‚ûú
						</button>
					</div>
				</div>
				<div class="group">
					<button id="btnHelp" class="ghost" title="Open help">Help</button>
					<button id="btnAI" class="icon-button">Servo Skull</button>
					<button id="btnSetup" class="primary" title="Open setup & tools">
						Setup
					</button>
					<button id="btnNewGame" class="danger" title="Start a new battle">
						New Game
					</button>
				</div>
			</header>

			<!-- Start Game Modal -->
			<div id="startModal" class="modal-backdrop">
				<div class="modal-dialog">
					<div class="modal-header">
						<strong class="faction-name">Start Game</strong>
						<button
							id="startClose"
							class="modal-close"
							aria-label="Close"
							style="display: none"
						>
							‚úï
						</button>
					</div>
					<div class="modal-body">
						<section class="panel" id="startPanel">
							<div class="grid-2">
								<!-- Player Names -->
								<div>
									<div class="card-title"><strong>Players</strong></div>
									<div class="player-import">
										<!-- Row: Player 1 -->
										<div class="player-import-row" style="margin-top: 6px">
											<input id="p1Name" type="text" value="Player 1" />
											<button
												id="btnImportP1"
												type="button"
												class="primary btn-choose"
											>
												Import army
											</button>
											<span id="armyFileNameP1" class="filename-pill sub"
												>Upload a Battleforge (40k App) PDF army list</span
											>
											<input
												type="file"
												id="armyFileP1"
												accept=".pdf,application/pdf"
												class="visually-hidden"
												aria-hidden="true"
											/>
										</div>

										<!-- Row: Player 2 -->
										<div class="player-import-row" style="margin-top: 6px">
											<input id="p2Name" type="text" value="Player 2" />
											<button
												id="btnImportP2"
												type="button"
												class="primary btn-choose"
											>
												Import army
											</button>
											<span id="armyFileNameP2" class="filename-pill sub"
												>Upload a Battleforge (40k App) PDF army list</span
											>
											<input
												type="file"
												id="armyFileP2"
												accept=".pdf,application/pdf"
												class="visually-hidden"
												aria-hidden="true"
											/>
										</div>
									</div>
								</div>
							</div>

							<div class="divider"></div>

							<!-- Mission Setup -->
							<div class="card-title"><strong>Mission Setup</strong></div>
							<div class="sub" style="margin-top: 6px">
								Choose a mission pack at random or pick one.
							</div>

							<div class="grid-2" style="margin-top: 8px">
								<div>
									<div
										style="
											margin-top: 8px;
											display: flex;
											gap: 8px;
											flex-wrap: wrap;
										"
									>
										<button id="btnMissionRandom">üé¥ Draw Random</button>
										<button id="btnMissionChoose">üìú Choose Mission</button>
									</div>
								</div>
								<div>
									<div class="sub"><strong>Selected Mission</strong></div>
									<div id="missionSelected" class="sub" style="margin-top: 6px">
										None selected.
									</div>
								</div>
							</div>

							<div id="missionChooser" class="hidden" style="margin-top: 10px">
								<div class="card-title">
									<strong>Choose a Mission</strong>
									<button id="btnMissionChooserClose" class="ghost">
										Close
									</button>
								</div>
								<div id="missionGrid" class="mission-grid"></div>
							</div>

							<div class="divider"></div>

							<!-- Saved states (Load ONLY) -->
							<div class="card-title"><strong>Saved states</strong></div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 12px;
									flex-wrap: wrap;
								"
							>
								<button id="btnLoad">üìÇ Load</button>
								<input
									id="loadState"
									type="file"
									accept="application/json"
									style="display: none"
								/>
							</div>
						</section>
					</div>
					<!-- closes .modal-body -->
					<div class="modal-footer">
						<span class="hint"
							>Upload both army lists and select a mission to begin.</span
						>
						<button id="btnStartBattle" class="btn btn-primary">
							Start battle!
						</button>
					</div>
				</div>
			</div>

			<!-- Setup & Tools Modal -->
			<div id="setupModal" class="modal-backdrop">
				<div class="modal-dialog">
					<div class="modal-header">
						<strong class="faction-name">Setup & Tools</strong>
						<button id="setupClose" class="modal-close" aria-label="Close">
							‚úï
						</button>
					</div>
					<div class="modal-body">
						<section class="panel" id="importPanel">
							<div class="grid-2">
								<div>
									<div class="card-title"><strong>CP / VP</strong></div>
									<div class="grid-2" style="margin-top: 6px">
										<div class="counter">
											<span class="tag">P1 CP</span
											><button data-cp="p1" data-delta="-1">‚àí</button
											><input id="p1CP" type="number" value="0" /><button
												data-cp="p1"
												data-delta="1"
											>
												Ôºã
											</button>
										</div>
										<div class="counter">
											<span class="tag">P1 VP</span
											><button data-vp="p1" data-delta="-1">‚àí</button
											><input id="p1VP" type="number" value="0" /><button
												data-vp="p1"
												data-delta="1"
											>
												Ôºã
											</button>
										</div>
										<div class="counter">
											<span class="tag">P2 CP</span
											><button data-cp="p2" data-delta="-1">‚àí</button
											><input id="p2CP" type="number" value="0" /><button
												data-cp="p2"
												data-delta="1"
											>
												Ôºã
											</button>
										</div>
										<div class="counter">
											<span class="tag">P2 VP</span
											><button data-vp="p2" data-delta="-1">‚àí</button
											><input id="p2VP" type="number" value="0" /><button
												data-vp="p2"
												data-delta="1"
											>
												Ôºã
											</button>
										</div>
									</div>
								</div>
							</div>

							<div class="divider"></div>
							<div class="card-title">
								<strong>Game Settings</strong>
							</div>
							<div class="sub" style="margin-top: 6px">
								<label
									><input type="checkbox" id="autoCP" checked /> Auto +1 CP at
									Command phase</label
								>
							</div>

							<!-- Tools section -->
							<div class="divider"></div>
							<div class="card-title"><strong>Tools</strong></div>
							<div class="sub" style="margin-top: 6px">
								If phase moved forward by mistake
							</div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 8px;
									flex-wrap: wrap;
								"
							>
								<button class="ghost" id="btnPrevPhase">‚óÄÔ∏é Prev Phase</button>
							</div>

							<div class="divider"></div>
							<div class="card-title"><strong>Saved states</strong></div>
							<div
								style="
									margin-top: 8px;
									display: flex;
									gap: 12px;
									flex-wrap: wrap;
								"
							>
								<button id="btnSave">üíæ Save</button>
							</div>
						</section>
					</div>
				</div>
			</div>

			<div class="row">
				<!-- Players only: two columns -->
				<section class="panel">
					<div class="card-title">
						<h3 id="p1Header">Player 1 Army</h3>
					</div>
					<div class="faction-row">
						<div id="p1Faction" class="faction-name"></div>
						<button id="p1Commands" class="ghost" disabled>Commands</button>
						<button id="p1Strats">Stratagems</button>
						<button id="p1Mission">Mission</button>
						<img id="p1FactionImg" alt="Faction" class="hidden" />
					</div>
					<div id="p1Units" class="players">
						<div class="player-col" id="p1UnitsCol1"></div>
						<div class="player-col" id="p1UnitsCol2"></div>
					</div>
				</section>
				<section class="panel">
					<div class="card-title">
						<h3 id="p2Header">Player 2 Army</h3>
					</div>
					<div class="faction-row">
						<div id="p2Faction" class="faction-name"></div>
						<button id="p2Commands" class="ghost" disabled>Commands</button>
						<button id="p2Strats">Stratagems</button>
						<button id="p2Mission">Mission</button>
						<img id="p2FactionImg" alt="Faction" class="hidden" />
					</div>
					<div id="p2Units" class="players">
						<div class="player-col" id="p2UnitsCol1"></div>
						<div class="player-col" id="p2UnitsCol2"></div>
					</div>
				</section>
			</div>

			<div class="footer">
				State is auto-saved locally. You can export/import to continue later.
			</div>
		</div>

		<template id="unitTemplate">
			<div class="unit-card" data-unit-id>
				<div class="unit-meta">
					<div class="unit-name"></div>
					<div class="sub keywords"></div>
					<div class="wounds">
						<div class="bar"><span></span></div>
						<div class="cnt" data-wounds></div>
						<button data-dmg="1">‚àí</button>
						<button data-dmg="-1">Ôºã</button>
					</div>
					<div class="sub" data-models></div>
					<div class="section-title">
						<strong>Effects</strong> <button data-add-effect>Ôºã Add</button>
					</div>
					<div class="effects" data-effects></div>
					<div class="unit-details" data-details>
						<div class="unit-details-inner">
							<div class="section-title"><strong>Unit Details</strong></div>
							<div class="statline" data-statline></div>
							<div class="composition" data-composition></div>
							<div class="section-title" style="margin-top: 8px">
								<strong>Weapons</strong>
							</div>
							<div class="weapon-grid" data-weapons></div>
							<div class="weapon-panel hidden" data-weapon-panel></div>
						</div>
					</div>
				</div>
				<div>
					<button class="btn-x" data-remove aria-label="Remove">‚úï</button>
				</div>
			</div>
		</template>

		<!-- PoolHouseAI 40K Assistant Modal -->
		<div id="aiModal" class="modal-backdrop imperial-terminal">
			<!-- HOLO-BINARY RAIN -->
			<canvas id="binaryRain"></canvas>
			<div class="modal-dialog ai-terminal">
				<div class="ai-static"></div>
				<!-- IMPERIAL HEADER BAR -->
				<div class="ai-header">
					<img class="skull" src="servo-skull.jpg" alt="Servo Skull" />

					<div id="aiStatus" class="sub">Idle</div>

					<button id="aiClose" class="modal-close" aria-label="Close">
						CLOSE
					</button>
				</div>

				<!-- TERMINAL MESSAGE LOG -->
				<div id="aiMessages" class="terminal-log"></div>

				<!-- TALK BUTTON -->
				<button id="aiTalkButton" type="button" class="terminal-talk-btn">
					<span id="aiTalkDot" class="talk-dot"></span>
					<span id="aiTalkLabel">Start Listening</span>
				</button>
			</div>
		</div>
		<!-- Phase Help Modal -->
		<div id="phaseModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="phaseHelpTitle">Phase Help</strong>
					<button id="phaseHelpClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div id="phaseHelpBody" class="modal-body"></div>
			</div>
		</div>
		<!-- Command Phase Modal -->
		<div id="commandModal" class="modal-backdrop command-modal">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="commandTitle" class="faction-name">Command Phase</strong>
					<button id="commandClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div class="modal-body">
					<div id="commandContext" class="sub"></div>
					<div id="commandList" class="command-list"></div>
					<label class="sub" for="commandUnitSelect"
						>Apply to unit
						<select id="commandUnitSelect"></select>
					</label>
				</div>
				<div class="modal-footer">
					<span class="hint">Orders expire at end of turn by default.</span>
					<button id="commandSkip" class="ghost">Skip</button>
					<button id="commandApply" class="primary">Apply</button>
				</div>
			</div>
		</div>

		<!-- Dice Roller Modal -->
		<div id="diceModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Dice Roller</strong>
					<button id="diceClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div class="modal-body">
					<div
						style="
							display: flex;
							gap: 8px;
							align-items: center;
							flex-wrap: wrap;
						"
					>
						<input id="diceExpr" type="text" placeholder="e.g. 6d6+2" />
						<button id="btnRoll">Roll</button>

						<input
							type="number"
							id="diceHighlight"
							min="1"
							max="20"
							placeholder="Highlight rolls ‚â•"
							style="flex: 1"
						/>
					</div>

					<div class="sub" id="diceHelp" style="margin-top: 6px">
						Examples: <br /><code>d6</code> (roll one D6),
						<code>6d6+2</code> (roll six D6 and add 2), <code>3d10-1</code>, or
						just <code>20</code> (roll twenty D6).
					</div>

					<div id="diceAnim" class="dice-anim" style="margin-top: 10px"></div>
					<div id="diceOut" class="sub" style="margin-top: 10px"></div>

					<div class="saving-checker">
						<div class="card-title">
							<strong class="faction-name">Saving Roll checker</strong>
						</div>
						<div class="sub">
							Quick S vs T helper for wound rolls. Enter attacker Strength (S)
							and target Toughness (T).
						</div>
						<div class="saving-inputs">
							<label for="woundStr">
								Strength (S)
								<input
									type="number"
									id="woundStr"
									min="1"
									max="30"
									inputmode="numeric"
									value="4"
								/>
							</label>
							<label for="woundTough">
								Toughness (T)
								<input
									type="number"
									id="woundTough"
									min="1"
									max="30"
									inputmode="numeric"
									value="4"
								/>
							</label>
						</div>
						<div id="woundResult" class="saving-result">Wounds on 4+</div>
						<div id="woundRule" class="saving-rule">S = T ‚Üí 4+</div>
						<div class="saving-table-toggle">
							<button id="woundTableToggle" type="button">
								Show S/T table
							</button>
						</div>
						<div
							class="saving-table"
							id="woundTable"
							aria-label="S vs T table"
							hidden
						></div>
					</div>
				</div>
			</div>
		</div>

		<!-- Help Modal -->
		<div id="helpModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Help</strong>
					<button id="helpClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div class="modal-body">
					<section class="panel">
						<div class="card-title"><strong>Getting Started</strong></div>
						<div class="sub">
							<p>
								Import your army list as a PDF, then click unit names to expand
								details. Use the phase pills at the top to step through your
								turn.
							</p>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title"><strong>Common Actions</strong></div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li>
									Click a unit name to view its M/T/Sv/W/Ld/OC and composition.
								</li>
								<ul>
									<li>
										Click a weapon name to view its profile, abilities, and
										rolls.
									</li>
								</ul>
								<li>
									Use the ‚àí / Ôºã buttons on a unit to apply damage or healing.
								</li>
								<li>
									Use the ‚úï button to remove a unit (or confirm when it reaches
									0W).
								</li>
								<li>
									Open <em>Setup</em> to rename players, import armies, and
									manage saves.
								</li>
							</ul>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title"><strong>Dice Notation</strong></div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li><code>8</code> ‚Äì roll eight six-sided die.</li>
								<li><code>d6</code> ‚Äì roll one six-sided die.</li>
								<li><code>6d6+2</code> ‚Äì roll six D6 and add 2.</li>
								<li><code>3d10-1</code> ‚Äì roll three D10 and subtract 1.</li>
							</ul>
						</div>
					</section>
					<section class="panel" style="margin-top: 10px">
						<div class="card-title">
							<strong>Terrain (10th Edition)</strong>
						</div>
						<div class="sub">
							<ul style="margin: 6px 0 0 18px">
								<li>
									<strong>Light Cover</strong> ‚Äì models wholly on/within gain
									the <em>Benefit of Cover</em> against ranged attacks.
								</li>
								<li>
									<strong>Heavy Cover</strong> ‚Äì as Light Cover; in addition, if
									Charged through Heavy Cover, charging units do not receive the
									charge bonus to melee Attacks (where applicable).
								</li>
								<li>
									<strong>Difficult Ground</strong> ‚Äì subtract 2" from Move,
									Advance and Charge moves made through it.
								</li>
								<li>
									<strong>Obscuring</strong> ‚Äì blocks line of sight through it
									for non-AIRCRAFT outside and targets behind (with usual
									exceptions like models on/within or towering).
								</li>
								<li>
									<strong>Benefit of Cover</strong> ‚Äì add 1 to Saving Throws
									(not Invulnerable saves) against ranged attacks; does not
									apply while the target is within Engagement Range of any enemy
									models.
								</li>
							</ul>
						</div>
					</section>
				</div>
			</div>
		</div>

		<!-- Stratagems Modal -->
		<div id="stratModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="stratTitle" class="faction-name">Stratagems</strong>
					<button id="stratClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div id="stratBody" class="modal-body">
					<div class="sub" id="stratContext"></div>
					<div id="stratList"></div>
					<div class="strat-footer">
						<button id="stratApply" class="primary" disabled>
							Apply Stratagem
						</button>
						<span id="stratApplyHint" class="sub"></span>
					</div>
				</div>
			</div>
		</div>

		<!-- About / Astronomican Modal -->
		<div id="aboutModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong class="faction-name">Astronomican</strong>
					<button id="aboutClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div class="modal-body" style="text-align: center">
					<img
						src="god-emperor-chris.jpeg"
						alt="God-Emperor Chris"
						style="
							max-width: 100%;
							height: auto;
							border-radius: 8px;
							border: 1px solid var(--border);
							background: #0f141a;
						"
					/>
					<div class="sub" style="margin-top: 10px">
						Helping dyslexics play 40k since 2025
					</div>
				</div>
			</div>
		</div>

		<!-- Mission Modal -->
		<div id="missionModal" class="modal-backdrop">
			<div class="modal-dialog">
				<div class="modal-header">
					<strong id="missionTitle" class="faction-name">Mission</strong>
					<button id="missionClose" class="modal-close" aria-label="Close">
						‚úï
					</button>
				</div>
				<div id="missionBody" class="modal-body"></div>
			</div>
		</div>
		<!-- Audio element for PoolHouseAI TTS -->
		<audio id="aiTtsAudio"></audio>
		<button id="floatingDiceBtn" class="floating-dice-btn">üé≤</button>
		<audio id="diceSound" src="sounds/dice-roll.mp3" preload="auto"></audio>
		<script>
			// --- Normalise common faction identifiers so UI lookups are resilient ---
			const FACTION_ALIASES = {
				"adepta-sororitas": "sisters",
				"astra-militarum": "imperial-guard",
				"imperial guard": "imperial-guard",
				"chaos space marines": "chaos-marines",
				"chaos-space-marines": "chaos-marines",
				"chaos marines": "chaos-marines",
				"chaos marine": "chaos-marines",
				chaos: "chaos-marines",
				csm: "chaos-marines",
				aeldari: "eldar",
				asuryani: "eldar",
				"druk-hari": "drukhari",
				"genestealer-cults": "genestealer",
				"genestealer cults": "genestealer",
				"t'au": "tau",
				"tau empire": "tau",
				// Added alias keys:
				"adepta sororitas": "sisters",
				"astra militarum": "imperial-guard",
				"space marines": "space-marines",
				"adeptus astartes": "space-marines",
			};
			// Add once, near your other constants:
			const UNIT_NAME_ALIASES = {
				// Adepta Sororitas
				"Sisters of Battle Squad": "Battle Sisters Squad",
				"Battle Sisters": "Battle Sisters Squad",
				"Battle Sister Squad": "Battle Sisters Squad",
				"Battle Sister": "Battle Sisters Squad",
				// (add more harmless synonyms as you encounter them)
			};

			const _LOWER_UNIT_NAME_ALIASES = Object.fromEntries(
				Object.entries(UNIT_NAME_ALIASES).map(([k, v]) => [k.toLowerCase(), v])
			);

			// Use your existing FACTION_ALIASES but make lookup case-insensitive:
			function canonicalFactionKey(input) {
				const kRaw = String(input || "")
					.trim()
					.toLowerCase();
				// Normalise simple space vs hyphen differences for lookups like
				// "Astra Militarum" -> "astra-militarum"; "Space Marines" -> "space-marines"
				const kHyphen = kRaw.replace(/\s+/g, "-");

				// build a lower-cased lookup from FACTION_ALIASES
				const lowerAliases = Object.fromEntries(
					Object.entries(FACTION_ALIASES).map(([a, c]) => [a.toLowerCase(), c])
				);

				// Prefer explicit aliases; then try the hyphen form; finally fall back to the hyphen form
				// so canonical keys that already use hyphens still work.
				return lowerAliases[kRaw] || lowerAliases[kHyphen] || kHyphen;
			}

			function canonicalUnitName(name) {
				const raw = String(name || "").trim();
				const lower = raw.toLowerCase();
				return _LOWER_UNIT_NAME_ALIASES[lower] || raw;
			}

			// --- Data source: wh40k_10th.json (replaces legacy data.js) ---
			const DATA_URL = "data/wh40k_10th.json";
			const STRATS_URL = "data/strats.json";
			const weaponProfiles = {};
			const unitDatabase = {};
			const abilitiesDatabase = {};
			const factionCommands = {};
			const factionOrders = {};
			const coreStratagems = [];
			let dataReadyPromise = null;

			const slugify = (s) =>
				String(s || "")
					.toLowerCase()
					.replace(/[^a-z0-9]+/g, "-")
					.replace(/^-+|-+$/g, "");

			const parseNumber = (val) => {
				if (val == null) return null;
				if (typeof val === "number") return val;
				const m = String(val).match(/-?\d+/);
				return m ? Number(m[0]) : null;
			};

			const cleanRange = (r) => {
				if (!r) return r;
				const s = String(r).trim();
				if (/melee/i.test(s)) return "Melee";
				const m = s.match(/\d+/);
				return m ? Number(m[0]) : s;
			};

			const deriveRole = (keywords = []) => {
				const flat = keywords
					.flatMap((k) => (k.words ? k.words : k))
					.map((k) => String(k).toLowerCase());
				if (flat.includes("battleline")) return "Battleline";
				if (flat.includes("character")) return "Character";
				if (flat.includes("vehicle")) return "Vehicle";
				if (flat.includes("monster")) return "Monster";
				if (flat.includes("infantry")) return "Infantry";
				return "Unit";
			};

			const applyFactionAliases = () => {
				Object.entries(FACTION_ALIASES).forEach(([alias, canonical]) => {
					if (unitDatabase[canonical] && !unitDatabase[alias]) {
						unitDatabase[alias] = unitDatabase[canonical];
					}
					if (factionCommands[canonical] && !factionCommands[alias]) {
						factionCommands[alias] = factionCommands[canonical];
					}
					if (factionOrders[canonical] && !factionOrders[alias]) {
						factionOrders[alias] = factionOrders[canonical];
					}
				});
			};

			const normalizeStratTurn = (raw) => {
				const t = String(raw || "both").toLowerCase();
				if (t === "your" || t === "current") return "current";
				if (t === "opponent" || t === "their") return "opponent";
				if (t === "either" || t === "both") return "both";
				return "both";
			};
			const normalizeStratPhases = (raw) => {
				if (!raw) return ["any"];
				const toArr = (val) =>
					String(val || "")
						.replace(/\(.*?\)/g, "") // drop parenthetical notes for matching
						.split(/(?:,|\/|\bor\b)/i)
						.map((p) => p.trim().toLowerCase())
						.filter(Boolean);
				const base = Array.isArray(raw) ? raw.flatMap(toArr) : toArr(raw);
				const simplified = base.map((p) => {
					if (p.includes("command")) return "command";
					if (p.includes("movement")) return "movement";
					if (p.includes("shooting")) return "shooting";
					if (p.includes("charge")) return "charge";
					if (p.includes("fight")) return "fight";
					if (p.includes("battle")) return "battleshock";
					return p || "any";
				});
				const unique = Array.from(new Set(simplified)).filter(Boolean);
				return unique.length ? unique : ["any"];
			};
			const buildStratagemsFromJson = (rows) => {
				coreStratagems.length = 0; // reset any old (9th) data
				(rows || []).forEach((r) => {
					const phases = normalizeStratPhases(r.phase || r.phases || "any");
					const displayPhase =
						Array.isArray(r.phase) || Array.isArray(r.phases)
							? (r.phase || r.phases).join
								? (r.phase || r.phases).join(", ")
								: String(r.phase || r.phases || "")
							: r.phase || r.phases || phases.join(", ");
					coreStratagems.push({
						key: r.id || r.name || "stratagem",
						name: r.name || r.id || "Stratagem",
						cost: r.cp ?? r.cost ?? 1,
						phases,
						phase: displayPhase || phases.join(", "),
						turn: normalizeStratTurn(r.turn),
						timing: r.timing || "",
						description: r.description || r.text || "",
						target: r.target || "",
						type: r.type || "Core Stratagem",
						source: "core",
					});
				});
			};

			const buildDataFromJson = (rows) => {
				rows.forEach((row) => {
					// Orders payloads
					if (row.type === "orders" && Array.isArray(row.orders)) {
						const factionKey = canonicalFactionKey(row.factionname || "");
						factionOrders[factionKey] = row.orders.map((o) => ({
							key: o.key,
							name: o.name,
							effect: o.effect,
							expires: o.expires || "turn",
							rounds: o.rounds,
						}));
						return;
					}

					const factionKey = canonicalFactionKey(row.factionname || "");
					if (!unitDatabase[factionKey]) unitDatabase[factionKey] = [];

					const unitName = row.unitname || "Unit";
					const unitSlug = slugify(unitName);

					// Stats: take first stat block as baseline
					const stat =
						Array.isArray(row.stats) && row.stats.length ? row.stats[0] : {};
					const movement = parseNumber(stat.m);
					const toughness = parseNumber(stat.t);
					const save = parseNumber(stat.sv);
					const wounds = parseNumber(stat.w);
					const leadership = parseNumber(stat.ld);
					const oc = parseNumber(stat.oc);
					const invulnSave =
						Array.isArray(row.abilities?.invulnerablesave) &&
						row.abilities.invulnerablesave.length
							? parseNumber(row.abilities.invulnerablesave[0].save)
							: null;

					const unitWeapons = [];
					(row.weapons || []).forEach((w, idx) => {
						const name = w.name || `Weapon ${idx + 1}`;
						const key = `${unitSlug}-${slugify(name)}`;
						// Only set once; later duplicates are ignored
						if (!weaponProfiles[key]) {
							const range = cleanRange(w.range);
							const isMelee = String(range).toLowerCase() === "melee";
							const skill = parseNumber(w.skill);
							weaponProfiles[key] = {
								name,
								range,
								attacks: w.attacks ?? w.a ?? "-",
								bs: isMelee ? null : skill ?? "-",
								ws: isMelee ? skill ?? "-" : null,
								strength: parseNumber(w.strength),
								ap: parseNumber(w.ap),
								damage: w.damage ?? w.d ?? "-",
								abilities: Array.isArray(w.abilities) ? w.abilities : [],
							};
						}
						unitWeapons.push(key);
					});

					unitDatabase[factionKey].push({
						name: unitName,
						models: parseNumber(
							row.unitcompo?.units?.[0]?.models || row.unitcompo?.models || 1
						),
						wounds,
						save,
						leadership,
						oc,
						movement,
						toughness,
						role: deriveRole(row.keywords),
						weapons: unitWeapons,
						invulnSave,
					});
				});

				applyFactionAliases();
			};

			async function loadWh40kData() {
				try {
					const [dataRows, stratRows] = await Promise.all([
						fetch(DATA_URL).then((r) => r.json()),
						fetch(STRATS_URL)
							.then((r) => r.json())
							.catch(() => []),
					]);
					buildDataFromJson(dataRows || []);
					buildStratagemsFromJson(stratRows || []);
				} catch (err) {
					console.error("Failed to load WH40K data/stratagems", err);
				}

				if (typeof window !== "undefined") {
					window.weaponProfiles = weaponProfiles;
					window.unitDatabase = unitDatabase;
					window.abilitiesDatabase = abilitiesDatabase;
					window.factionCommands = factionCommands;
					window.factionOrders = factionOrders;
					window.coreStratagems = coreStratagems;
					window.dataReadyPromise = dataReadyPromise;

					window.canonicalFactionKey = canonicalFactionKey;
					window.canonicalUnitName = canonicalUnitName;
					window.getUnitFromDatabase = getUnitFromDatabase;
					window.getComposition = getComposition;
					window.presentStats = presentStats;
				}
			}

			// After data loads, refresh any existing units in state so their weapons/stats
			// pick up the database profiles (helps if state was restored before data ready)
			function rehydrateUnitsFromDatabase() {
				if (!window.unitDatabase || !Array.isArray(State.players)) return;
				State.players.forEach((player, pi) => {
					const faction =
						(player.army && player.army.faction) || player.faction || "";
					const updated = (player.units || []).map((u) => {
						const prof = findUnitProfileByName(u.name, faction);
						if (!prof) return u;
						return {
							...u,
							weapons: prof.weapons || u.weapons || [],
							stats: u.stats ||
								presentStats(prof) || {
									M: prof.movement,
									T: prof.toughness,
									Sv: prof.save,
									W: prof.wounds,
									Ld: prof.leadership,
									OC: prof.oc,
								},
						};
					});
					player.units = updated;
				});
				saveLocal();
				render();
			}

			function getUnitFromDatabase(factionLabel, unitName) {
				const fKey = canonicalFactionKey(factionLabel);
				const db = window.unitDatabase[fKey] || [];
				const wanted = canonicalUnitName(unitName).toLowerCase();
				return (
					db.find((u) => {
						const uname = String(u.name || "");
						const can = canonicalUnitName(uname).toLowerCase();
						return can === wanted || uname.toLowerCase() === wanted;
					}) || null
				);
			}

			// If you also store parsed composition per (faction, unit), normalize both:
			function getComposition(compStore, factionLabel, unitName) {
				const fKey = canonicalFactionKey(factionLabel);
				const uKey = canonicalUnitName(unitName);
				// however you store composition (example):
				// compStore[fKey]?.[uKey] -> { models: [...], ... }
				return compStore?.[fKey]?.[uKey] || null;
			}

			// When rendering stats, map your keys to the UI labels:
			function presentStats(u) {
				if (!u) return null;
				return {
					M: u.movement,
					T: u.toughness,
					Sv: u.save,
					W: u.wounds,
					Ld: u.leadership,
					OC: u.oc,
				};
			}
			// Kick off async data load from wh40k_10th.json
			dataReadyPromise = loadWh40kData().then(() => {
				rehydrateUnitsFromDatabase();
			});
			// Return Core + Faction stratagems filtered by phase/turn.
			// phase: string like "movement","shooting","charge","fight","battleshock","command","any"
			// whoseTurn: "current" | "opponent"
			function getStratagemsForContext(
				factionLabel,
				phase = "any",
				whoseTurn = "both"
			) {
				const fKey = canonicalFactionKey(factionLabel);
				const phaseLc = String(phase || "any").toLowerCase();
				const turnLc = String(whoseTurn || "both").toLowerCase();

				const all = [...(coreStratagems || [])];

				const matchPhase = (s) => {
					const list = Array.isArray(s.phases)
						? s.phases
						: normalizeStratPhases(s.phase || s.phases || "any");
					const arr = list.map((p) => String(p).toLowerCase());
					return arr.includes("any") || arr.includes(phaseLc);
				};
				const matchTurn = (s) => {
					const t = normalizeStratTurn(s.turn);
					return t === "both" || t === turnLc;
				};

				return all.filter((s) => matchPhase(s) && matchTurn(s));
			}
			// Export for use in main app
			if (typeof window !== "undefined") {
				window.weaponProfiles = weaponProfiles;
				window.unitDatabase = unitDatabase;
				window.abilitiesDatabase = abilitiesDatabase;
				window.factionCommands = factionCommands;
				window.factionOrders = factionOrders;
				window.coreStratagems = coreStratagems;
				window.getStratagemsForContext = getStratagemsForContext;

				// expose helper utilities for the UI
				window.canonicalFactionKey = canonicalFactionKey;
				window.canonicalUnitName = canonicalUnitName;
				window.getUnitFromDatabase = getUnitFromDatabase;
				window.getComposition = getComposition;
				window.presentStats = presentStats;
			}

			// ------------------------------
			// 10th Edition Missions (UI data)
			// This array is read by the Setup "Mission" picker and the Mission modal.
			// Fields used by UI: key, name, pack, type, deployment, summary
			// You can safely expand objects later with: primary, mission_rules, secondaries, notes, etc.
			// ------------------------------
			window.missions = [
				{
					key: "take-and-hold",
					name: "Take and Hold",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Hammer and Anvil",
					summary:
						"Score by controlling more objectives at the end of each battle round.",
				},
				{
					key: "scorched-earth",
					name: "Scorched Earth",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Dawn of War",
					summary:
						"Hold and destroy enemy-side objectives to score progressively.",
				},
				{
					key: "supply-drop",
					name: "Supply Drop",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Search and Destroy",
					summary:
						"Late-game supply objectives drop randomly; endgame-heavy scoring.",
				},
				{
					key: "purge-the-foe",
					name: "Purge the Foe",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Crucible of Battle",
					summary:
						"Score for holding and for destroying more units than the opponent.",
				},
				{
					key: "sites-of-power",
					name: "Sites of Power",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Sweeping Engagement",
					summary: "Characters are key to controlling special objective sites.",
				},
				{
					key: "vital-ground",
					name: "Vital Ground",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Tide of Conviction",
					summary: "Score extra for objectives outside your deployment zone.",
				},
				{
					key: "tear-down-their-icons",
					name: "Tear Down Their Icons",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Dawn of War",
					summary:
						"Plant explosives on enemy territory to earn end-of-round points.",
				},
				{
					key: "the-ritual",
					name: "The Ritual",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Hammer and Anvil",
					summary:
						"Perform repeated actions to build up primary scoring momentum.",
				},
				{
					key: "priority-targets",
					name: "Priority Targets",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Search and Destroy",
					summary:
						"Two priority objectives‚Äîkeep yours safe and contest the enemy‚Äôs.",
				},
				{
					key: "sweeping-clear",
					name: "Sweeping Clear",
					pack: "Leviathan",
					type: "Eternal War",
					deployment: "Sweeping Engagement",
					summary:
						"Progressive scoring with pushes across multiple midfield points.",
				},
				{
					key: "incursion-data-recovery",
					name: "Data Recovery",
					pack: "Pariah Nexus",
					type: "Incursion",
					deployment: "Crucible of Battle",
					summary:
						"Recover data from marked objectives; actions and control matter.",
				},
				{
					key: "incursion-salvage",
					name: "Salvage",
					pack: "Pariah Nexus",
					type: "Incursion",
					deployment: "Dawn of War",
					summary:
						"Secure and salvage resources; holding end-of-round is rewarded.",
				},
			];

			// Define globally so any early code won't error
			function unlockAiAudio() {
				// This gets overwritten later by the full AI block
			}
			const PHASE_HELP = {
				Command: `
											<p><strong>Command phase:</strong> Gain 1CP, resolve any "start of your Command phase" abilities and effects, select targets for army rules/stratagems as appropriate, and take any required Battle-shock tests as instructed by rules (many 10th edition rules check for below Half-strength here).</p>
										`,
				Movement: `
											<p><strong>Movement phase:</strong> Select units to move. Each unit can Normal Move, Advance (add D6 to Move and cannot shoot certain weapons or charge), or Fall Back (cannot shoot or charge unless a rule allows). Aircraft and other special moves follow their datasheet rules.</p>
										`,
				Shooting: `
											<p><strong>Shooting phase:</strong> Choose eligible units to shoot, select targets in range and line of sight, resolve attacks weapon-by-weapon (Hit ‚Üí Wound ‚Üí Saves ‚Üí Damage), and apply abilities like Rapid Fire, Blast, etc.</p>
										`,
				Charge: `
											<p><strong>Charge phase (10th):</strong> Pick eligible units one at a time to declare charges. A unit that Advanced or Fell Back cannot charge unless a rule allows it. Declare all intended targets up front; targets can fire Overwatch/defensive rules as applicable. Roll 2D6 and move each charging unit up to that distance toward the closest declared target, ending within Engagement Range. If you cannot reach any declared target, the charge fails and the unit makes no charge move.</p>
											<p class="sub">Tips: Remember to stay outside of enemy Engagement Range before declaring. You can move around other models as long as you maintain coherency and end within Engagement Range of at least one declared target. Multi-charges must get you into Engagement Range of <em>every</em> declared target or the charge fails.</p>
										`,
				Fight: `
											<p><strong>Fight phase:</strong> Units in Engagement Range fight in alternating order. Pile-In ‚Üí Make Attacks ‚Üí Remove Casualties ‚Üí Consolidate. Apply abilities such as Fights First/Last and modifiers from stratagems.</p>
										`,
				Battleshock: `
											<p><strong>Battle-shock step:</strong> Resolve any end-of-turn checks or effects tied to Battle-shock and mission rules. In 10th edition, many Battle-shock tests are taken at the start of the Command phase when a unit is below Half-strength; use this step to track ongoing Battle-shock effects and clean up end-of-turn abilities.</p>
										`,
			};

			function openPhaseModal(title, html) {
				const m = document.getElementById("phaseModal");
				const t = document.getElementById("phaseHelpTitle");
				const b = document.getElementById("phaseHelpBody");
				if (t) t.textContent = title || "Phase Help";
				if (b) b.innerHTML = html || "";
				if (m) m.classList.add("active");
			}
			function closePhaseModal() {
				const m = document.getElementById("phaseModal");
				if (m) m.classList.remove("active");
			}
			// ------------------------------
			// Weapon helpers (uses weaponProfiles loaded from wh40k_10th.json)
			// ------------------------------
			function getWeaponProfilesMap() {
				const db = window.weaponProfiles || {};
				// build a map by lowercase name for fuzzy matching from composition text
				const byName = new Map();
				for (const [key, prof] of Object.entries(db)) {
					const name =
						prof && prof.name
							? String(prof.name).toLowerCase().trim()
							: String(key).toLowerCase().trim();
					byName.set(name, { key, prof });
				}
				return { byName, byKey: db };
			}

			function extractWeaponsFromComposition(lines) {
				if (!Array.isArray(lines) || !lines.length) return [];
				const { byName } = getWeaponProfilesMap();

				// Build a list of { name, key } and sort by longest name first.
				const nameEntries = Array.from(byName.entries())
					.map(([nm, v]) => ({ name: nm, key: v.key }))
					.sort((a, b) => b.name.length - a.name.length);

				const foundKeys = new Set();

				// Escape regex helper
				const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

				for (const raw of lines) {
					let remaining = String(raw).toLowerCase();
					if (!remaining) continue;

					for (const { name, key } of nameEntries) {
						if (name.length < 3) continue; // ignore extremely short names
						// Whole-word match for the weapon name (case-insensitive)
						const re = new RegExp(`\\b${esc(name)}\\b`, "i");
						if (re.test(remaining)) {
							foundKeys.add(key);
							// Remove matched text from this line so shorter names contained within
							// (e.g., "scything talons" inside "gargantuan scything talons")
							// won't also match on the same line.
							// Replace all occurrences (use loop because of dynamic regex without /g flag capture)
							let m;
							while ((m = re.exec(remaining))) {
								const start = m.index;
								const end = start + m[0].length;
								remaining = `${remaining.slice(0, start)}${" ".repeat(
									m[0].length
								)}${remaining.slice(end)}`;
							}
						}
					}
				}

				return Array.from(foundKeys);
			}

			function renderWeaponProfileHTML(key) {
				const db = window.weaponProfiles || {};
				const p = db[key];
				if (!p) return '<div class="sub">No profile found.</div>';
				const isMelee = String(p.range).toLowerCase() === "melee";
				const accLabel = isMelee ? "WS" : "BS";
				const acc = isMelee ? p.ws ?? "-" : p.bs ?? "-";
				const abil =
					Array.isArray(p.abilities) && p.abilities.length
						? p.abilities.join(", ")
						: "‚Äî";
				return `
						  <div class="sub" style="margin-bottom:6px"><strong>${
								p.name || key
							}</strong></div>
						  <table class="weapon-table">
						    <thead>
						      <tr>
						        <th>Rng</th><th>A</th><th>${accLabel}</th><th>S</th><th>AP</th><th>D</th>
						      </tr>
						    </thead>
						    <tbody>
						      <tr>
						        <td>${p.range}</td>
						        <td>${p.attacks ?? "-"}</td>
						        <td>${acc}</td>
						        <td>${p.strength ?? "-"}</td>
						        <td>${p.ap ?? 0}</td>
						        <td>${p.damage ?? "-"}</td>
						      </tr>
						      <tr class="abilities-row">
						        <td colspan="6"><span class="muted">Abilities:</span> ${abil}</td>
						      </tr>
						    </tbody>
						  </table>
						`;
			}

			function renderWeaponsForUnit(unit, listEl, panelEl) {
				if (!listEl || !panelEl) return;
				const keys =
					(Array.isArray(unit.weapons) && unit.weapons.length
						? unit.weapons
						: extractWeaponsFromComposition(unit.composition || [])) || [];
				listEl.innerHTML = "";
				panelEl.innerHTML = "";
				panelEl.classList.add("hidden");
				const grid = panelEl.closest(".players");
				relayoutMasonry(grid);

				if (!keys.length) {
					listEl.innerHTML =
						'<span class="sub">No weapons detected from PDF.</span>';
					return;
				}

				// Build buttons
				keys.forEach((key) => {
					const p =
						(window.weaponProfiles && window.weaponProfiles[key]) || null;
					const btn = document.createElement("button");
					btn.className = "weapon-link";
					btn.type = "button";
					btn.setAttribute("data-weapon-key", key);
					btn.textContent = p ? p.name || key : key;
					btn.addEventListener("click", () => {
						const current = panelEl.getAttribute("data-open-key") || "";
						if (current === key && !panelEl.classList.contains("hidden")) {
							// toggle close
							panelEl.classList.add("hidden");
							panelEl.removeAttribute("data-open-key");
							panelEl.innerHTML = "";
						} else {
							panelEl.innerHTML = renderWeaponProfileHTML(key);
							panelEl.classList.remove("hidden");
							panelEl.setAttribute("data-open-key", key);
							// After injecting the table, shrink any too-long values to fit
							autoshrinkWeaponTable(panelEl);
						}

						// ‚ú® Recompute masonry span after height changes
						const grid = panelEl.closest(".players");
						relayoutMasonry(grid);
					});
					listEl.appendChild(btn);
				});
			}

			// --- Auto-shrink long values inside weapon tables so they don't ellipsis ---
			function isOverflowing(el) {
				return el && el.scrollWidth > el.clientWidth;
			}

			/**
			 * Reduce font-size inside a cell until the content fits on one line,
			 * without changing table layout. Falls back gracefully at a minimum size.
			 */
			function fitTextToCell(td, minPx = 9, maxPx = 12) {
				if (!td) return;
				// Start from computed (or cap at max)
				const computed = parseFloat(getComputedStyle(td).fontSize) || maxPx;
				let size = Math.min(computed, maxPx);

				// Reset any previous tweaks
				td.style.fontSize = size + "px";
				td.style.letterSpacing = "";

				// Shrink stepwise while overflowing
				while (isOverflowing(td) && size > minPx) {
					size -= 1;
					td.style.fontSize = size + "px";
					// Tighten tracking a touch when very small
					if (size <= minPx + 1) td.style.letterSpacing = "-0.2px";
				}
			}

			/**
			 * Apply autoshrink to all stat cells of a freshly-rendered weapon table.
			 * (Skips the abilities row which wraps by design.)
			 */
			function autoshrinkWeaponTable(root) {
				if (!root) return;
				const cells = root.querySelectorAll(
					".weapon-table tbody tr:not(.abilities-row) td"
				);
				cells.forEach((td) => fitTextToCell(td));
			}

			// ------------------------------
			// Data Models
			// ------------------------------
			/** @typedef {{name:string, models?:number, woundsPerModel?:number, keywords?:string[], abilities?:string[]}} ImportedUnit */

			const PHASES = [
				"Command",
				"Movement",
				"Shooting",
				"Charge",
				"Fight",
				"Battleshock",
			];

			const defaultArmy = () => ({ faction: "", units: [] });

			function deepClone(o) {
				return JSON.parse(JSON.stringify(o));
			}

			function makeId() {
				return Math.random().toString(36).slice(2, 9);
			}

			function nowISO() {
				return new Date().toISOString();
			}

			const commandModalState = {
				orders: [],
				playerIdx: null,
				selectedIdx: -1,
			};

			function log(msg) {
				const el = document.getElementById("log");
				if (!el) return; // no log panel present; skip
				const div = document.createElement("div");
				div.className = "item";
				div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
				el.prepend(div);
				while (el.children.length > 200) el.removeChild(el.lastChild);
			}

			function findUnitOwner(unitId) {
				for (let pi = 0; pi < State.players.length; pi++) {
					const arr = State.players[pi].units || [];
					const idx = arr.findIndex((u) => u.id === unitId);
					if (idx > -1) return { playerIdx: pi, index: idx, arr };
				}
				return null;
			}
			function removeUnitById(unitId) {
				const owner = findUnitOwner(unitId);
				if (!owner) return false;
				const unit = owner.arr[owner.index];
				owner.arr.splice(owner.index, 1);
				log(`Removed ${unit.name} from the battlefield.`);
				return true;
			}

			// Modal helpers
			function openSetupModal() {
				const m = document.getElementById("setupModal");
				if (m) m.classList.add("active");
			}
			function closeSetupModal() {
				const m = document.getElementById("setupModal");
				if (m) m.classList.remove("active");
			}
			function openStartModal() {
				const m = document.getElementById("startModal");
				if (m) m.classList.add("active");
			}
			function closeStartModal() {
				const m = document.getElementById("startModal");
				if (m) m.classList.remove("active");
				if (State.phaseIndex === 0) maybeOpenCommandPhaseModal();
			}
			function isStartReady() {
				const p1Ready = !!(
					State.players[0] &&
					Array.isArray(State.players[0].units) &&
					State.players[0].units.length > 0
				);
				const p2Ready = !!(
					State.players[1] &&
					Array.isArray(State.players[1].units) &&
					State.players[1].units.length > 0
				);
				const missionReady = !!State.mission;
				return p1Ready && p2Ready && missionReady;
			}
			function updateStartBattleButton() {
				const btn = document.getElementById("btnStartBattle");
				const hint = document.querySelector("#startModal .modal-footer .hint");
				if (!btn) return;
				const ready = isStartReady();
				btn.disabled = !ready;
				btn.classList.toggle("primary", ready);
				if (hint) {
					hint.textContent = ready
						? "All set. Begin the battle!"
						: "Upload both army lists and select a mission to begin.";
				}
			}
			function resetStateForNewGame() {
				State.round = 1;
				State.currentPlayer = 0;
				State.phaseIndex = 0;
				State.autoGainCP = true;
				State.players = [
					{ name: "Player 1", cp: 1, vp: 0, army: defaultArmy(), units: [] },
					{ name: "Player 2", cp: 1, vp: 0, army: defaultArmy(), units: [] },
				];
				localStorage.removeItem("wh40k_tracker_state_v1");
				log("New game started.");
			}

			/** Game state */
			const State = {
				round: 1,
				currentPlayer: 0, // 0 = p1, 1 = p2
				phaseIndex: 0,
				autoGainCP: true,
				mission: null, // shared mission for this battle
				players: [
					{ name: "Player 1", cp: 1, vp: 0, army: defaultArmy(), units: [] },
					{ name: "Player 2", cp: 1, vp: 0, army: defaultArmy(), units: [] },
				],
				// A flat, serialisable unit model stored per player
				/** @returns {{round:number, player:number}} */
				turnId() {
					return { round: this.round, player: this.currentPlayer };
				},
			};

			function saveLocal() {
				localStorage.setItem("wh40k_tracker_state_v1", JSON.stringify(State));
			}
			function loadLocal() {
				const raw = localStorage.getItem("wh40k_tracker_state_v1");
				if (!raw) return;
				try {
					const data = JSON.parse(raw);
					// Basic migration guard
					if (!Array.isArray(data.players) || data.players.length !== 2) return;
					Object.assign(State, data);
				} catch (e) {
					console.warn("Failed to load local state", e);
				}
			}

			// ------------------------------
			// External data lookups (unitDatabase from wh40k_10th.json)
			// ------------------------------
			function canonicaliseFactionName(f) {
				if (!f || typeof f !== "string") return "";
				const s = f
					.toLowerCase()
					.replace(/[^a-z0-9\s\-']/g, "")
					.trim();
				// try exact keys as-is
				if (window.unitDatabase && window.unitDatabase[s]) return s;
				// normalise spaces -> dashes, drop apostrophes
				const k = s.replace(/\s+/g, "-").replace(/'+/g, "");
				if (window.unitDatabase && window.unitDatabase[k]) return k;
				// fuzzy: find any key that appears inside the text (e.g., "astra militarum" -> "imperial-guard" via alias keys)
				if (window.unitDatabase) {
					const keys = Object.keys(window.unitDatabase);
					for (const key of keys) {
						if (s.includes(key)) return key;
					}
				}
				return k; // best effort
			}

			function findUnitProfileByName(name, factionHint) {
				if (!window.unitDatabase) return null;
				const normalize = (s) =>
					String(s || "")
						.toLowerCase()
						.replace(/[^a-z0-9]+/g, " ")
						.replace(/\s+/g, " ")
						.trim();
				const n = normalize(name);
				const fKey = canonicaliseFactionName(factionHint || "");

				const tryMatch = (arr) => {
					if (!Array.isArray(arr)) return null;
					// exact name first
					let prof = arr.find((u) => normalize(u.name) === n);
					if (prof) return prof;
					// loose contains (e.g., handle punctuation/case differences)
					prof = arr.find((u) => n.includes(normalize(u.name)));
					return prof || null;
				};

				// 1) search within hinted faction (including aliases added above)
				if (fKey && window.unitDatabase[fKey]) {
					const p = tryMatch(window.unitDatabase[fKey]);
					if (p) return p;
				}
				// 2) search across all factions as fallback
				for (const key of Object.keys(window.unitDatabase)) {
					const p = tryMatch(window.unitDatabase[key]);
					if (p) return p;
				}
				return null;
			}
			function renderCompositionHTML(lines) {
				if (!Array.isArray(lines) || !lines.length) {
					return '<span class="sub">No composition detected from PDF.</span>';
				}

				// Build HTML with proper nesting:
				// ‚Ä¢ Top level bullet opens a <li> (kept open until we see what's next)
				// ‚ó¶ Sub-bullets are nested inside a <ul> under the last <li>
				const out = [];
				out.push('<ul style="margin:6px 0 6px 18px">');

				let liOpen = false;
				let subOpen = false;

				const BULLET_TOP = /^[‚Ä¢‚óè*\-]\s*/; // solid bullets & dashes
				const BULLET_SUB = /^(?:‚ó¶|‚óã|¬∞|‚àô|¬∑|‚àò|o)\s*/i; // hollow/small bullets & 'o'

				const isTop = (s) => BULLET_TOP.test(s);
				const isSub = (s) => BULLET_SUB.test(s);

				for (const raw of lines) {
					const s = String(raw).trim();
					if (!s) continue;

					if (isTop(s)) {
						// Close previous sublist and li if needed
						if (subOpen) {
							out.push("</ul>");
							subOpen = false;
						}
						if (liOpen) {
							out.push("</li>");
							liOpen = false;
						}
						// Open new top-level li
						const text = s.replace(BULLET_TOP, "");
						out.push("<li>" + text);
						liOpen = true;
					} else if (isSub(s)) {
						// Ensure we have a parent <li>
						if (!liOpen) {
							out.push("<li>");
							liOpen = true;
						}
						// Open a nested <ul> if not already open
						if (!subOpen) {
							out.push('<ul style="margin:4px 0 4px 18px">');
							subOpen = true;
						}
						const text = s.replace(BULLET_SUB, "");
						out.push("<li>" + text + "</li>");
					}
				}

				// Close any open tags
				if (subOpen) out.push("</ul>");
				if (liOpen) out.push("</li>");
				out.push("</ul>");

				return out.join("");
			}
			// Layout helpers (no-op now that each column is independent)
			function relayoutMasonry(_) {
				/* no-op */
			}
			function relayoutAllGrids() {
				/* no-op */
			}
			// No resize listener needed anymore
			// ------------------------------
			// Audio helpers (placeholder files ‚Äî add your own later)
			const soundPools = {
				woundAdd: [
					"sounds/heal-1.mp3",
					"sounds/heal-2.mp3",
					"sounds/heal-3.mp3",
					"sounds/heal-4.mp3",
					"sounds/heal-5.mp3",
				],
				woundRemove: [
					"sounds/wound-1.mp3",
					"sounds/wound-2.mp3",
					"sounds/wound-3.mp3",
					"sounds/wound-4.mp3",
					"sounds/wound-5.mp3",
				],
				unitDeath: [
					"sounds/death-1.mp3",
					"sounds/death-2.mp3",
					"sounds/death-3.mp3",
					"sounds/death-4.mp3",
					"sounds/death-5.mp3",
				],
			};
			const soundCursor = {
				woundAdd: 0,
				woundRemove: 0,
				unitDeath: 0,
			};
			function playSoundFromPool(poolKey) {
				const list = soundPools[poolKey];
				if (!list || !list.length) return;
				const idx = soundCursor[poolKey] % list.length;
				soundCursor[poolKey] = (idx + 1) % list.length;
				try {
					const audio = new Audio(list[idx]);
					audio.volume = 0.9;
					audio.play().catch(() => {});
				} catch (err) {
					console.warn("Audio playback failed", err);
				}
			}
			// Track expanded unit cards across re-renders
			function captureExpandedUnitIds() {
				return Array.from(
					document.querySelectorAll(".unit-card [data-details].active")
				)
					.map((el) => el.closest("[data-unit-id]")?.dataset.unitId)
					.filter(Boolean);
			}
			function restoreExpandedUnitIds(ids) {
				if (!ids || !ids.length) return;
				const want = new Set(ids);
				document
					.querySelectorAll(".unit-card [data-details]")
					.forEach((detailsEl) => {
						const card = detailsEl.closest("[data-unit-id]");
						if (!card || !want.has(card.dataset.unitId)) return;
						detailsEl.classList.add("active");
						detailsEl.style.maxHeight = "none";
						const outerCard = detailsEl.closest(".unit-card");
						if (outerCard) outerCard.classList.add("expanded");
						const nameEl = card.querySelector(".unit-name");
						if (nameEl) nameEl.setAttribute("aria-expanded", "true");
					});
			}
			// Helper for smooth expand/collapse of unit details
			function smoothToggle(el) {
				if (!el) return;
				const card = el.closest(".unit-card");
				const isOpening = !el.classList.contains("active");

				if (isOpening) {
					// Prepare: set to current height (0), then measure and animate to scrollHeight
					el.classList.add("active");
					if (card) card.classList.add("expanded");
					el.style.maxHeight = "0px"; // ensure we start collapsed
					// Next frame to allow transition
					requestAnimationFrame(() => {
						const target = el.scrollHeight;
						el.style.maxHeight = target + "px";
						const gridEarly = el.closest(".players");
						relayoutMasonry(gridEarly);
					});

					const onEnd = (e) => {
						if (e.propertyName === "max-height") {
							// Allow content growth while open
							el.style.maxHeight = "none";
							const grid = el.closest(".players");
							relayoutMasonry(grid);
							el.removeEventListener("transitionend", onEnd);
						}
					};
					el.addEventListener("transitionend", onEnd);
				} else {
					if (card) card.classList.remove("expanded");
					// Closing: set a fixed height first, then animate to 0
					const current = el.scrollHeight;
					el.style.maxHeight = current + "px";
					// force reflow to apply the fixed height before collapsing
					void el.offsetHeight; // reflow
					el.classList.remove("active");
					requestAnimationFrame(() => {
						el.style.maxHeight = "0px";
					});

					const onEnd = (e) => {
						if (e.propertyName === "max-height") {
							// Cleanup inline style when fully collapsed
							el.style.maxHeight = "";

							// ‚ú® Recompute the grid span now that we‚Äôre actually collapsed
							const grid = el.closest(".players");
							relayoutMasonry(grid);

							el.removeEventListener("transitionend", onEnd);
						}
					};
					el.addEventListener("transitionend", onEnd);
				}
			}
			// Units / Effects helpers
			// ------------------------------
			/** Create a tracked unit from an imported unit */
			function createUnit(u) {
				// pull wounds per model from unitDatabase (wh40k_10th.json) when available
				const factionHint =
					u.__faction || (State && State._importFactionHint) || "";
				const models = Number(u.models || 1);

				const profile = findUnitProfileByName(u.name || "Unit", factionHint);
				const wpmFromProfile = profile && Number(profile.wounds);

				const wpm = Number.isFinite(wpmFromProfile)
					? wpmFromProfile
					: Number(u.woundsPerModel || 1);

				const totalW = models * wpm;
				return {
					id: makeId(),
					name: u.name || "Unit",
					models,
					woundsPerModel: wpm,
					totalWounds: totalW,
					remainingWounds: totalW,
					// Prefer weapon keys from the database when present; fallback to composition-derived later
					weapons:
						profile && Array.isArray(profile.weapons) ? profile.weapons : [],
					keywords: Array.isArray(u.keywords)
						? u.keywords
						: typeof u.keywords === "string"
						? u.keywords
								.split(/[,;]+/)
								.map((s) => s.trim())
								.filter(Boolean)
						: profile && profile.role
						? [profile.role]
						: [],
					abilities: Array.isArray(u.abilities)
						? u.abilities
						: typeof u.abilities === "string"
						? u.abilities
								.split(/[,;]+/)
								.map((s) => s.trim())
								.filter(Boolean)
						: [],
					effects: [],
					composition: Array.isArray(u.composition) ? u.composition : [],
					stats: profile
						? {
								M: profile.movement,
								T: profile.toughness,
								Sv: profile.save,
								W: Number(profile.wounds),
								Ld: profile.leadership,
								OC: profile.oc,
						  }
						: null,
				};
			}

			function applyDamage(unit, delta) {
				const before = unit.remainingWounds;
				unit.remainingWounds = Math.max(
					0,
					Math.min(unit.totalWounds, unit.remainingWounds - delta)
				);
				const after = unit.remainingWounds;
				const change = after - before;

				if (change !== 0) {
					if (change < 0) {
						playSoundFromPool("woundRemove");
					} else {
						playSoundFromPool("woundAdd");
					}
					log(
						`${unit.name}: ${
							change < 0 ? `took ${-change}` : `healed ${change}`
						} wound(s). ${Math.max(after, 0)}/${unit.totalWounds} remain.`
					);
				}

				// When a unit reaches 0 wounds, offer to remove it. If cancelled, keep it at 1W.
				if (after === 0) {
					const ok = confirm(
						`${unit.name} has 0 wounds remaining.\nRemove it from the battlefield?`
					);
					if (ok) {
						playSoundFromPool("unitDeath");
						// remove from state
						removeUnitById(unit.id);
					} else {
						// restore to 1W in case the reduction was a mistake
						unit.remainingWounds = 1;
						log(`${unit.name}: kept on the table at 1 wound.`);
					}
				}
			}

			function currentPhase() {
				return PHASES[State.phaseIndex];
			}

			function nextPhase() {
				const oldPhase = State.phaseIndex;
				const oldTurn = { round: State.round, player: State.currentPlayer };
				// advance
				if (State.phaseIndex < PHASES.length - 1) {
					State.phaseIndex++;
					expireEffects({
						phaseAdvanced: true,
						turnChanged: false,
						oldTurn,
						oldPhase,
					});
					onPhaseStart();
				} else {
					// Leaving Battleshock -> next player's Command
					State.phaseIndex = 0;
					State.currentPlayer = State.currentPlayer === 0 ? 1 : 0;
					if (State.currentPlayer === 0) State.round++;
					expireEffects({
						phaseAdvanced: true,
						turnChanged: true,
						oldTurn,
						oldPhase,
					});
					onPhaseStart();
				}
				render();
				saveLocal();
				// If stratagems modal is open, refresh its contents for the new context
				if (__openStratForPlayer !== null) {
					const listEl = document.getElementById("stratList");
					if (listEl) renderStratListInto(listEl, __openStratForPlayer);
				}
			}

			function prevPhase() {
				if (State.phaseIndex > 0) {
					State.phaseIndex--;
					render();
					saveLocal();
					if (State.phaseIndex === 0) maybeOpenCommandPhaseModal();
					return;
				}
				// going back from Command -> previous player's Battleshock
				if (State.round === 1 && State.currentPlayer === 0) return; // at start
				State.phaseIndex = PHASES.length - 1;
				State.currentPlayer = State.currentPlayer === 0 ? 1 : 0;
				if (State.currentPlayer === 1)
					State.round = Math.max(1, State.round - 1);
				render();
				saveLocal();
				// If stratagems modal is open, refresh its contents for the new context
				if (__openStratForPlayer !== null) {
					const listEl = document.getElementById("stratList");
					if (listEl) renderStratListInto(listEl, __openStratForPlayer);
				}
			}

			function onPhaseStart() {
				if (State.phaseIndex === 0 && State.autoGainCP) {
					const p = State.players[State.currentPlayer];
					p.cp += 1;
					log(`${p.name} gains +1 CP (Command phase).`);
				}
				maybeOpenCommandPhaseModal();
			}

			function effectLabel(ef) {
				if (!ef) return "";
				const name = ef.name || "Effect";
				return ef.detail ? `${name}: ${ef.detail}` : name;
			}

			function expireEffects(ctx) {
				// ctx: {phaseAdvanced:boolean, turnChanged:boolean, oldTurn:{round,player}, oldPhase:number}
				for (const player of State.players) {
					for (const unit of player.units) {
						const keep = [];
						for (const ef of unit.effects || []) {
							let remove = false;
							if (ef.expiry === "phase" && ctx.phaseAdvanced) {
								// Remove on any phase advance after creation phase within the same turn
								if (
									ef.createdAt.round === ctx.oldTurn.round &&
									ef.createdAt.player === ctx.oldTurn.player
								) {
									remove = true;
								}
							} else if (ef.expiry === "turn" && ctx.turnChanged) {
								if (
									ef.createdAt.round === ctx.oldTurn.round &&
									ef.createdAt.player === ctx.oldTurn.player
								) {
									remove = true;
								}
							} else if (ef.expiry === "opponentTurn" && ctx.turnChanged) {
								// Opponent's turn just ended if new current player equals ef.createdAt.player
								const newPlayer = ctx.oldTurn.player === 0 ? 1 : 0;
								if (newPlayer === ef.createdAt.player) {
									remove = true;
								}
							} else if (ef.expiry === "rounds") {
								if (State.round >= ef.createdAt.round + (ef.rounds || 1))
									remove = true;
							}
							if (remove) {
								log(`${unit.name}: Effect ended ‚Äî ${effectLabel(ef)}`);
							}
							if (!remove) keep.push(ef);
						}
						unit.effects = keep;
					}
				}
			}

			// ------------------------------
			// Command Phase orders modal
			// ------------------------------
			function getCommandOrdersForFaction(factionLabel) {
				const canon =
					typeof window.canonicalFactionKey === "function"
						? window.canonicalFactionKey(factionLabel || "")
						: String(factionLabel || "").toLowerCase();
				const fuzzy =
					typeof canonicaliseFactionName === "function"
						? canonicaliseFactionName(factionLabel || "")
						: canon;
				const rawClean = String(factionLabel || "")
					.toLowerCase()
					.replace(/[^a-z0-9]+/g, "-")
					.replace(/^-+|-+$/g, "");
				const db = window.factionOrders || {};
				const hyphen = canon.replace(/\s+/g, "-");
				const list =
					db[canon] ||
					db[hyphen] ||
					db[fuzzy] ||
					db[factionLabel?.toLowerCase()] ||
					db[rawClean] ||
					db[rawClean.replace(/-+/g, "")] ||
					db[Object.keys(db).find((k) => rawClean && rawClean.includes(k))] ||
					db[Object.keys(db).find((k) => rawClean && k.includes(rawClean))] ||
					[];
				return Array.isArray(list) ? list : [];
			}

			function anchorCommandModal(playerIdx) {
				const modal = document.getElementById("commandModal");
				const dialog = modal ? modal.querySelector(".modal-dialog") : null;
				const panel = document.getElementById(
					playerIdx === 0 ? "p1Units" : "p2Units"
				);
				if (!modal || !dialog || !panel) return;
				const rect = panel.getBoundingClientRect();
				// Keep the dialog high on the viewport for visibility, while centered on the player's column
				const top = window.scrollY + 16;
				const centerX = rect.left + rect.width / 2 + window.scrollX;
				dialog.style.position = "absolute";
				dialog.style.left = `${centerX}px`;
				dialog.style.top = `${top}px`;
				dialog.style.transform = "translateX(-50%)";
				dialog.style.width = `${Math.min(rect.width, 560)}px`;
				modal.style.alignItems = "flex-start";
				modal.style.justifyContent = "center";
			}

			function renderCommandList() {
				const listEl = document.getElementById("commandList");
				const applyBtn = document.getElementById("commandApply");
				if (!listEl) return;
				const orders = commandModalState.orders || [];
				listEl.innerHTML = "";
				if (!orders.length) {
					listEl.innerHTML =
						'<div class="sub">No commands/orders available.</div>';
					if (applyBtn) applyBtn.disabled = true;
					return;
				}
				if (applyBtn) applyBtn.disabled = commandModalState.selectedIdx < 0;
				orders.forEach((o, idx) => {
					const btn = document.createElement("button");
					btn.type = "button";
					btn.className =
						"command-option" +
						(idx === commandModalState.selectedIdx ? " active" : "");
					btn.innerHTML = `<strong>${o.name}</strong><div class="sub">${
						o.effect || ""
					}</div>`;
					btn.addEventListener("click", () => {
						commandModalState.selectedIdx = idx;
						renderCommandList();
					});
					listEl.appendChild(btn);
				});
			}

			function openCommandPhaseModal(playerIdx) {
				const modal = document.getElementById("commandModal");
				if (!modal) return false;
				const player = State.players[playerIdx];
				if (!player) return false;
				const faction =
					(player.army && player.army.faction) || player.faction || "";
				const orders = getCommandOrdersForFaction(faction);
				const units = Array.isArray(player.units) ? player.units : [];
				if (!units.length) return false;

				commandModalState.orders = orders;
				commandModalState.playerIdx = playerIdx;
				commandModalState.selectedIdx = orders.length ? 0 : -1;

				const title = document.getElementById("commandTitle");
				if (title)
					title.textContent = `Command Phase ‚Äî ${
						player.name || `Player ${playerIdx + 1}`
					}`;
				const ctx = document.getElementById("commandContext");
				if (ctx)
					ctx.textContent = `${player.name || `Player ${playerIdx + 1}`} ‚Ä¢ ${
						faction || "Faction"
					}`;

				commandModalState.selectedIdx = orders.length ? 0 : -1;
				renderCommandList();

				const unitSelect = document.getElementById("commandUnitSelect");
				if (unitSelect)
					unitSelect.innerHTML = units
						.map((u) => `<option value="${u.id}">${u.name}</option>`)
						.join("");

				anchorCommandModal(playerIdx);
				modal.classList.add("active");
				return true;
			}

			function closeCommandPhaseModal() {
				const modal = document.getElementById("commandModal");
				if (modal) modal.classList.remove("active");
				commandModalState.orders = [];
				commandModalState.playerIdx = null;
				commandModalState.selectedIdx = -1;
			}

			function openCommandsForPlayer(playerIdx) {
				if (State.phaseIndex !== 0 || State.currentPlayer !== playerIdx) {
					alert(
						"Commands can only be opened during that player's Command phase."
					);
					return;
				}
				const ok = openCommandPhaseModal(playerIdx);
				if (!ok) alert("No commands/orders available for this faction.");
			}

			function applySelectedCommandOrder() {
				const unitSelect = document.getElementById("commandUnitSelect");
				if (!unitSelect) return;

				const order = commandModalState.orders[commandModalState.selectedIdx];
				const playerIdx =
					commandModalState.playerIdx != null
						? commandModalState.playerIdx
						: State.currentPlayer;
				const units =
					(State.players[playerIdx] && State.players[playerIdx].units) || [];
				const unit = units.find((u) => u.id === unitSelect.value);
				if (!order || !unit) return;

				const ef = {
					id: makeId(),
					name: order.name,
					detail: order.effect || "",
					expiry: order.expires || "turn",
					rounds: order.rounds,
					createdAt: {
						round: State.round,
						player: State.currentPlayer,
						phaseIndex: State.phaseIndex,
						iso: nowISO(),
					},
				};
				if (!unit.effects) unit.effects = [];
				unit.effects.push(ef);
				log(
					`${unit.name}: Order applied ‚Äî ${effectLabel(ef)} (${
						ef.expiry === "persistent" ? "‚àû" : ef.expiry
					})`
				);
				saveLocal();
				render();
				closeCommandPhaseModal();
			}

			function maybeOpenCommandPhaseModal() {
				if (State.phaseIndex !== 0) return;
				const startModal = document.getElementById("startModal");
				if (startModal && startModal.classList.contains("active")) return;
				const player = State.players[State.currentPlayer];
				if (!player || !(player.units && player.units.length)) return;
				// Do not reopen if already open
				const modal = document.getElementById("commandModal");
				if (modal && modal.classList.contains("active")) return;
				openCommandPhaseModal(State.currentPlayer);
			}

			// ------------------------------
			// PDF Import Helpers (Battlescribe/Wahapedia style lists)
			// ------------------------------
			async function readPdfText(file) {
				const pdfjs =
					window.__pdfjs || window.pdfjsLib || window["pdfjs-dist/build/pdf"];
				if (!pdfjs) throw new Error("PDF.js not loaded");
				const buf = await file.arrayBuffer();
				const doc = await pdfjs.getDocument({ data: buf }).promise;
				let text = "";
				for (let p = 1; p <= doc.numPages; p++) {
					const page = await doc.getPage(p);
					const content = await page.getTextContent();

					// Reconstruct lines using hasEOL so bullets and their text stay together.
					let line = "";
					const pageLines = [];
					for (const it of content.items) {
						const s = "str" in it ? it.str : it?.unicode || "";
						line += s;
						if (it.hasEOL) {
							pageLines.push(line.trim());
							line = "";
						} else {
							line += " ";
						}
					}
					if (line.trim()) pageLines.push(line.trim());

					text += pageLines.join("\n") + "\n";
				}
				return text;
			}

			function parseArmyPdfText(raw) {
				// Normalize whitespace and split lines
				const text = raw
					.replace(/\u00A0/g, " ")
					.replace(/[\r\t]+/g, " ")
					.replace(/ +/g, " ")
					.trim();
				const lines = text
					.split(/\n+/)
					.map((s) => s.trim())
					.filter(Boolean);

				const SECTION_HEADERS = new Set([
					"CHARACTERS",
					"BATTLELINE",
					"DEDICATED TRANSPORTS",
					"OTHER DATASHEETS",
					"ALLIED UNITS",
					"LORD OF WAR",
					"ELITES",
					"FAST ATTACK",
					"HEAVY SUPPORT",
					"FLYER",
				]);

				// Try to infer faction and army name from the first 20 lines
				let faction = "";
				let army_name = "";
				for (let i = 0; i < Math.min(20, lines.length); i++) {
					const L = lines[i];
					if (!army_name && /Points\)/i.test(L))
						army_name = L.replace(/\s*\(.*$/, "").trim();
					if (
						!faction &&
						/(Astra Militarum|Space Marines|Chaos|Tyranids|Adept[a]? Sororitas|Orks|Adeptus Mechanicus|Necrons|T'au|Eldar|Leagues of Votann|Genestealer Cults)/i.test(
							L
						)
					)
						faction = L;
				}

				// --- Helper: model line detection and tokens ---
				const WEAPON_TOKENS = [
					"lasgun",
					"lascannon",
					"plasma",
					"melta",
					"flamer",
					"grenade",
					"missile",
					"launcher",
					"bolter",
					"bolt",
					"pistol",
					"rifle",
					"cannon",
					"stubber",
					"mortar",
					"autocannon",
					"autogun",
					"sword",
					"chainsword",
					"knife",
					"power",
					"gauntlet",
					"spitter",
					"devourer",
					"claw",
					"talon",
					"talons",
					"bonesword",
					"barbed",
					"hammer",
					"maul",
					"blade",
					"carbine",
					"shotgun",
					"volley",
					"hot-shot",
					"hot‚Äëshot",
					"hot‚Äìshot",
					"vox",
					"vox-caster",
					"voxcaster",
					"weapon",
				];
				function isProbablyModelLine(s) {
					const line = s.trim();
					// Ignore sub-bullets (wargear) like "‚ó¶  9x Close combat weapon"
					if (line.startsWith("‚ó¶")) return false;
					// Only count top-level bullets that start with ‚Ä¢, -, or *
					const m = line.match(/^[‚Ä¢\-*]\s*(\d+)x\s+([A-Za-z][A-Za-z\-\s'‚Äô]+)/);
					if (!m) return false;
					const text = m[2].toLowerCase();
					// Filter typical wargear/weapon words
					if (text.includes("weapon")) return false;
					if (WEAPON_TOKENS.some((tok) => text.includes(tok))) return false;
					return true;
				}

				// Identify unit headers like "Kasrkin (110 Points)" or "Hormagaunts (65 Points)"
				const unitHeader = /^(.*)\((\d+) Points\)$/i;
				let seenSectionHeader = false;
				const units = [];
				for (let i = 0; i < lines.length; i++) {
					const L = lines[i];
					if (SECTION_HEADERS.has(L.toUpperCase())) {
						seenSectionHeader = true;
						continue;
					}
					// Only consider unit headers after we have seen at least one section header
					const m = seenSectionHeader ? L.match(unitHeader) : null;
					if (m) {
						const name = m[1].trim();
						// Collect following lines until next header or section
						const block = [];
						let j = i + 1;
						for (; j < lines.length; j++) {
							const nL = lines[j];
							if (SECTION_HEADERS.has(nL.toUpperCase()) || unitHeader.test(nL))
								break;
							block.push(nL);
						}
						i = j - 1;
						// Merge bullet-only lines with the next NON-empty text line.
						// Some PDFs render bullets (‚Ä¢ / ‚ó¶) on their own line, then the content on a later line.
						// We also skip over empty spacer lines before merging.
						const merged = [];
						const isTopBulletOnly = (s) => /^[‚Ä¢‚óè*\-]\s*$/.test(s);
						const isSubBulletOnly = (s) => /^(?:‚ó¶|‚óã|¬∞|‚àô|¬∑|‚àò|o)\s*$/i.test(s);
						const isBulletOnly = (s) =>
							isTopBulletOnly(s) || isSubBulletOnly(s);
						const hasBulletWithText = (s) =>
							/^(?:[‚Ä¢‚óè*\-]|[‚ó¶‚óã¬∞‚àô¬∑‚àòo])\s+/.test(s);

						for (let k = 0; k < block.length; k++) {
							const a = (block[k] || "").trim();

							if (isBulletOnly(a)) {
								// Seek forward to the next non-empty line
								let m = k + 1;
								while (m < block.length && !(block[m] || "").trim()) m++;
								if (m < block.length) {
									const next = (block[m] || "").trim();
									if (hasBulletWithText(next)) {
										// The next line already has a bullet + text; just use that instead of the lone bullet
										merged.push(next);
									} else {
										// Append the text to the bullet symbol we saw on its own
										merged.push(a + " " + next);
									}
									k = m; // skip the consumed line(s)
								} else {
									// Nothing to merge with; keep the bullet so it is visible
									merged.push(a);
								}
								continue;
							}

							// Normal line
							merged.push(a);
						}

						// Capture composition bullets from the merged block
						const comp = [];
						for (const tRaw of merged) {
							const t = (tRaw || "").trim();
							if (/^(?:[‚Ä¢‚óè*\-]|[‚ó¶‚óã¬∞‚àô¬∑‚àòo])\s*/i.test(t)) comp.push(t);
						}
						// Count models like "10x Hormagaunt", "1x Sergeant", etc., but only likely model lines
						let models = 0;
						for (const b of block) {
							if (!isProbablyModelLine(b)) continue;
							const mx = b.match(/(\d+)x\s+/i);
							if (mx) models += parseInt(mx[1], 10);
						}
						if (!models) models = 1; // Vehicles/solitary models default to 1
						units.push({
							name,
							models,
							woundsPerModel: 1,
							keywords: [],
							abilities: [],
							composition: comp,
						});
					}
				}

				return { faction, army_name: army_name || "Imported PDF", units };
			}

			async function processArmyFileForPlayer(f, targetIdx) {
				try {
					if (!(f.type === "application/pdf" || /\.pdf$/i.test(f.name))) {
						alert("Please upload a PDF army list.");
						return;
					}
					const raw = await readPdfText(f);
					const army = parseArmyPdfText(raw);

					State.players[targetIdx].army = {
						faction: army.faction || "",
						army_name: army.army_name || "",
						units: [],
					};
					State._importFactionHint = army.faction || "";
					const _factionHint = army.faction || "";

					State.players[targetIdx].units = (army.units || []).map((u) =>
						createUnit({ ...u, __faction: _factionHint })
					);

					updateStartBattleButton();
					log(
						`${State.players[targetIdx].name}: Imported ${army.units.length} unit(s) from PDF.`
					);
					render();
					saveLocal();
				} catch (err) {
					console.error(err);
					alert("Import failed: " + (err.message || err));
				}
			}

			// ------------------------------
			// Dice Roller
			// ------------------------------
			function parseDiceExpr(expr) {
				// Supports: NdM+K / NdM-K / d6 / 6 / 6d6
				expr = (expr || "").toString().trim();
				if (!expr) return null;
				const m =
					expr.match(/^(\d+)?d(\d+)([+-]\d+)?$/i) || expr.match(/^(\d+)$/);
				if (!m) return null;
				if (m[0].includes("d")) {
					const num = parseInt(m[1] || "1", 10);
					const sides = parseInt(m[2], 10);
					const mod = m[3] ? parseInt(m[3], 10) : 0;
					return { num, sides, mod };
				} else {
					const num = parseInt(m[1], 10);
					return { num, sides: 6, mod: 0 };
				}
			}

			function rollDice(num, sides) {
				const out = [];
				for (let i = 0; i < num; i++)
					out.push(1 + Math.floor(Math.random() * sides));
				return out;
			}

			function doRoll(expr, tn) {
				const spec = parseDiceExpr(expr);
				if (!spec) return { err: "Bad expression" };
				const rolls = rollDice(spec.num, spec.sides);
				const total = rolls.reduce((a, b) => a + b, 0) + spec.mod;
				let successes = null;
				if (tn && Number.isFinite(tn))
					successes = rolls.filter((v) => v >= tn).length;
				return { spec, rolls, total, successes };
			}

			function renderDiceFaces(container, num, sides) {
				container.innerHTML = "";
				const maxShow = Math.min(num, 50);
				// Dynamically scale dice size to fit up to 50 dice within the existing area.
				// Base size ~32px, shrink progressively as counts rise; never smaller than 10px.
				const baseSize = 56; // larger default
				const scaleFactor = Math.max(0.4, 1 - (maxShow - 1) * 0.01); // very gentle taper
				const sizePx = Math.max(16, Math.round(baseSize * scaleFactor));
				container.style.setProperty("--die-size", `${sizePx}px`);
				for (let i = 0; i < maxShow; i++) {
					const d = document.createElement("div");
					d.className = "die spin";
					d.textContent =
						1 + Math.floor(Math.random() * Math.max(2, Math.min(20, sides)));
					container.appendChild(d);
				}
				if (num > maxShow) {
					const more = document.createElement("span");
					more.className = "more-badge";
					more.textContent = `+${num - maxShow} more`;
					container.appendChild(more);
				}
			}

			function tickDiceFaces(container, sides) {
				const diceEls = container.querySelectorAll(".die");
				diceEls.forEach((d) => {
					d.textContent =
						1 + Math.floor(Math.random() * Math.max(2, Math.min(20, sides)));
				});
			}

			function applyDiceHighlightAndSummary(
				container,
				rolls,
				spec,
				threshold,
				successes
			) {
				const diceEls = container.querySelectorAll(".die");
				const maxShow = Math.min(spec.num, diceEls.length);

				// Apply final roll values + green highlight
				for (let i = 0; i < maxShow; i++) {
					const val = rolls[i];
					const el = diceEls[i];
					el.textContent = val;

					if (Number.isFinite(threshold) && val >= threshold) {
						el.classList.add("dice-highlight");
					} else {
						el.classList.remove("dice-highlight");
					}
				}

				// Build the readout text
				const outEl = document.getElementById("diceOut");
				if (!outEl) return;

				// Success badge near dice
				const badge = document.createElement("span");
				badge.className = "dice-success-badge";
				if (Number.isFinite(threshold) && typeof successes === "number") {
					badge.innerHTML = `<strong style="font-size:18px">${successes} ‚â• ${threshold}+</strong>`;
				} else {
					badge.textContent = "No threshold";
				}

				// Clear and rebuild the dice summary area
				outEl.innerHTML = "";
				outEl.appendChild(badge);
			}

			function runDiceAnimation(spec, finalRolls, threshold, successes) {
				return new Promise((resolve) => {
					const anim = document.getElementById("diceAnim");
					if (!anim) return resolve();

					// Build spinning dice placeholders
					renderDiceFaces(anim, spec.num, spec.sides);

					const start = performance.now();
					const duration = Math.min(1500, 400 + spec.num * 80);
					const interval = setInterval(
						() => tickDiceFaces(anim, spec.sides),
						90
					);

					function end() {
						clearInterval(interval);
						// Stop spinning
						anim
							.querySelectorAll(".die")
							.forEach((d) => d.classList.remove("spin"));
						// Apply final results + highlighting + summary
						applyDiceHighlightAndSummary(
							anim,
							finalRolls,
							spec,
							threshold,
							successes
						);
						resolve();
					}

					function raf(t) {
						if (t - start >= duration) return end();
						requestAnimationFrame(raf);
					}
					requestAnimationFrame(raf);
				});
			}

			// --- Saving Roll checker (S vs T) ---
			function woundRollNeeded(str, tough) {
				if (
					!Number.isFinite(str) ||
					!Number.isFinite(tough) ||
					str <= 0 ||
					tough <= 0
				)
					return null;
				if (str >= tough * 2) return "2+";
				if (str > tough) return "3+";
				if (str === tough) return "4+";
				if (str * 2 <= tough) return "6+";
				return "5+";
			}

			function woundRuleText(str, tough, result) {
				if (!result) return "Enter Strength and Toughness.";
				if (str >= tough * 2) return "S ‚â• 2T ‚Üí 2+";
				if (str > tough) return "S > T ‚Üí 3+";
				if (str === tough) return "S = T ‚Üí 4+";
				if (str * 2 <= tough) return "S ‚â§ T/2 ‚Üí 6+";
				return "S < T ‚Üí 5+";
			}

			function updateWoundHelper() {
				const sEl = document.getElementById("woundStr");
				const tEl = document.getElementById("woundTough");
				const out = document.getElementById("woundResult");
				const rule = document.getElementById("woundRule");
				if (!sEl || !tEl || !out || !rule) return;

				const s = parseInt(sEl.value, 10);
				const t = parseInt(tEl.value, 10);
				const res = woundRollNeeded(s, t);

				out.textContent = res ? `Wounds on ${res}` : "‚Äî";
				rule.textContent = woundRuleText(s, t, res);
			}

			function renderWoundTable() {
				const tbl = document.getElementById("woundTable");
				if (!tbl) return;
				tbl.innerHTML = "";

				const header = document.createElement("div");
				header.className = "row head";
				const corner = document.createElement("div");
				corner.className = "cell muted";
				corner.textContent = "S‚Üì / T‚Üí";
				header.appendChild(corner);
				for (let t = 1; t <= 10; t++) {
					const cell = document.createElement("div");
					cell.className = "cell head";
					cell.textContent = t;
					header.appendChild(cell);
				}
				tbl.appendChild(header);

				for (let s = 1; s <= 10; s++) {
					const row = document.createElement("div");
					row.className = "row";
					const head = document.createElement("div");
					head.className = "cell head";
					head.textContent = s;
					row.appendChild(head);
					for (let t = 1; t <= 10; t++) {
						const cell = document.createElement("div");
						cell.className = "cell";
						cell.textContent = woundRollNeeded(s, t) || "‚Äì";
						row.appendChild(cell);
					}
					tbl.appendChild(row);
				}
			}

			function toggleWoundTable() {
				const tbl = document.getElementById("woundTable");
				const btn = document.getElementById("woundTableToggle");
				if (!tbl || !btn) return;
				const willShow = tbl.hidden;
				tbl.hidden = !willShow;
				tbl.classList.toggle("visible", willShow);
				btn.textContent = willShow ? "Hide S/T table" : "Show S/T table";
			}

			// === DICE ROLL BUTTON HANDLER ===
			document.getElementById("btnRoll").addEventListener("click", () => {
				// üîä Play dice sound if available
				const diceSound = document.getElementById("diceSound");
				if (diceSound) {
					diceSound.currentTime = 0;
					diceSound.play().catch(() => {});
				}

				const expr = document.getElementById("diceExpr").value.trim();
				const tnInput = document.getElementById("diceHighlight");
				const threshold = tnInput ? parseInt(tnInput.value, 10) : null;

				const result = doRoll(expr, threshold);

				if (result.err) {
					document.getElementById("diceOut").textContent = result.err;
					return;
				}

				runDiceAnimation(
					result.spec,
					result.rolls,
					threshold,
					result.successes
				);
			});

			// Hook up Saving Roll checker inputs
			["woundStr", "woundTough"].forEach((id) => {
				const el = document.getElementById(id);
				if (el) el.addEventListener("input", updateWoundHelper);
			});
			const woundToggle = document.getElementById("woundTableToggle");
			if (woundToggle) woundToggle.addEventListener("click", toggleWoundTable);
			renderWoundTable();
			updateWoundHelper();

			// ------------------------------
			// Stratagems UI (Core + Faction)
			// Expects: window.getStratagemsForContext(faction, phase, whoseTurn)
			// and (optionally) window.coreStratagems for tagging.
			// ------------------------------
			let __openStratForPlayer = null; // remember which player's list is open
			let __selectedStratKey = null;
			let __selectedStratName = null;
			let __selectedStratCost = 0;

			function stratagemTurnLabel(playerIdx) {
				return State.currentPlayer === playerIdx
					? "your turn"
					: "opponent's turn";
			}
			function humanPhaseLabel() {
				return PHASES[State.phaseIndex] || "";
			}
			function setSelectedStratagem(key, cost, name) {
				__selectedStratKey = key || null;
				__selectedStratCost = cost || 0;
				__selectedStratName = name || key || null;
				const btn = document.getElementById("stratApply");
				const hint = document.getElementById("stratApplyHint");
				if (btn) {
					btn.disabled = !__selectedStratKey;
					btn.textContent = __selectedStratKey
						? `Apply (${__selectedStratCost} CP)`
						: "Apply Stratagem";
				}
				if (hint) {
					if (!__selectedStratKey) {
						hint.textContent = "Select a stratagem to apply.";
					} else {
						const currentCp =
							__openStratForPlayer != null
								? Number(State.players[__openStratForPlayer].cp || 0)
								: 0;
						hint.textContent =
							currentCp >= __selectedStratCost
								? `Will spend ${__selectedStratCost} CP (you have ${currentCp}).`
								: `Need ${__selectedStratCost} CP but only have ${currentCp}.`;
					}
				}
			}
			function applySelectedStratagem() {
				if (__openStratForPlayer == null || !__selectedStratKey) return;
				const player = State.players[__openStratForPlayer];
				const cost = Number(__selectedStratCost || 0);
				const currentCp = Number(player.cp || 0);
				if (cost > currentCp) {
					alert("Not enough CP to use this stratagem.");
					return;
				}
				player.cp = Math.max(0, currentCp - cost);
				log(
					`${player.name || `Player ${__openStratForPlayer + 1}`} used ${
						__selectedStratName || __selectedStratKey
					} for ${cost} CP. Remaining CP: ${player.cp}.`
				);
				setSelectedStratagem(null, 0);
				saveLocal();
				render();
			}
			function renderStratListInto(container, playerIdx) {
				if (!container) return;

				const faction =
					(State.players[playerIdx].army &&
						State.players[playerIdx].army.faction) ||
					"";
				const whose =
					State.currentPlayer === playerIdx ? "current" : "opponent";
				const phase = humanPhaseLabel();

				let list = [];
				if (typeof window.getStratagemsForContext === "function") {
					try {
						list = window.getStratagemsForContext(faction, phase, whose) || [];
					} catch (e) {
						console.warn("getStratagemsForContext failed:", e);
					}
				}

				const coreSet = new Set(
					(window.coreStratagems || []).map((s) =>
						(s.key || s.name || "").toLowerCase()
					)
				);
				const groups = { faction: [], core: [] };

				for (const s of list) {
					const key = (s.key || s.name || "").toLowerCase();
					if (s.source === "core" || coreSet.has(key)) groups.core.push(s);
					else groups.faction.push(s);
				}

				const mkCard = (s) => {
					const phaseLabel =
						s.phase ||
						(Array.isArray(s.phases) ? s.phases.join(", ") : s.phases || "Any");
					const timing = s.timing ? `<div class="muted">${s.timing}</div>` : "";
					const type = s.type ? `<span class="chip">${s.type}</span>` : "";
					const turnLabel =
						s.turn === "both"
							? "Either turn"
							: s.turn === "current"
							? "Your turn"
							: s.turn === "opponent"
							? "Opponent's turn"
							: s.turn || "";
					const turn = turnLabel
						? `<span class="chip">${turnLabel}</span>`
						: "";
					const phaseChip = phaseLabel
						? `<span class="chip">Phase: ${phaseLabel}</span>`
						: "";
					const target = s.target
						? `<span class="chip">Target: ${s.target}</span>`
						: "";
					const cost = s.cost != null ? s.cost : 1;
					const desc =
						s.description ||
						s.text ||
						"No description provided for this stratagem.";
					return `
									   <div class="strat-card" data-strat-key="${(
												s.key ||
												s.name ||
												""
											).toLowerCase()}" data-strat-name="${
						s.name || s.key
					}" data-strat-cost="${cost}" aria-expanded="false">
									     <div class="strat-head" data-strat-toggle>
									       <strong>${s.name || s.key}</strong>
									       <span class="cp-badge">${cost} CP</span>
									     </div>
									     <div class="subtle-hint">Click to expand</div>
									     <div class="strat-body">
									       ${timing}
									       <div class="sub" style="margin-top:4px">${desc}</div>
									       <div class="chips">
									         ${phaseChip}
									         ${type}
									         ${turn}
									         ${target}
									       </div>
									     </div>
									   </div>
									 `;
				};

				const ctxText = `Showing stratagems for ${phase} ‚Ä¢ ${stratagemTurnLabel(
					playerIdx
				)} ‚Ä¢ ${faction || "Faction"}`;
				const ctxEl = document.getElementById("stratContext");
				if (ctxEl) ctxEl.textContent = ctxText;

				const parts = [];
				if (groups.faction.length) {
					parts.push(
						`<div class="strat-section-title">Faction Stratagems</div>`
					);
					parts.push(groups.faction.map(mkCard).join(""));
				}
				if (groups.core.length) {
					parts.push(`<div class="strat-section-title">Core Stratagems</div>`);
					parts.push(groups.core.map(mkCard).join(""));
				}
				if (!parts.length) {
					parts.push(
						'<div class="sub">No stratagems found for this context. (Core stratagems data may not be loaded.)</div>'
					);
				}
				container.innerHTML = parts.join("");

				// Make cards expandable on click of name/header
				container.querySelectorAll(".strat-card").forEach((card) => {
					const toggle = card.querySelector("[data-strat-toggle]") || card;
					const body = card.querySelector(".strat-body");
					if (!body) return;
					const handler = () => {
						const willOpen = !card.classList.contains("expanded");
						card.classList.toggle("expanded", willOpen);
						card.setAttribute("aria-expanded", willOpen ? "true" : "false");
					};
					toggle.addEventListener("click", handler);
					toggle.addEventListener("keydown", (e) => {
						if (e.key === "Enter" || e.key === " ") {
							e.preventDefault();
							handler();
						}
					});
					toggle.tabIndex = 0;
					card.classList.remove("expanded");
					card.setAttribute("aria-expanded", "false");
					// Selection
					card.addEventListener("click", () => {
						container
							.querySelectorAll(".strat-card")
							.forEach((c) => c.classList.remove("selected"));
						card.classList.add("selected");
						const k = card.getAttribute("data-strat-key") || "";
						const c = Number(card.getAttribute("data-strat-cost")) || 0;
						const n =
							card.querySelector("strong")?.textContent ||
							card.getAttribute("data-strat-name") ||
							k;
						setSelectedStratagem(k, c, n);
					});
				});
				// If current selection no longer visible, clear
				const stillVisible = __selectedStratKey
					? container.querySelector(
							`.strat-card[data-strat-key="${__selectedStratKey}"]`
					  )
					: null;
				if (!stillVisible) setSelectedStratagem(null, 0);
			}

			function openStratModalFor(playerIdx) {
				__openStratForPlayer = playerIdx;
				setSelectedStratagem(null, 0);
				const m = document.getElementById("stratModal");
				const t = document.getElementById("stratTitle");
				if (t) {
					const pname =
						State.players[playerIdx].name || `Player ${playerIdx + 1}`;
					t.textContent = `Stratagems ‚Äî ${pname}`;
				}
				const listEl = document.getElementById("stratList");
				renderStratListInto(listEl, playerIdx);
				if (m) m.classList.add("active");
			}
			function closeStratModal() {
				__openStratForPlayer = null;
				setSelectedStratagem(null, 0);
				const m = document.getElementById("stratModal");
				if (m) m.classList.remove("active");
			}
			// ------------------------------
			// Missions (10th Edition) ‚Äî placeholder until a mission source is added
			// Expects window.missions = [{key,name,pack,type,summary,primary,deployment,notes}]
			// ------------------------------
			function getAvailableMissions() {
				if (Array.isArray(window.missions) && window.missions.length)
					return window.missions;
				// Temporary placeholders (replace with real data source later)
				return [
					{
						key: "scorched-earth",
						name: "Scorched Earth",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Primary: hold objectives; burn in opponent territory.",
						deployment: "Dawn of War",
					},
					{
						key: "take-and-hold",
						name: "Take and Hold",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Primary: hold more at the end of each round.",
						deployment: "Hammer and Anvil",
					},
					{
						key: "supply-drop",
						name: "Supply Drop",
						pack: "Leviathan",
						type: "Eternal War",
						summary: "Late-game shifting objectives with endgame scoring.",
						deployment: "Search and Destroy",
					},
				];
			}
			function pickRandomMission() {
				const list = getAvailableMissions();
				if (!list.length) return null;
				return list[Math.floor(Math.random() * list.length)];
			}
			function missionDisplayName(m) {
				return m ? m.name || m.key || "Mission" : "None";
			}
			function renderMissionSelected() {
				const el = document.getElementById("missionSelected");
				if (!el) return;
				if (!State.mission) {
					el.textContent = "None selected.";
					return;
				}
				const m = State.mission;
				el.innerHTML = `<strong>${missionDisplayName(
					m
				)}</strong><br><span class="sub">${m.pack || ""}${
					m.type ? " ‚Ä¢ " + m.type : ""
				}</span>`;
			}
			function renderMissionCardsInto(container) {
				const list = getAvailableMissions();
				container.innerHTML = "";
				list.forEach((m) => {
					const card = document.createElement("div");
					card.className =
						"mission-card" +
						(State.mission && State.mission.key === m.key ? " selected" : "");
					card.innerHTML = `
									   <div><strong>${m.name || m.key}</strong></div>
									   <div class="mission-meta">
									     ${m.pack ? `<span class="chip">${m.pack}</span>` : ""}
									     ${m.type ? `<span class="chip">${m.type}</span>` : ""}
									     ${m.deployment ? `<span class="chip">${m.deployment}</span>` : ""}
									   </div>
									   <div class="sub" style="margin-top:6px">${m.summary || ""}</div>
									 `;
					card.addEventListener("click", () => {
						State.mission = m;
						log(`Mission selected: ${missionDisplayName(m)}`);
						saveLocal();
						renderMissionSelected();
						updateStartBattleButton();
						renderMissionCardsInto(container); // refresh highlight
					});
					container.appendChild(card);
				});
			}
			function openMissionModal() {
				const m = document.getElementById("missionModal");
				if (!m) return;
				const body = document.getElementById("missionBody");
				const title = document.getElementById("missionTitle");
				const mis = State.mission;
				if (!mis) {
					title.textContent = "Mission";
					body.innerHTML =
						'<div class="sub">No mission selected. Open <em>Setup</em> ‚Üí Mission Setup to draw or choose one.</div>';
				} else {
					title.textContent = mis.name || mis.key || "Mission";
					body.innerHTML = `
									   <div class="panel">
									     <div class="card-title">
									       <strong>${mis.name || mis.key}</strong>
									       ${mis.pack ? `<span class="badge">${mis.pack}</span>` : ""}
									     </div>
									     <div class="sub">
									       ${mis.type ? `<strong>Type:</strong> ${mis.type}<br>` : ""}
									       ${
														mis.deployment
															? `<strong>Deployment:</strong> ${mis.deployment}<br>`
															: ""
													}
									       ${mis.summary ? `<strong>Summary:</strong> ${mis.summary}` : ""}
									     </div>
									   </div>
									 `;
				}
				m.classList.add("active");
			}
			// ------------------------------
			// Faction helpers
			// ------------------------------
			function getFactionImage(factionText) {
				const key = canonicaliseFactionName(factionText || "");
				// Map using canonical keys (lowercase, hyphenated) + common raw labels as fallbacks
				const map = {
					// Astra Militarum / Imperial Guard
					"imperial-guard": "Imperial-Guard.jpg",
					"astra-militarum": "Imperial-Guard.jpg",
					"astra militarum": "Imperial-Guard.jpg",

					// Chaos Space Marines
					"chaos-marines": "chaos-marine.jpg",
					"chaos space marines": "chaos-marine.jpg",
					chaos: "chaos-marine.jpg",

					// Adepta Sororitas
					sisters: "sisters-of-battle.jpg",
					"adepta-sororitas": "sisters-of-battle.jpg",
					"adepta sororitas": "sisters-of-battle.jpg",

					// Space Marines
					"space-marines": "space-marines.jpg",
					"space marines": "space-marines.jpg",

					// Tyranids
					tyranids: "tyranids.jpeg",

					// Orks
					orks: "orks.jpg",

					// Eldar
					eldar: "Eldar.jpeg",
					Aeldari: "Eldar.jpeg",

					// Necron
					necron: "necron.jpg",
					necrons: "necron.jpg",
				};

				// Try canonical key first, then a lowercase raw fallback
				const rawLower = (factionText || "").toLowerCase().trim();
				return map[key] || map[rawLower] || null;
			}
			function getFactionLabel(factionText) {
				// Prefer the text from the import if present; otherwise map common keys to display names
				if (factionText && factionText.trim()) return factionText.trim();
				return "";
			}
			// ------------------------------
			// Rendering
			// ------------------------------
			function render() {
				const expandedUnitIds = captureExpandedUnitIds();
				document.getElementById("p1Name").value = State.players[0].name;
				document.getElementById("p2Name").value = State.players[1].name;
				document.getElementById("p1CP").value = State.players[0].cp;
				document.getElementById("p2CP").value = State.players[1].cp;
				document.getElementById("p1VP").value = State.players[0].vp;
				document.getElementById("p2VP").value = State.players[1].vp;

				document.getElementById(
					"roundBadge"
				).textContent = `Round ${State.round}`;
				document.getElementById("turnPlayerBadge").textContent =
					State.players[State.currentPlayer].name;

				// Phases
				const pills = document.getElementById("phasePills");
				pills.innerHTML = "";
				PHASES.forEach((p, idx) => {
					const span = document.createElement("span");
					span.className = "pill" + (idx === State.phaseIndex ? " active" : "");
					span.textContent = p;
					span.style.cursor = "help";
					span.title = "Click for phase help";
					span.addEventListener("click", () => {
						const html = PHASE_HELP[p] || "<p>No help available.</p>";
						openPhaseModal(p, html);
					});
					pills.appendChild(span);
				});

				// Headers
				document.getElementById(
					"p1Header"
				).textContent = `${State.players[0].name}`;
				document.getElementById(
					"p2Header"
				).textContent = `${State.players[1].name}`;

				// Faction meta (name + image)
				[0, 1].forEach((idx) => {
					const factionText =
						(State.players[idx].army && State.players[idx].army.faction) || "";
					const label = getFactionLabel(factionText);
					const imgFile = getFactionImage(factionText);
					const nameEl = document.getElementById(
						idx === 0 ? "p1Faction" : "p2Faction"
					);
					const imgEl = document.getElementById(
						idx === 0 ? "p1FactionImg" : "p2FactionImg"
					);
					if (nameEl) nameEl.textContent = label;
					if (imgEl) {
						if (imgFile) {
							imgEl.src = imgFile;
							imgEl.classList.remove("hidden");
							imgEl.alt = label || "Faction";
						} else {
							imgEl.removeAttribute("src");
							imgEl.classList.add("hidden");
						}
					}
					const cmdBtn = document.getElementById(
						idx === 0 ? "p1Commands" : "p2Commands"
					);
					if (cmdBtn) {
						const hasOrders =
							getCommandOrdersForFaction(factionText).length > 0;
						const allowed =
							State.phaseIndex === 0 &&
							State.currentPlayer === idx &&
							hasOrders;
						cmdBtn.disabled = !allowed;
						cmdBtn.classList.toggle("ghost", !allowed);
						cmdBtn.title = hasOrders
							? allowed
								? "Open command/orders for this player."
								: "Commands available during this player's Command phase."
							: "No commands found for this faction.";
					}
				});

				// Units
				const mount = (playerIdx, rootId) => {
					const root = document.getElementById(rootId);
					const col1 = document.getElementById(rootId + "Col1");
					const col2 = document.getElementById(rootId + "Col2");
					if (!root || !col1 || !col2) return;

					// Clear both columns and alternate cards into them
					col1.innerHTML = "";
					col2.innerHTML = "";
					let colNext = 1;

					for (const unit of State.players[playerIdx].units) {
						const tpl = document.getElementById("unitTemplate");
						const node = tpl.content.cloneNode(true);
						const wrap = node.querySelector("[data-unit-id]");
						wrap.dataset.unitId = unit.id;

						// No data-col or grid-row spanning ‚Äî columns are real, independent containers now

						const isMovementPhase = PHASES[State.phaseIndex] === "Movement";
						const moveVal =
							(unit.stats && unit.stats.M != null ? unit.stats.M : null) ||
							unit.movement ||
							null;
						const displayName =
							isMovementPhase && moveVal != null
								? `${unit.name} ‚Äî M ${moveVal}`
								: unit.name;
						wrap.querySelector(".unit-name").textContent = displayName;
						const nameEl = wrap.querySelector(".unit-name");
						const detailsEl = wrap.querySelector("[data-details]");
						if (nameEl && detailsEl) {
							nameEl.setAttribute("role", "button");
							nameEl.setAttribute("tabindex", "0");
							nameEl.setAttribute("aria-expanded", "false");

							const doToggle = () => {
								const willOpen = !detailsEl.classList.contains("active");
								smoothToggle(detailsEl);
								nameEl.setAttribute(
									"aria-expanded",
									willOpen ? "true" : "false"
								);
							};

							nameEl.addEventListener("click", doToggle);
							nameEl.addEventListener("keydown", (ev) => {
								if (ev.key === "Enter" || ev.key === " ") {
									ev.preventDefault();
									doToggle();
								}
							});
						}

						const kw =
							unit.keywords && unit.keywords.length
								? unit.keywords.join(" ‚Ä¢ ")
								: "";
						wrap.querySelector(".keywords").textContent = kw;
						wrap.querySelector("[data-models]").textContent =
							unit.models && unit.woundsPerModel
								? `${unit.models} model(s) ‚Ä¢ ${unit.woundsPerModel}W each`
								: "";

						const pct =
							unit.totalWounds === 0
								? 0
								: Math.max(
										0,
										Math.min(
											100,
											Math.round(
												(100 * unit.remainingWounds) / unit.totalWounds
											)
										)
								  );
						wrap.querySelector(".bar > span").style.width = pct + "%";
						wrap.querySelector(
							"[data-wounds]"
						).textContent = `${unit.remainingWounds}/${unit.totalWounds}`;

						wrap.querySelectorAll("[data-dmg]").forEach((btn) => {
							btn.addEventListener("click", () => {
								const d = Number(btn.getAttribute("data-dmg"));
								applyDamage(unit, d);
								saveLocal();
								render();
							});
						});

						wrap
							.querySelector("[data-remove]")
							.addEventListener("click", () => {
								if (confirm(`Remove ${unit.name}?`)) {
									const arr = State.players[playerIdx].units;
									const idx = arr.findIndex((x) => x.id === unit.id);
									if (idx > -1) {
										arr.splice(idx, 1);
										saveLocal();
										render();
									}
								}
							});

						const efRoot = wrap.querySelector("[data-effects]");
						efRoot.innerHTML = "";
						(unit.effects || []).forEach((ef) => {
							const chip = document.createElement("span");
							chip.className = "effect-chip";
							const label = effectLabel(ef);
							const exp =
								ef.expiry === "persistent"
									? "‚àû"
									: ef.expiry === "phase"
									? "end of phase"
									: ef.expiry === "turn"
									? "end of turn"
									: ef.expiry === "opponentTurn"
									? "end of opponent's turn"
									: `+${ef.rounds || 1} round(s)`;
							chip.innerHTML = `${label} <small>(${exp})</small> <button title="Remove">‚úï</button>`;
							chip.querySelector("button").addEventListener("click", () => {
								unit.effects = (unit.effects || []).filter(
									(x) => x.id !== ef.id
								);
								log(`${unit.name}: Removed effect ‚Äî ${label}`);
								saveLocal();
								render();
							});
							efRoot.appendChild(chip);
						});

						// Weapons UI hookup
						const listEl = wrap.querySelector("[data-weapons]");
						const panelEl = wrap.querySelector("[data-weapon-panel]");
						renderWeaponsForUnit(unit, listEl, panelEl);

						// Append the card into the current column, alternating 1,2,1,2‚Ä¶
						const targetCol = colNext === 1 ? col1 : col2;
						colNext = colNext === 1 ? 2 : 1;
						targetCol.appendChild(node);

						// Add effect
						wrap
							.querySelector("[data-add-effect]")
							.addEventListener("click", () => {
								promptAddEffect(unit);
							});
						const statRoot = wrap.querySelector("[data-statline]");
						if (statRoot) {
							statRoot.innerHTML = "";
							const s = unit.stats;
							if (s) {
								const mk = (label, val) => {
									const sp = document.createElement("span");
									sp.className = "tag";
									sp.textContent = `${label}: ${val ?? "-"}`;
									return sp;
								};
								statRoot.appendChild(mk("M", s.M));
								statRoot.appendChild(mk("T", s.T));
								statRoot.appendChild(mk("Sv", s.Sv != null ? s.Sv + "+" : "-"));
								statRoot.appendChild(mk("W", s.W));
								statRoot.appendChild(mk("Ld", s.Ld != null ? s.Ld + "+" : "-"));
								statRoot.appendChild(mk("OC", s.OC));
							} else {
								statRoot.innerHTML =
									'<span class="sub">No stats found in loaded data for this unit.</span>';
							}
						}
						const compRoot = wrap.querySelector("[data-composition]");
						if (compRoot)
							compRoot.innerHTML = renderCompositionHTML(unit.composition);
						// Weapons list + details panel
						const wListEl = wrap.querySelector("[data-weapons]");
						const wPanelEl = wrap.querySelector("[data-weapon-panel]");
						renderWeaponsForUnit(unit, wListEl, wPanelEl);
						root.appendChild(node);
					}
				};
				// Update selected mission preview in Setup
				renderMissionSelected();
				mount(0, "p1Units");
				mount(1, "p2Units");
				restoreExpandedUnitIds(expandedUnitIds);
				updateStartBattleButton();
				relayoutAllGrids();
			}

			function promptAddEffect(unit) {
				const name = prompt(
					"Effect name (e.g., Transhuman, Cover, Battle-shock):"
				);
				if (!name) return;
				const opts = prompt(
					"Expiry: phase | turn | opponentTurn | rounds | persistent",
					"turn"
				);
				if (!opts) return;
				let expiry = opts.trim();
				let rounds = 1;
				if (expiry === "rounds") {
					const r = Number(prompt("How many rounds?", "1"));
					if (Number.isFinite(r) && r > 0) rounds = r;
					else rounds = 1;
				}
				const ef = {
					id: makeId(),
					name: name.trim(),
					expiry,
					rounds,
					createdAt: {
						round: State.round,
						player: State.currentPlayer,
						phaseIndex: State.phaseIndex,
						iso: nowISO(),
					},
				};
				if (!unit.effects) unit.effects = [];
				unit.effects.push(ef);
				log(
					`${unit.name}: Added effect ‚Äî ${effectLabel(ef)} (${
						expiry === "persistent" ? "‚àû" : expiry
					})`
				);
				saveLocal();
				render();
			}

			// ------------------------------
			// Bootstrap / Events
			// ------------------------------
			function bind() {
				// Names
				document.getElementById("p1Name").addEventListener("input", (e) => {
					State.players[0].name = e.target.value;
					render();
					updateStartBattleButton();
					saveLocal();
				});
				document.getElementById("p2Name").addEventListener("input", (e) => {
					State.players[1].name = e.target.value;
					render();
					saveLocal();
				});

				// CP / VP buttons
				document.querySelectorAll("[data-cp]").forEach((btn) => {
					btn.addEventListener("click", () => {
						const who = btn.getAttribute("data-cp") === "p1" ? 0 : 1;
						const delta = Number(btn.getAttribute("data-delta"));
						State.players[who].cp = Math.max(
							0,
							Number(State.players[who].cp) + delta
						);
						saveLocal();
						render();
					});
				});
				document.querySelectorAll("[data-vp]").forEach((btn) => {
					btn.addEventListener("click", () => {
						const who = btn.getAttribute("data-vp") === "p1" ? 0 : 1;
						const delta = Number(btn.getAttribute("data-delta"));
						State.players[who].vp = Math.max(
							0,
							Number(State.players[who].vp) + delta
						);
						saveLocal();
						render();
					});
				});
				document.getElementById("p1CP").addEventListener("input", (e) => {
					State.players[0].cp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p2CP").addEventListener("input", (e) => {
					State.players[1].cp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p1VP").addEventListener("input", (e) => {
					State.players[0].vp = Number(e.target.value || 0);
					saveLocal();
				});
				document.getElementById("p2VP").addEventListener("input", (e) => {
					State.players[1].vp = Number(e.target.value || 0);
					saveLocal();
				});

				// Phase controls
				document
					.getElementById("btnNextPhase")
					.addEventListener("click", nextPhase);
				document
					.getElementById("btnPrevPhase")
					.addEventListener("click", prevPhase);
				document.getElementById("autoCP").addEventListener("change", (e) => {
					State.autoGainCP = !!e.target.checked;
					saveLocal();
				});

				// Command phase orders modal
				const commandClose = document.getElementById("commandClose");
				if (commandClose)
					commandClose.addEventListener("click", closeCommandPhaseModal);
				const commandSkip = document.getElementById("commandSkip");
				if (commandSkip)
					commandSkip.addEventListener("click", closeCommandPhaseModal);
				const commandApply = document.getElementById("commandApply");
				if (commandApply)
					commandApply.addEventListener("click", applySelectedCommandOrder);
				const commandModal = document.getElementById("commandModal");
				if (commandModal) {
					commandModal.addEventListener("click", (e) => {
						if (e.target === commandModal) closeCommandPhaseModal();
					});
				}
				window.addEventListener("resize", () => {
					if (
						document
							.getElementById("commandModal")
							?.classList.contains("active") &&
						commandModalState.playerIdx != null
					) {
						anchorCommandModal(commandModalState.playerIdx);
					}
				});

				// Save / Load
				document.getElementById("btnSave").addEventListener("click", () => {
					const blob = new Blob([JSON.stringify(State, null, 2)], {
						type: "application/json",
					});
					const a = document.createElement("a");
					a.href = URL.createObjectURL(blob);
					const d = new Date();
					a.download = `40k_tracker_round${State.round}_${d
						.toISOString()
						.slice(0, 10)}.json`;
					document.body.appendChild(a);
					a.click();
					a.remove();
				});
				document.getElementById("btnLoad").addEventListener("click", () => {
					document.getElementById("loadState").click();
				});
				document
					.getElementById("loadState")
					.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (!f) return;
						const text = await f.text();
						try {
							const data = JSON.parse(text);
							Object.assign(State, data);
							log("Loaded saved game state.");
							render();
							saveLocal();
						} catch (err) {
							alert("Bad state file.");
						}
					});

				// Setup modal toggles
				const btnSetup = document.getElementById("btnSetup");
				if (btnSetup) btnSetup.addEventListener("click", openSetupModal);
				const setupClose = document.getElementById("setupClose");
				if (setupClose) setupClose.addEventListener("click", closeSetupModal);
				// Close when clicking backdrop (outside dialog)
				const setupModal = document.getElementById("setupModal");
				if (setupModal) {
					setupModal.addEventListener("click", (e) => {
						if (e.target === setupModal) closeSetupModal();
					});
				}

				// ============================================================
				// PoolHouseAI ‚Äî 40K Voice Assistant (Imperial Terminal)
				// ============================================================
				(function () {
					const OPENAI_API_KEY = "";

					const AI_SYSTEM_PROMPT = `
			You are PoolHouseAI, a Warhammer 40,000 10th edition assistant.
			You are a servo-skull attached to an Imperial officer.
			Reply in short, clear sentences.
			Answer rules and tactics questions accurately for 10th edition.
			Use a clipped, formal tone: ‚Äúaffirmative‚Äù, ‚Äúprocessing‚Äù, ‚Äúcogitator online‚Äù, "Praise be to God Emporer Chris".
			Always prioritise the provided 10th-ed data (stats/weapons) over any prior knowledge.
				`;

					// --- Lightweight RAG using local wh40k_10th.json ---
					let ragData = [];
					let ragLoaded = false;
					async function loadRagData() {
						if (ragLoaded) return;
						try {
							const res = await fetch("data/wh40k_10th.json");
							ragData = (await res.json()) || [];
						} catch (e) {
							console.warn("RAG load failed", e);
						} finally {
							ragLoaded = true;
						}
					}
					loadRagData();

					function normalize(str) {
						return String(str || "")
							.toLowerCase()
							.replace(/[^a-z0-9]+/g, " ")
							.trim();
					}

					function getRagRows() {
						// Use only the loaded JSON to avoid stale/legacy data
						return ragData || [];
					}

					function buildRagContext(query) {
						const rows = getRagRows();
						if (!rows.length) return "";
						const q = normalize(query);
						if (!q) return "";

						const tokens = q.split(" ").filter(Boolean);

						const scored = rows
							.map((row) => {
								const nameKey = normalize(row.unitname);
								const comboKey = normalize(
									(row.unitname || "") + " " + (row.factionname || "")
								);
								let score = 0;
								if (nameKey === q || comboKey === q) score = 100;
								else if (nameKey.includes(q) || comboKey.includes(q))
									score = 80;
								else {
									const hits = tokens.filter(
										(t) => t && (nameKey.includes(t) || comboKey.includes(t))
									).length;
									if (hits) score = 40 + hits * 10;
								}
								return { row, score };
							})
							.filter((r) => r.score > 0)
							.sort((a, b) => b.score - a.score)
							.slice(0, 4)
							.map((r) => r.row);

						if (!scored.length) return "";

						const lines = scored.map((row) => {
							const s = (row.stats && row.stats[0]) || {};
							const statLine = `M ${s.m || "-"} T ${s.t || "-"} Sv ${
								s.sv || "-"
							} W ${s.w || "-"} Ld ${s.ld || "-"} OC ${s.oc || "-"}`;
							const weaps = (row.weapons || [])
								.slice(0, 4)
								.map(
									(w) =>
										`${w.name}: ${w.range || "Melee"} | A ${
											w.attacks || "-"
										} | SKL ${w.skill || "-"} | S ${w.strength || "-"} | AP ${
											w.ap || "-"
										} | D ${w.damage || "-"}`
								)
								.join(" ; ");
							return `Unit: ${row.unitname} (${row.factionname}) ‚Äî ${statLine}${
								weaps ? " | Weapons: " + weaps : ""
							}`;
						});
						return `Prefer these 10th-ed profiles over memory:\n${lines.join(
							"\n"
						)}`;
					}

					// --- DOM hooks ---
					const aiModal = document.getElementById("aiModal");
					const aiClose = document.getElementById("aiClose");
					const btnAI = document.getElementById("btnAI");
					const aiMessages = document.getElementById("aiMessages");
					const aiStatus = document.getElementById("aiStatus");
					const aiTalkButton = document.getElementById("aiTalkButton");
					const aiTalkLabel = document.getElementById("aiTalkLabel");
					const aiTalkDot = document.getElementById("aiTalkDot");
					const aiAudio = document.getElementById("aiTtsAudio");

					if (!aiModal || !btnAI || !aiMessages || !aiTalkButton || !aiAudio)
						return;

					// --- Helpers ---
					function setAiStatus(text) {
						if (aiStatus) aiStatus.textContent = text;
					}

					function appendAiMessage(text, who) {
						const div = document.createElement("div");
						div.className = "item";

						if (who === "ai") {
							div.classList.add("ai");
							div.setAttribute("data-msg", text); // typing animation target
							div.textContent = ""; // will be animated by CSS
						} else {
							div.textContent = "You: " + text;
						}

						aiMessages.appendChild(div);
						aiMessages.scrollTop = aiMessages.scrollHeight;
					}

					function openAiModal() {
						aiModal.classList.add("active");
						setAiStatus("Idle");
					}

					function closeAiModal() {
						aiModal.classList.remove("active");
					}

					btnAI.addEventListener("click", () => {
						unlockAiAudio();
						openAiModal();
					});

					aiClose.addEventListener("click", closeAiModal);
					aiModal.addEventListener("click", (e) => {
						if (e.target === aiModal) closeAiModal();
					});

					// --- Audio unlock for iOS/Safari ---
					let aiAudioUnlocked = false;
					function unlockAiAudio() {
						if (aiAudioUnlocked || !aiAudio) return;

						try {
							aiAudio.src =
								"data:audio/mp4;base64,AAAAGGZ0eXBtcDQyAAAAAG1wNDFtcDQyaXNvbWF2YzEAAAAIZnJlZQAAAAE=";

							aiAudio
								.play()
								.then(() => {
									aiAudio.pause();
									aiAudio.currentTime = 0;
									aiAudioUnlocked = true;
								})
								.catch(() => {});
						} catch (e) {}
					}

					// Web Audio for gritty servo-skull effect
					let aiAudioCtx = null;
					function getAiAudioCtx() {
						if (!aiAudioCtx)
							aiAudioCtx = new (window.AudioContext ||
								window.webkitAudioContext)();
						return aiAudioCtx;
					}
					function makeDistortionCurve(amount = 80) {
						const k = typeof amount === "number" ? amount : 50;
						const n = 44100;
						const curve = new Float32Array(n);
						const deg = Math.PI / 180;
						for (let i = 0; i < n; i++) {
							const x = (i * 2) / n - 1;
							curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
						}
						return curve;
					}

					// --- TTS ---
					async function aiSpeak(text) {
						if (!text || !aiAudio) return Promise.resolve();

						setAiStatus("Speaking‚Ä¶");

						return new Promise(async (resolve) => {
							try {
								aiAudio.pause();
								aiAudio.currentTime = 0;

								const response = await fetch(
									"https://api.openai.com/v1/audio/speech",
									{
										method: "POST",
										headers: {
											"Content-Type": "application/json",
											Authorization: "Bearer " + OPENAI_API_KEY,
										},
										body: JSON.stringify({
											model: "gpt-4o-mini-tts",
											voice: "alloy",
											format: "aac",
											input: text,
										}),
									}
								);

								if (!response.ok) {
									console.error(
										"TTS Error:",
										response.status,
										await response.text()
									);
									setAiStatus("Idle");
									return resolve();
								}

								const buf = await response.arrayBuffer();
								const ctx = getAiAudioCtx();
								try {
									await ctx.resume();
									const audioBuffer = await ctx.decodeAudioData(buf.slice(0));
									const source = ctx.createBufferSource();
									source.buffer = audioBuffer;
									source.playbackRate.value = 0.94; // slight drag for servo skull vibe

									const filter = ctx.createBiquadFilter();
									filter.type = "bandpass";
									filter.frequency.value = 1200;
									filter.Q.value = 1.2;

									const shaper = ctx.createWaveShaper();
									shaper.curve = makeDistortionCurve(120);
									shaper.oversample = "4x";

									const gain = ctx.createGain();
									gain.gain.value = 0.9;

									source.connect(shaper);
									shaper.connect(filter);
									filter.connect(gain);
									gain.connect(ctx.destination);

									source.onended = () => {
										setAiStatus("Idle");
										resolve();
									};
									source.start(0);
								} catch (e) {
									// Fallback to audio element if WebAudio fails
									const blob = new Blob([buf], { type: "audio/aac" });
									const url = URL.createObjectURL(blob);
									aiAudio.onended = () => {
										URL.revokeObjectURL(url);
										setAiStatus("Idle");
										resolve();
									};

									aiAudio.src = url;
									await aiAudio
										.play()
										.catch((err) => console.error("Play error:", err));
								}
							} catch (err) {
								console.error("TTS error:", err);
								setAiStatus("Idle");
								resolve();
							}
						});
					}

					// --- Chat ---
					async function aiAskGPT(text) {
						// Ensure local data is loaded before building context
						await loadRagData();
						const ragContext = buildRagContext(text);
						const userContent = ragContext
							? `${ragContext}\n\nQuestion: ${text}`
							: text;
						try {
							const res = await fetch("https://api.openai.com/v1/responses", {
								method: "POST",
								headers: {
									"Content-Type": "application/json",
									Authorization: "Bearer " + OPENAI_API_KEY,
								},
								body: JSON.stringify({
									model: "gpt-4o-mini",
									input: [
										{ role: "system", content: AI_SYSTEM_PROMPT },
										{ role: "user", content: userContent },
									],
								}),
							});
							const json = await res.json();
							return json.output?.[0]?.content?.[0]?.text || "(No reply)";
						} catch (e) {
							console.error("aiAskGPT error:", e);
							return "(Network error)";
						}
					}

					// ============================================================
					// PUSH-TO-TALK + WHISPER
					// ============================================================

					// Typewriter effect so replies "print" down the terminal instead of as one block
					async function typeOutAiMessage(text) {
						return new Promise((resolve) => {
							const msg = document.createElement("div");
							msg.className = "item ai";
							msg.textContent = "";
							msg.style.whiteSpace = "pre-wrap";

							aiMessages.appendChild(msg);
							aiMessages.scrollTop = aiMessages.scrollHeight;

							const content = (text || "").replace(/\r\n/g, "\n");
							const total = content.length;
							let i = 0;

							const step = () => {
								if (i >= total) {
									resolve();
									return;
								}

								msg.textContent += content[i];
								aiMessages.scrollTop = aiMessages.scrollHeight;

								i += 1;
								const delay = content[i - 1] === "\n" ? 100 : 16;
								setTimeout(step, delay);
							};

							step();
						});
					}

					async function sendAiRequest(transcript) {
						setAiStatus("Thinking‚Ä¶");

						const reply = await aiAskGPT(transcript);

						// Start audio immediately, type concurrently for synced feel
						const speakPromise = aiSpeak(reply);

						// --- Display AI message with our typewriter effect ---
						await typeOutAiMessage(reply);

						await speakPromise.catch(() => {});

						setAiStatus("Idle");
					}
					// --- Whisper persistent values ---
					let aiRecording = false;
					let mediaRecorder = null;
					let audioChunks = [];

					function setTalkButtonIdle() {
						aiTalkLabel.textContent = "üé§ Start Listening";
						aiTalkButton.classList.remove("primary");
						aiTalkDot.style.background = "#ff5555";
					}

					function setTalkButtonListening() {
						aiTalkLabel.textContent = "üéôÔ∏è Stop Listening";
						aiTalkButton.classList.add("primary");
						aiTalkDot.style.background = "#55ff55";
					}

					if (aiTalkButton) {
						aiTalkButton.addEventListener("click", () => {
							unlockAiAudio();

							if (!aiRecording) {
								aiRecording = true;
								setTalkButtonListening();
								startWhisperRecording();
							} else {
								aiRecording = false;
								setTalkButtonIdle();
								stopWhisperRecording();
							}
						});
					}

					function startWhisperRecording() {
						audioChunks = [];

						navigator.mediaDevices
							.getUserMedia({ audio: true })
							.then((stream) => {
								mediaRecorder = new MediaRecorder(stream, {
									mimeType: "audio/webm",
								});

								mediaRecorder.ondataavailable = (e) => {
									if (e.data.size > 0) audioChunks.push(e.data);
								};

								mediaRecorder.start();
								setAiStatus("Listening‚Ä¶");
							})
							.catch((err) => {
								console.error("Mic error:", err);
								alert("Microphone access failed.");
							});
					}

					async function stopWhisperRecording() {
						if (!mediaRecorder) return;

						mediaRecorder.onstop = async () => {
							const blob = new Blob(audioChunks, { type: "audio/webm" });
							const file = new File([blob], "speech.webm", {
								type: "audio/webm",
							});

							const transcript = await sendToWhisper(file);
							if (!transcript) return;

							appendAiMessage(transcript, "user");
							await sendAiRequest(transcript);
						};

						mediaRecorder.stop();
						setAiStatus("Processing‚Ä¶");
					}

					async function sendToWhisper(file) {
						try {
							const form = new FormData();
							form.append("file", file);
							form.append("model", "gpt-4o-mini-transcribe");
							form.append("response_format", "text");
							form.append(
								"prompt",
								"This is Warhammer 40,000 10th edition. Use correct terms such as lascannon, melta, bolter, Exocrine, Stratagems, Overwatch, Ogryn, Kasrkin, Tyranid, synapse."
							);

							const resp = await fetch(
								"https://api.openai.com/v1/audio/transcriptions",
								{
									method: "POST",
									headers: { Authorization: `Bearer ${OPENAI_API_KEY}` },
									body: form,
								}
							);

							const text = await resp.text();
							return text.trim();
						} catch (err) {
							console.error("Whisper STT error:", err);
							return null;
						}
					}

					setTalkButtonIdle();
				})();
				// Mission setup controls
				const btnMissionChoose = document.getElementById("btnMissionChoose");
				const missionChooser = document.getElementById("missionChooser");
				const missionGrid = document.getElementById("missionGrid");
				const btnMissionChooserClose = document.getElementById(
					"btnMissionChooserClose"
				);

				/* ============================================================
			   BINARY RAIN BACKGROUND
			   ============================================================ */
				(function initBinaryRain() {
					const canvas = document.getElementById("binaryRain");
					if (!canvas) return;

					const ctx = canvas.getContext("2d");
					let w = (canvas.width = canvas.offsetWidth);
					let h = (canvas.height = canvas.offsetHeight);

					const chars = "01‚ñí‚ñì‚ñë‚óº‚óª‚óé‚óè‚óâ".split("");
					const fontSize = 14;
					const cols = Math.floor(w / fontSize);
					const drops = Array(cols).fill(0);

					function draw() {
						ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
						ctx.fillRect(0, 0, w, h);

						ctx.fillStyle = "rgba(0,255,255,0.4)";
						ctx.font = fontSize + "px monospace";

						drops.forEach((y, i) => {
							const text = chars[Math.floor(Math.random() * chars.length)];
							ctx.fillText(text, i * fontSize, y * fontSize);

							if (y * fontSize > h && Math.random() > 0.975) {
								drops[i] = 0;
							}
							drops[i]++;
						});
					}

					setInterval(draw, 50);

					// Resize if modal changes size
					new ResizeObserver(() => {
						w = canvas.width = canvas.offsetWidth;
						h = canvas.height = canvas.offsetHeight;
					}).observe(canvas);
				})();

				const btnMissionRandom = document.getElementById("btnMissionRandom");
				const modeRandom = document.getElementById("missionModeRandom");
				const modeChoose = document.getElementById("missionModeChoose");

				if (btnMissionRandom) {
					btnMissionRandom.addEventListener("click", () => {
						if (modeRandom) modeRandom.checked = true;
						const m = pickRandomMission();
						if (m) {
							State.mission = m;
							renderMissionSelected();
							updateStartBattleButton();
							saveLocal();
							log(`Random mission drawn: ${missionDisplayName(m)}`);
							if (missionChooser) missionChooser.classList.add("hidden");
						} else {
							alert("No missions available yet. Add them to window.missions.");
						}
					});
				}

				if (btnMissionChoose) {
					btnMissionChoose.addEventListener("click", () => {
						if (modeChoose) modeChoose.checked = true;
						if (missionChooser) missionChooser.classList.remove("hidden");
						if (missionGrid) renderMissionCardsInto(missionGrid);
					});
				}

				if (btnMissionChooserClose) {
					btnMissionChooserClose.addEventListener("click", () => {
						if (missionChooser) missionChooser.classList.add("hidden");
					});
				}
				// Stratagems buttons (null-safe)
				const p1StratsBtn = document.getElementById("p1Strats");
				const p2StratsBtn = document.getElementById("p2Strats");
				if (p1StratsBtn)
					p1StratsBtn.addEventListener("click", () => openStratModalFor(0));
				if (p2StratsBtn)
					p2StratsBtn.addEventListener("click", () => openStratModalFor(1));
				const stratApply = document.getElementById("stratApply");
				if (stratApply)
					stratApply.addEventListener("click", applySelectedStratagem);
				// Commands buttons (null-safe)
				const p1CmdBtn = document.getElementById("p1Commands");
				const p2CmdBtn = document.getElementById("p2Commands");
				if (p1CmdBtn)
					p1CmdBtn.addEventListener("click", () => openCommandsForPlayer(0));
				if (p2CmdBtn)
					p2CmdBtn.addEventListener("click", () => openCommandsForPlayer(1));

				// Stratagems modal close & backdrop (null-safe)
				const stratModal = document.getElementById("stratModal");
				const stratClose = document.getElementById("stratClose");
				if (stratClose) stratClose.addEventListener("click", closeStratModal);
				if (stratModal) {
					stratModal.addEventListener("click", (e) => {
						if (e.target === stratModal) closeStratModal();
					});
				}

				// Mission buttons (view; shared mission) ‚Äî null-safe
				const p1MissionBtn = document.getElementById("p1Mission");
				const p2MissionBtn = document.getElementById("p2Mission");
				if (p1MissionBtn)
					p1MissionBtn.addEventListener("click", openMissionModal);
				if (p2MissionBtn)
					p2MissionBtn.addEventListener("click", openMissionModal);

				// Mission modal close & backdrop ‚Äî null-safe
				const missionModal = document.getElementById("missionModal");
				const missionClose = document.getElementById("missionClose");
				if (missionClose) {
					missionClose.addEventListener("click", () => {
						if (missionModal) missionModal.classList.remove("active");
					});
				}
				if (missionModal) {
					missionModal.addEventListener("click", (e) => {
						if (e.target === missionModal)
							missionModal.classList.remove("active");
					});
				}

				// Start Game modal toggles
				const startModal = document.getElementById("startModal");
				const btnStartBattle = document.getElementById("btnStartBattle");
				// Keep the header close button hidden/disabled
				const startClose = document.getElementById("startClose");
				if (startClose) {
					startClose.style.display = "none";
					startClose.onclick = null;
				}
				if (btnStartBattle) {
					btnStartBattle.addEventListener("click", () => {
						if (!isStartReady()) return; // double-guard
						closeStartModal();
					});
				}
				if (startModal) {
					// Only allow backdrop-click close if setup is complete
					startModal.addEventListener("click", (e) => {
						if (e.target === startModal && isStartReady()) {
							closeStartModal();
						}
					});
				} // Phase Help modal toggles
				const phaseHelpClose = document.getElementById("phaseHelpClose");
				if (phaseHelpClose)
					phaseHelpClose.addEventListener("click", closePhaseModal);
				const phaseModal = document.getElementById("phaseModal");
				if (phaseModal) {
					phaseModal.addEventListener("click", (e) => {
						if (e.target === phaseModal) closePhaseModal();
					});
				}
				// Dice modal toggles
				const btnDice = document.getElementById("btnDice");
				if (btnDice)
					btnDice.addEventListener("click", () => {
						const m = document.getElementById("diceModal");
						if (m) m.classList.add("active");
						// Focus the dice expression input when opening the modal
						const diceExpr = document.getElementById("diceExpr");
						if (diceExpr) setTimeout(() => diceExpr.focus(), 0);
					});
				const diceClose = document.getElementById("diceClose");
				if (diceClose)
					diceClose.addEventListener("click", () => {
						const m = document.getElementById("diceModal");
						if (m) m.classList.remove("active");
					});
				const diceModal = document.getElementById("diceModal");
				if (diceModal) {
					diceModal.addEventListener("click", (e) => {
						if (e.target === diceModal) diceModal.classList.remove("active");
					});
				}
				// Floating Dice Button
				const floatingDiceBtn = document.getElementById("floatingDiceBtn");
				if (floatingDiceBtn)
					floatingDiceBtn.addEventListener("click", () => {
						const m = document.getElementById("diceModal");
						if (m) m.classList.add("active");

						const diceExpr = document.getElementById("diceExpr");
						if (diceExpr) setTimeout(() => diceExpr.focus(), 0);
					});
				// Help modal toggles
				const btnHelp = document.getElementById("btnHelp");
				if (btnHelp)
					btnHelp.addEventListener("click", () => {
						const m = document.getElementById("helpModal");
						if (m) m.classList.add("active");
					});
				const helpClose = document.getElementById("helpClose");
				if (helpClose)
					helpClose.addEventListener("click", () => {
						const m = document.getElementById("helpModal");
						if (m) m.classList.remove("active");
					});
				const helpModal = document.getElementById("helpModal");
				if (helpModal) {
					helpModal.addEventListener("click", (e) => {
						if (e.target === helpModal) helpModal.classList.remove("active");
					});
				}

				// About / Astronomican modal
				const appTitle = document.getElementById("appTitle");
				if (appTitle) {
					appTitle.addEventListener("click", () => {
						const m = document.getElementById("aboutModal");
						if (m) m.classList.add("active");
					});
				}
				const aboutClose = document.getElementById("aboutClose");
				if (aboutClose) {
					aboutClose.addEventListener("click", () => {
						const m = document.getElementById("aboutModal");
						if (m) m.classList.remove("active");
					});
				}
				const aboutModal = document.getElementById("aboutModal");
				if (aboutModal) {
					aboutModal.addEventListener("click", (e) => {
						if (e.target === aboutModal) aboutModal.classList.remove("active");
					});
				}
				// New Game
				const btnNewGame = document.getElementById("btnNewGame");
				if (btnNewGame) {
					btnNewGame.addEventListener("click", () => {
						if (
							confirm("Start a new battle? This will wipe the current state.")
						) {
							resetStateForNewGame();
							render();
							saveLocal();
							openStartModal();
						}
					});
				}
				// Importers (per-player)
				const btnImportP1 = document.getElementById("btnImportP1");
				const btnImportP2 = document.getElementById("btnImportP2");
				const fileP1 = document.getElementById("armyFileP1");
				const fileP2 = document.getElementById("armyFileP2");
				const fileNameP1 = document.getElementById("armyFileNameP1");
				const fileNameP2 = document.getElementById("armyFileNameP2");

				if (btnImportP1 && fileP1) {
					btnImportP1.addEventListener("click", () => fileP1.click());
					fileP1.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (fileNameP1)
							fileNameP1.textContent = f ? f.name : "No file chosen";
						if (!f) return;
						await processArmyFileForPlayer(f, 0); // ‚ûú Player 1
						e.target.value = ""; // reset
					});
				}

				if (btnImportP2 && fileP2) {
					btnImportP2.addEventListener("click", () => fileP2.click());
					fileP2.addEventListener("change", async (e) => {
						const f = e.target.files && e.target.files[0];
						if (fileNameP2)
							fileNameP2.textContent = f ? f.name : "No file chosen";
						if (!f) return;
						await processArmyFileForPlayer(f, 1); // ‚ûú Player 2
						e.target.value = ""; // reset
					});
				}

				// Dice
				const diceExpr = document.getElementById("diceExpr");
				const diceHighlightInput = document.getElementById("diceHighlight");
				const diceOut = document.getElementById("diceOut");
				const diceAnim = document.getElementById("diceAnim");

				document.getElementById("btnRoll").addEventListener("click", () => {
					const expr = diceExpr.value.trim();
					const thresholdVal = parseInt(diceHighlightInput.value, 10);
					const threshold = Number.isFinite(thresholdVal) ? thresholdVal : null;

					const res = doRoll(expr, threshold); // NOTE: we use the tn parameter already in your doRoll

					if (res.err) {
						diceOut.textContent = res.err;
						diceAnim.innerHTML = "";
						return;
					}

					diceOut.textContent = "Rolling‚Ä¶";

					// Animate, then show final rolls + highlight
					runDiceAnimation(res.spec, res.rolls, threshold, res.successes);
				});
				// Add Enter key handler for dice modal (both inputs)
				(function () {
					const rollBtn = document.getElementById("btnRoll");
					const diceModal = document.getElementById("diceModal");
					const inputs = [
						document.getElementById("diceExpr"),
						document.getElementById("diceHighlight"),
					].filter(Boolean);
					// Auto-select text on focus/click for quick overwrite
					inputs.forEach((inp) => {
						inp.addEventListener("focus", () => inp.select());
						inp.addEventListener("click", () => inp.select());
					});
					if (diceModal && rollBtn) {
						diceModal.addEventListener("keydown", (e) => {
							if (e.key === "Enter") {
								e.preventDefault();
								rollBtn.click();
							}
						});
					}
					inputs.forEach((inp) =>
						inp.addEventListener("keydown", (e) => {
							if (e.key === "Enter") {
								e.preventDefault();
								rollBtn.click();
							}
						})
					);
				})();
				// Log (null-safe)
				const clearLogBtn = document.getElementById("btnClearLog");
				if (clearLogBtn) {
					clearLogBtn.addEventListener("click", () => {
						const logEl = document.getElementById("log");
						if (logEl) logEl.innerHTML = "";
					});
				}

				// Global Escape key closes any open modal (backdrops use the `active` class)
				document.addEventListener("keydown", (e) => {
					if (e.key === "Escape") {
						const sm = document.getElementById("startModal");
						if (sm && sm.classList.contains("active") && !isStartReady()) {
							// Block closing the Start Game modal until requirements are met
							return;
						}
						[
							"setupModal",
							"diceModal",
							"helpModal",
							"phaseModal",
							"aboutModal",
							"stratModal",
							"missionModal",
							"startModal",
							"commandModal",
						].forEach((id) => {
							const m = document.getElementById(id);
							if (m && m.classList.contains("active"))
								m.classList.remove("active");
						});
					}
				});
			}

			// ------------------------------
			// Init
			// ------------------------------
			loadLocal();
			bind();
			render();
			// Open Start Game on first load (no saved state yet)
			try {
				const raw = localStorage.getItem("wh40k_tracker_state_v1");
				if (!raw) openStartModal();
			} catch (_) {
				openStartModal();
			}
			onPhaseStart();
			// If no saved state (or no units), prompt setup ‚Äî but never over the blocking Start Game modal
			try {
				const saved = localStorage.getItem("wh40k_tracker_state_v1");
				const noUnits =
					!State.players[0].units.length && !State.players[1].units.length;
				const sm = document.getElementById("startModal");
				const startBlocking =
					sm && sm.classList.contains("active") && !isStartReady();
				if (!startBlocking && (!saved || noUnits)) {
					openSetupModal();
				}
			} catch (e) {
				/* ignore */
			}
		</script>
	</body>
</html>
