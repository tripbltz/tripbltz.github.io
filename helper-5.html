<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Warhammer 40K Battle Assistant</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
				background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
				color: #fff;
				min-height: 100vh;
				overflow-x: hidden;
			}

			/* Header Styles */
			.header {
				background: linear-gradient(90deg, #8b0000, #4b0000);
				padding: 1rem;
				text-align: center;
				border-bottom: 3px solid #ffd700;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
			}

			.header h1 {
				font-size: 2rem;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
				letter-spacing: 2px;
			}

			/* Setup Screen */
			.setup-screen {
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 2rem;
				gap: 1rem;
				min-height: calc(100vh - 80px);
			}

			.setup-form {
				background: rgba(0, 0, 0, 0.8);
				padding: 2rem;
				border-radius: 10px;
				border: 2px solid #ffd700;
				max-width: 800px;
				width: 100%;
				box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
			}

			.setup-form h2 {
				color: #ffd700;
				margin-bottom: 1.5rem;
				text-align: center;
				font-size: 1.8rem;
			}

			.player-setup {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 2rem;
				margin-bottom: 2rem;
			}

			.player-form {
				background: rgba(255, 255, 255, 0.05);
				padding: 1.5rem;
				border-radius: 8px;
				border: 1px solid #333;
			}

			.player-form h3 {
				color: #ffd700;
				margin-bottom: 1rem;
				text-align: center;
			}

			.form-group {
				margin-bottom: 1rem;
			}

			.form-group label {
				display: block;
				margin-bottom: 0.5rem;
				color: #ffd700;
				font-weight: bold;
				font-size: 0.9rem;
			}

			.form-group input,
			.form-group select {
				width: 100%;
				padding: 0.75rem;
				border: 1px solid #666;
				border-radius: 4px;
				background: rgba(255, 255, 255, 0.1);
				color: #fff;
				font-size: 1rem;
			}

			/* Button Styles */
			.btn {
				background: linear-gradient(45deg, #8b0000, #dc143c);
				color: #fff;
				border: none;
				padding: 0.75rem 1.5rem;
				border-radius: 6px;
				cursor: pointer;
				font-size: 1rem;
				font-weight: bold;
				transition: all 0.3s;
				text-transform: uppercase;
				letter-spacing: 1px;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
			}

			.btn:hover {
				background: linear-gradient(45deg, #dc143c, #ff6347);
				transform: translateY(-2px);
				box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
			}

			.btn-secondary {
				background: linear-gradient(45deg, #4b0082, #6a5acd);
				padding: 0.5rem 1rem;
				font-size: 0.9rem;
			}

			.btn-secondary:hover {
				background: linear-gradient(45deg, #6a5acd, #9370db);
			}

			.btn-small {
				padding: 0.4rem 0.8rem;
				font-size: 0.85rem;
			}

			/* Game Container */
			.game-container {
				display: none;
				padding: 1rem;
				gap: 1rem;
				grid-template-columns: 1fr 320px;
				height: calc(100vh - 80px);
			}

			/* Phase Tracker */
			.phase-tracker {
				background: rgba(0, 0, 0, 0.8);
				padding: 1rem;
				border-radius: 10px;
				border: 2px solid #ffd700;
				margin-bottom: 1rem;
			}

			.phase-bar {
				display: flex;
				justify-content: space-between;
				margin-bottom: 1rem;
				gap: 4px;
			}

			.phase {
				background: rgba(255, 255, 255, 0.1);
				padding: 0.5rem;
				border-radius: 5px;
				border: 1px solid #666;
				cursor: pointer;
				transition: all 0.3s;
				flex: 1;
				text-align: center;
				font-size: 0.9rem;
			}

			.phase.active {
				background: linear-gradient(45deg, #ffd700, #ffa500);
				color: #000;
				border-color: #ffd700;
				transform: scale(1.05);
				font-weight: bold;
			}

			.turn-info {
				display: flex;
				justify-content: space-between;
				align-items: center;
				flex-wrap: wrap;
				gap: 1rem;
			}

			/* Player Panels */
			.players-area {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 1rem;
				height: calc(100% - 120px);
			}

			.player-panel {
				background: rgba(0, 0, 0, 0.7);
				border-radius: 10px;
				border: 2px solid #666;
				padding: 1rem;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			.player-panel.active {
				border-color: #ffd700;
				box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
			}

			.player-header {
				display: flex;
				align-items: center;
				gap: 1rem;
				margin-bottom: 1rem;
				padding-bottom: 1rem;
				border-bottom: 1px solid #666;
			}

			.player-avatar {
				width: 60px;
				height: 60px;
				border-radius: 50%;
				background: linear-gradient(45deg, #8b0000, #dc143c);
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				font-weight: bold;
				border: 2px solid #ffd700;
			}

			.player-stats {
				flex: 1;
			}

			.stat-row {
				display: flex;
				justify-content: space-between;
				margin-bottom: 0.5rem;
				font-size: 0.95rem;
			}

			.stat-badge {
				background: rgba(255, 215, 0, 0.2);
				padding: 0.2rem 0.5rem;
				border-radius: 4px;
				font-weight: bold;
			}

			/* Units Section */
			.units-section {
				flex: 1;
				overflow-y: auto;
				margin-bottom: 1rem;
				padding-right: 0.5rem;
			}

			.units-section h4 {
				color: #ffd700;
				margin-bottom: 0.75rem;
				font-size: 1.1rem;
			}

			.unit-card {
				background: rgba(255, 255, 255, 0.1);
				padding: 0.75rem;
				margin-bottom: 0.5rem;
				border-radius: 5px;
				border-left: 4px solid #ffd700;
				cursor: pointer;
				transition: all 0.3s;
			}

			.unit-card:hover {
				background: rgba(255, 215, 0, 0.1);
				transform: translateX(5px);
			}

			.unit-card.damaged {
				border-left-color: #ffa500;
			}

			.unit-card.critical {
				border-left-color: #ff4500;
			}

			.unit-card.destroyed {
				opacity: 0.5;
				border-left-color: #ff0000;
			}

			.unit-card.battleshocked {
				border-left-color: #ff00ff;
				background: rgba(255, 0, 255, 0.1);
			}

			.unit-card.engaged {
				border-left-color: #ff6600;
				background: rgba(255, 102, 0, 0.1);
			}

			.unit-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 0.5rem;
			}

			.unit-name {
				font-weight: bold;
				color: #ffd700;
			}

			.unit-stats-row {
				font-size: 0.85rem;
				color: #ccc;
				margin-bottom: 0.5rem;
			}

			.unit-wounds {
				display: flex;
				gap: 0.25rem;
				margin-top: 0.5rem;
				flex-wrap: wrap;
			}

			.wound-pip {
				width: 10px;
				height: 10px;
				border-radius: 50%;
				background: #00ff00;
				border: 1px solid #fff;
				transition: all 0.3s;
			}

			.wound-pip.lost {
				background: #ff0000;
			}

			.unit-weapons {
				margin-top: 0.5rem;
				padding-top: 0.5rem;
				border-top: 1px solid rgba(255, 255, 255, 0.2);
				font-size: 0.75rem;
				color: #aaa;
			}

			.weapon-profile {
				margin-bottom: 0.25rem;
			}

			.unit-buffs {
				margin-top: 0.5rem;
				font-size: 0.8rem;
			}

			.buff-tag {
				display: inline-block;
				background: rgba(100, 149, 237, 0.3);
				color: #87ceeb;
				padding: 0.2rem 0.5rem;
				border-radius: 3px;
				margin-right: 0.5rem;
				margin-bottom: 0.25rem;
			}

			.battleshock-badge {
				background: #ff00ff;
				color: #fff;
				padding: 0.2rem 0.5rem;
				border-radius: 3px;
				font-size: 0.75rem;
				font-weight: bold;
				margin-left: 0.5rem;
			}

			.engaged-badge {
				background: #ff6600;
				color: #fff;
				padding: 0.2rem 0.5rem;
				border-radius: 3px;
				font-size: 0.75rem;
				font-weight: bold;
				margin-left: 0.5rem;
			}

			/* Actions Section */
			.actions-section {
				border-top: 1px solid #666;
				padding-top: 1rem;
			}

			.action-input {
				display: flex;
				gap: 0.5rem;
				margin-bottom: 1rem;
			}

			.action-input input {
				flex: 1;
				padding: 0.5rem;
				border: 1px solid #666;
				border-radius: 4px;
				background: rgba(255, 255, 255, 0.1);
				color: #fff;
				font-size: 0.9rem;
			}

			.quick-actions {
				display: flex;
				gap: 0.5rem;
				flex-wrap: wrap;
			}

			/* Sidebar */
			.sidebar {
				display: flex;
				flex-direction: column;
				gap: 1rem;
				overflow-y: auto;
			}

			/* Dice Section */
			.dice-section {
				background: rgba(0, 0, 0, 0.8);
				padding: 1rem;
				border-radius: 10px;
				border: 2px solid #4b0082;
			}

			.dice-section h3 {
				color: #9370db;
				margin-bottom: 1rem;
			}

			.dice-controls {
				display: flex;
				gap: 0.5rem;
				margin-bottom: 1rem;
			}

			.dice-input {
				flex: 1;
				padding: 0.5rem;
				border: 1px solid #666;
				border-radius: 4px;
				background: rgba(255, 255, 255, 0.1);
				color: #fff;
			}

			.dice-results {
				background: rgba(255, 255, 255, 0.05);
				padding: 1rem;
				border-radius: 5px;
				min-height: 120px;
			}

			.dice-visual {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
				margin-bottom: 1rem;
			}

			.die {
				width: 36px;
				height: 36px;
				background: #fff;
				color: #000;
				border-radius: 5px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: bold;
				font-size: 1.2rem;
				border: 2px solid #000;
				animation: rollIn 0.5s ease-out;
			}

			@keyframes rollIn {
				from {
					transform: rotate(360deg) scale(0);
					opacity: 0;
				}
				to {
					transform: rotate(0) scale(1);
					opacity: 1;
				}
			}

			.die.success {
				background: #00ff00;
			}

			.die.fail {
				background: #ff6666;
			}

			/* Log Section */
			.log-section {
				background: rgba(0, 0, 0, 0.8);
				padding: 1rem;
				border-radius: 10px;
				border: 2px solid #008000;
				flex: 1;
				display: flex;
				flex-direction: column;
				min-height: 300px;
			}

			.log-section h3 {
				color: #00ff00;
				margin-bottom: 1rem;
			}

			.log-content {
				flex: 1;
				overflow-y: auto;
				background: rgba(255, 255, 255, 0.05);
				padding: 0.5rem;
				border-radius: 5px;
				font-family: "Courier New", monospace;
				font-size: 0.85rem;
				max-height: 400px;
			}

			.log-entry {
				margin-bottom: 0.5rem;
				padding: 0.5rem;
				border-left: 3px solid #ffd700;
				padding-left: 0.75rem;
				background: rgba(255, 255, 255, 0.02);
			}

			.log-timestamp {
				color: #888;
				font-size: 0.75rem;
				font-weight: bold;
			}

			.log-phase {
				color: #ffd700;
				font-weight: bold;
			}

			.log-damage {
				color: #ff6666;
			}

			.log-heal {
				color: #66ff66;
			}

			.log-stratagem {
				color: #9370db;
				font-weight: bold;
			}

			.log-shooting {
				color: #ffa500;
				font-weight: bold;
			}

			.log-morale {
				color: #ff00ff;
				font-weight: bold;
			}

			.log-charge {
				color: #ff6600;
				font-weight: bold;
			}

			/* Objectives */
			.objectives-section {
				background: rgba(0, 0, 0, 0.8);
				padding: 1rem;
				border-radius: 10px;
				border: 2px solid #ffd700;
			}

			.objective-card {
				background: rgba(255, 255, 255, 0.07);
				border-left: 4px solid #ffd700;
				margin-bottom: 0.5rem;
				padding: 0.7rem;
				border-radius: 6px;
				font-size: 0.98rem;
				display: flex;
				flex-direction: column;
				gap: 0.25rem;
			}

			.objective-control-select,
			.objective-terrain-select {
				background: rgba(0, 0, 0, 0.6);
				color: #ffd700;
				border: 1px solid #ffd700;
				border-radius: 4px;
				margin-right: 0.5rem;
			}

			/* Unit Selection Modal */
			.modal {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.8);
				z-index: 1000;
				overflow-y: auto;
			}

			.modal-content {
				background: #1a1a1a;
				margin: 2rem auto;
				padding: 2rem;
				max-width: 800px;
				border-radius: 10px;
				border: 2px solid #ffd700;
			}

			.unit-selection-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
				gap: 1rem;
				margin: 1rem 0;
			}

			.unit-select-card {
				background: rgba(255, 255, 255, 0.1);
				padding: 1rem;
				border-radius: 5px;
				border: 2px solid #666;
				cursor: pointer;
				transition: all 0.3s;
			}

			.unit-select-card:hover {
				border-color: #ffd700;
				background: rgba(255, 215, 0, 0.1);
			}

			.unit-select-card.selected {
				border-color: #00ff00;
				background: rgba(0, 255, 0, 0.1);
			}

			/* Shooting Modal */
			.shooting-modal {
				background: #1a1a1a;
				margin: 5rem auto;
				padding: 2rem;
				max-width: 600px;
				border-radius: 10px;
				border: 2px solid #ffa500;
			}

			.shooting-modal h2 {
				color: #ffa500;
				margin-bottom: 1rem;
			}

			.shooting-step {
				background: rgba(255, 255, 255, 0.05);
				padding: 1rem;
				margin-bottom: 1rem;
				border-radius: 5px;
				border: 1px solid #666;
			}

			.shooting-step h3 {
				color: #ffd700;
				margin-bottom: 0.5rem;
			}

			.roll-result {
				background: rgba(255, 165, 0, 0.1);
				padding: 0.75rem;
				border-radius: 5px;
				margin-top: 0.5rem;
				border: 1px solid #ffa500;
			}

			/* Morale Modal */
			.morale-test-modal {
				background: #1a1a1a;
				margin: 5rem auto;
				padding: 2rem;
				max-width: 500px;
				border-radius: 10px;
				border: 2px solid #ff00ff;
			}

			.morale-test-modal h2 {
				color: #ff00ff;
				margin-bottom: 1rem;
			}

			.test-info {
				background: rgba(255, 255, 255, 0.05);
				padding: 1rem;
				border-radius: 5px;
				margin-bottom: 1rem;
			}

			.test-info h3 {
				color: #ffd700;
				margin-bottom: 0.75rem;
			}

			.test-info p {
				margin-bottom: 0.5rem;
				line-height: 1.5;
			}

			.test-result {
				background: rgba(255, 255, 255, 0.05);
				padding: 1rem;
				border-radius: 5px;
				margin-top: 1rem;
				text-align: center;
				border: 2px solid #666;
				transition: all 0.3s;
			}

			.test-result.passed {
				border: 2px solid #00ff00;
				background: rgba(0, 255, 0, 0.1);
			}

			.test-result.failed {
				border: 2px solid #ff0000;
				background: rgba(255, 0, 0, 0.1);
			}

			/* Charge Modal */
			.charge-modal {
				background: #1a1a1a;
				margin: 3rem auto;
				padding: 2rem;
				max-width: 700px;
				border-radius: 10px;
				border: 2px solid #ff6600;
			}

			.charge-modal h2 {
				color: #ff6600;
				margin-bottom: 1rem;
				text-align: center;
			}

			.charge-step {
				background: rgba(255, 255, 255, 0.05);
				padding: 1.5rem;
				border-radius: 8px;
			}

			.charge-step h3 {
				color: #ffd700;
				margin-bottom: 1rem;
			}

			.charge-info {
				background: rgba(255, 102, 0, 0.1);
				border: 1px solid #ff6600;
				padding: 1rem;
				border-radius: 5px;
				margin: 1rem 0;
			}

			.charge-info p {
				margin: 0.5rem 0;
				font-size: 0.95rem;
			}

			.overwatch-option {
				background: rgba(255, 165, 0, 0.1);
				border: 1px solid #ffa500;
				padding: 1rem;
				margin-bottom: 1rem;
				border-radius: 5px;
			}

			.overwatch-option h4 {
				color: #ffa500;
				margin-bottom: 0.5rem;
			}

			.charge-roll-section {
				background: rgba(255, 255, 255, 0.08);
				padding: 1.5rem;
				border-radius: 8px;
				margin-top: 1rem;
				text-align: center;
			}

			.charge-roll-section h3 {
				color: #ff6600;
				margin-bottom: 1rem;
			}

			.charge-success {
				border-color: #00ff00 !important;
				background: rgba(0, 255, 0, 0.15) !important;
			}

			.charge-failed {
				border-color: #ff0000 !important;
				background: rgba(255, 0, 0, 0.15) !important;
			}

			/* Responsive Design */
			@media (max-width: 1200px) {
				.game-container {
					grid-template-columns: 1fr;
				}

				.sidebar {
					display: grid;
					grid-template-columns: 1fr 1fr;
					gap: 1rem;
				}

				.log-section {
					grid-column: span 2;
				}
			}

			@media (max-width: 768px) {
				.player-setup {
					grid-template-columns: 1fr;
				}

				.players-area {
					grid-template-columns: 1fr;
				}

				.phase-bar {
					flex-wrap: wrap;
				}

				.phase {
					font-size: 0.8rem;
					padding: 0.4rem;
				}
			}

			/* Scrollbar Styling */
			::-webkit-scrollbar {
				width: 8px;
			}

			::-webkit-scrollbar-track {
				background: rgba(255, 255, 255, 0.1);
				border-radius: 4px;
			}

			::-webkit-scrollbar-thumb {
				background: #ffd700;
				border-radius: 4px;
			}

			::-webkit-scrollbar-thumb:hover {
				background: #ffa500;
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>⚔️ WARHAMMER 40,000 BATTLE ASSISTANT ⚔️</h1>
		</div>

		<!-- Setup Screen -->
		<div id="setupScreen" class="setup-screen">
			<div class="setup-form">
				<h2>🛡️ Prepare for Battle</h2>
				<div class="player-setup">
					<div class="player-form">
						<h3>Player 1</h3>
						<div class="form-group">
							<label>Battle-Brother Name:</label>
							<input
								type="text"
								id="player1Name"
								placeholder="Enter commander name"
								value=""
							/>
						</div>
						<div class="form-group">
							<label>Faction:</label>
							<select id="player1Faction">
								<option value="">Select Faction</option>
								<option value="space-marines">Space Marines</option>
								<option value="imperial-guard">Astra Militarum</option>
								<option value="sisters">Adepta Sororitas</option>
								<option value="custodes">Adeptus Custodes</option>
								<option value="chaos-marines">Chaos Space Marines</option>
								<option value="death-guard">Death Guard</option>
								<option value="thousand-sons">Thousand Sons</option>
								<option value="orks">Orks</option>
								<option value="tau">T'au Empire</option>
								<option value="necrons">Necrons</option>
								<option value="eldar">Aeldari</option>
								<option value="drukhari">Drukhari</option>
								<option value="tyranids">Tyranids</option>
								<option value="genestealer">Genestealer Cults</option>
							</select>
						</div>
					</div>
					<div class="player-form">
						<h3>Player 2</h3>
						<div class="form-group">
							<label>Battle-Brother Name:</label>
							<input
								type="text"
								id="player2Name"
								placeholder="Enter commander name"
								value=""
							/>
						</div>
						<div class="form-group">
							<label>Faction:</label>
							<select id="player2Faction">
								<option value="">Select Faction</option>
								<option value="space-marines">Space Marines</option>
								<option value="imperial-guard">Astra Militarum</option>
								<option value="sisters">Adepta Sororitas</option>
								<option value="custodes">Adeptus Custodes</option>
								<option value="chaos-marines">Chaos Space Marines</option>
								<option value="death-guard">Death Guard</option>
								<option value="thousand-sons">Thousand Sons</option>
								<option value="orks">Orks</option>
								<option value="tau">T'au Empire</option>
								<option value="necrons">Necrons</option>
								<option value="eldar">Aeldari</option>
								<option value="drukhari">Drukhari</option>
								<option value="tyranids">Tyranids</option>
								<option value="genestealer">Genestealer Cults</option>
							</select>
						</div>
					</div>
				</div>
				<div class="setup-buttons" style="text-align: center">
					<button class="btn" onclick="startBattle()">
						⚡ Begin Battle ⚡
					</button>
				</div>
			</div>
		</div>

		<!-- Unit Selection Modal -->
		<div id="unitModal" class="modal">
			<div class="modal-content">
				<h2 id="modalTitle">Select Units</h2>
				<div id="unitSelectionGrid" class="unit-selection-grid"></div>
				<div style="text-align: center; margin-top: 2rem">
					<button class="btn btn-secondary" onclick="closeUnitModal()">
						Cancel
					</button>
					<button class="btn" onclick="confirmUnitSelection()">
						Confirm Selection
					</button>
				</div>
			</div>
		</div>

		<!-- Weapon Selection Modal -->
		<div id="weaponModal" class="modal">
			<div class="modal-content">
				<h2 id="weaponModalTitle">Assign Weapons</h2>
				<div id="weaponSelectionContent"></div>
				<div style="text-align: center; margin-top: 2rem">
					<button class="btn btn-secondary" onclick="closeWeaponModal()">
						Cancel
					</button>
					<button class="btn" onclick="confirmWeaponSelection()">
						Confirm Weapons
					</button>
				</div>
			</div>
		</div>

		<!-- Shooting Phase Modal -->
		<div id="shootingModal" class="modal">
			<div class="modal-content shooting-modal">
				<h2>🎯 Shooting Attack</h2>
				<div id="shootingContent">
					<!-- Dynamic content will be inserted here -->
				</div>
			</div>
		</div>

		<!-- Battle-shock Test Modal -->
		<div id="moraleModal" class="modal">
			<div class="modal-content morale-test-modal">
				<h2>⚠️ Battle-shock Test</h2>
				<div id="moraleTestContent">
					<!-- Dynamic content will be inserted here -->
				</div>
			</div>
		</div>

		<!-- Charge Phase Modal -->
		<div id="chargeModal" class="modal">
			<div class="modal-content charge-modal">
				<h2>⚡ Charge Declaration ⚡</h2>
				<div id="chargeContent">
					<!-- Dynamic content will be inserted here -->
				</div>
			</div>
		</div>

		<!-- Main Game Screen -->
		<div id="gameScreen" class="game-container">
			<div class="main-game">
				<!-- Phase Info Box -->
				<div
					id="phaseInfoBox"
					style="
						background: rgba(0, 0, 0, 0.7);
						color: #ffd700;
						padding: 0.5rem 1rem;
						border-radius: 8px;
						margin-bottom: 1rem;
						font-size: 1rem;
					"
				>
					<!-- Phase info will be injected here -->
				</div>

				<!-- Phase Tracker -->
				<div class="phase-tracker">
					<div class="phase-bar">
						<div class="phase active" data-phase="command">Command</div>
						<div class="phase" data-phase="movement">Movement</div>
						<div class="phase" data-phase="shooting">Shooting</div>
						<div class="phase" data-phase="charge">Charge</div>
						<div class="phase" data-phase="fight">Fight</div>
						<div class="phase" data-phase="morale">Morale</div>
					</div>
					<div class="turn-info">
						<div>
							<span style="font-size: 1.1rem"
								>⚔️ Battle Round: <strong id="currentTurn">1</strong></span
							>
							<span style="margin-left: 1rem"
								>👑 Active: <strong id="activePlayer">-</strong></span
							>
						</div>
						<div>
							<button class="btn btn-small" onclick="nextPhase()">
								Next Phase →
							</button>
							<button class="btn btn-secondary btn-small" onclick="endTurn()">
								End Turn
							</button>
							<button class="btn btn-secondary btn-small" onclick="resetGame()">
								Reset
							</button>
						</div>
					</div>
				</div>

				<!-- Players Area -->
				<div class="players-area">
					<!-- Player 1 Panel -->
					<div class="player-panel" id="player1Panel">
						<div class="player-header">
							<div class="player-avatar">P1</div>
							<div class="player-stats">
								<div class="stat-row">
									<span
										style="font-size: 1.1rem; font-weight: bold"
										id="player1NameDisplay"
										>Player 1</span
									>
								</div>
								<div class="stat-row">
									<span class="stat-badge"
										>⚡ CP: <span id="player1CP">0</span></span
									>
									<span class="stat-badge"
										>🎯 VP: <span id="player1VP">0</span></span
									>
								</div>
							</div>
						</div>

						<div class="units-section">
							<h4>🛡️ Battle Forces</h4>
							<div id="player1Units"></div>
						</div>

						<div class="actions-section">
							<h4 style="color: #ffd700; margin-bottom: 0.5rem">
								⚔️ Battle Commands
							</h4>
							<div class="action-input">
								<input
									type="text"
									id="player1Input"
									placeholder="e.g., 'Space Marine shoots Ork Boy', 'use Transhuman'"
								/>
								<button class="btn btn-small" onclick="processAction(1)">
									Execute
								</button>
							</div>
							<div class="quick-actions">
								<button
									class="btn btn-secondary btn-small"
									onclick="quickAction(1, 'spend-cp')"
								>
									Use CP
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="quickAction(1, 'gain-vp')"
								>
									Score VP
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="rollDiceFor(1)"
								>
									Roll Dice
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="selectUnitsForPlayer(1)"
								>
									Add Units
								</button>
							</div>
						</div>
					</div>

					<!-- Player 2 Panel -->
					<div class="player-panel" id="player2Panel">
						<div class="player-header">
							<div class="player-avatar">P2</div>
							<div class="player-stats">
								<div class="stat-row">
									<span
										style="font-size: 1.1rem; font-weight: bold"
										id="player2NameDisplay"
										>Player 2</span
									>
								</div>
								<div class="stat-row">
									<span class="stat-badge"
										>⚡ CP: <span id="player2CP">0</span></span
									>
									<span class="stat-badge"
										>🎯 VP: <span id="player2VP">0</span></span
									>
								</div>
							</div>
						</div>

						<div class="units-section">
							<h4>🛡️ Battle Forces</h4>
							<div id="player2Units"></div>
						</div>

						<div class="actions-section">
							<h4 style="color: #ffd700; margin-bottom: 0.5rem">
								⚔️ Battle Commands
							</h4>
							<div class="action-input">
								<input
									type="text"
									id="player2Input"
									placeholder="e.g., 'Ork Boy shoots Space Marine', 'WAAAGH!'"
								/>
								<button class="btn btn-small" onclick="processAction(2)">
									Execute
								</button>
							</div>
							<div class="quick-actions">
								<button
									class="btn btn-secondary btn-small"
									onclick="quickAction(2, 'spend-cp')"
								>
									Use CP
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="quickAction(2, 'gain-vp')"
								>
									Score VP
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="rollDiceFor(2)"
								>
									Roll Dice
								</button>
								<button
									class="btn btn-secondary btn-small"
									onclick="selectUnitsForPlayer(2)"
								>
									Add Units
								</button>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Sidebar -->
			<div class="sidebar">
				<!-- Dice Section -->
				<div class="dice-section">
					<h3>🎲 Dice Engine</h3>
					<div class="dice-controls">
						<input
							type="text"
							class="dice-input"
							id="diceInput"
							placeholder="e.g., '6d6', '2d6+1', 'roll 5'"
						/>
						<button class="btn btn-small" onclick="rollDice()">Roll!</button>
					</div>
					<div class="dice-results" id="diceResults">
						<div style="text-align: center; color: #888">Ready to roll...</div>
					</div>
				</div>

				<!-- Objectives Panel -->
				<div class="objectives-section">
					<h3 style="color: #ffd700">🎯 Objectives</h3>
					<div id="objectivesList"></div>
					<button class="btn btn-small" onclick="addObjective()">
						Add Objective
					</button>
				</div>

				<!-- Game Log -->
				<div class="log-section">
					<h3>📜 Battle Chronicle</h3>
					<div class="log-content" id="gameLog"></div>
					<div style="margin-top: 0.5rem; display: flex; gap: 0.5rem">
						<button class="btn btn-secondary btn-small" onclick="clearLog()">
							Clear
						</button>
						<button class="btn btn-secondary btn-small" onclick="exportLog()">
							Export
						</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Unit Actions Modal -->
		<div id="unitActionsModal" class="modal">
			<div class="modal-content">
				<h2 id="unitActionTitle">Unit Actions</h2>
				<div id="unitActionsList"></div>
				<div style="text-align: center; margin-top: 1rem">
					<button class="btn btn-secondary" onclick="closeUnitActionsModal()">
						Close
					</button>
				</div>
			</div>
		</div>

		<script>
			// Action explanations for contextual info tooltips
			const actionExplanations = {
				move: "Move this unit up to its Movement (M) value in inches.",
				advance:
					"Advance: Roll a D6 and add to this unit's Movement. Cannot shoot non-Assault weapons after advancing.",
				shoot:
					"Make ranged attacks with eligible weapons in the Shooting phase.",
				charge: "Declare a charge against eligible enemies within range.",
				fight: "Make melee attacks in the Fight phase.",
				"battle-shock":
					"If a unit is below half-strength or otherwise required, it must take a Battle-shock test in the Morale phase.",
				stratagem:
					"Use an eligible Stratagem. Consumes CP and grants a special effect.",
				recover: "Attempt to recover from Battle-shock during Morale phase.",
			};
			function showActionInfo(action) {
				alert(
					actionExplanations[action] || "No info available for this action."
				);
			}
			const factionCommands = {
				"space-marines": [
					{
						name: "Oath of Moment",
						description:
							"Select one enemy unit. This turn, reroll all failed hit rolls against that unit. If the unit is a CHARACTER, gain 1 CP.",
						phase: "shooting",
						cost: 1,
						frequency: "once",
						target: "enemy",
						type: "strategic",
					},
					{
						name: "Transhuman Physiology",
						description:
							"Select one friendly unit. Until the end of the turn, that unit can only be wounded on a roll of 4+.",
						phase: "fight",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
				"imperial-guard": [
					{
						name: "Take Cover",
						description:
							"Select one friendly unit. Until the start of your next turn, that unit gains +1 to their saving throws.",
						phase: "shooting",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
					{
						name: "For the Emperor",
						description:
							"Select one friendly unit. Until the end of the turn, that unit can reroll all failed hit rolls.",
						phase: "fight",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
				orks: [
					{
						name: "WAAAGH!",
						description:
							"All Ork units in range can reroll charge rolls and gain +1 to their Strength this turn.",
						phase: "charge",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
					{
						name: "Furious Charge",
						description:
							"Select one Ork unit. Until the end of the turn, that unit adds 1 to their damage rolls in the first round of combat.",
						phase: "fight",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
				necrons: [
					{
						name: "My Will Be Done",
						description:
							"Select one friendly Necron unit. Until the end of the turn, that unit can reroll all failed hit rolls and wound rolls.",
						phase: "shooting",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
					{
						name: "Phase Shifter",
						description:
							"Select one friendly Necron unit. Until the start of your next turn, that unit has a 4+ invulnerable save.",
						phase: "fight",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
				tau: [
					{
						name: "Supporting Fire",
						description:
							"Use when an enemy unit declares a charge. Your units can fire Overwatch even if they are not eligible to shoot this turn.",
						phase: "charge",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
					{
						name: "Tactical Withdrawal",
						description:
							"Select one friendly unit. Until the start of your next turn, that unit can move through enemy units and cannot be charged.",
						phase: "movement",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
				tyranids: [
					{
						name: "Synaptic Imperative",
						description:
							"Select one friendly Tyranid unit. Until the end of the turn, that unit gains +1 to their Strength and Toughness.",
						phase: "command",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
					{
						name: "Adrenaline Surge",
						description:
							"Use at the start of the Fight phase. One Tyranid unit can reroll all failed hit rolls in close combat this phase.",
						phase: "fight",
						cost: 1,
						frequency: "once",
						target: "friendly",
						type: "strategic",
					},
				],
			};

			// Weapon profiles database
			const weaponProfiles = {
				// Space Marines weapons
				"bolt-rifle": {
					name: "Bolt Rifle",
					range: 24,
					attacks: 2,
					bs: 3,
					strength: 4,
					ap: 1,
					damage: 1,
					abilities: [],
				},
				"auto-bolt-rifle": {
					name: "Auto Bolt Rifle",
					range: 24,
					attacks: 3,
					bs: 3,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: ["Assault"],
				},
				"stalker-bolt-rifle": {
					name: "Stalker Bolt Rifle",
					range: 36,
					attacks: 1,
					bs: 3,
					strength: 4,
					ap: 2,
					damage: 2,
					abilities: ["Heavy"],
				},
				"bolt-pistol": {
					name: "Bolt Pistol",
					range: 12,
					attacks: 1,
					bs: 3,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: ["Pistol"],
				},
				"plasma-incinerator": {
					name: "Plasma Incinerator",
					range: 24,
					attacks: 2,
					bs: 3,
					strength: 7,
					ap: 2,
					damage: 2,
					abilities: ["Rapid Fire 1"],
				},
				"plasma-pistol": {
					name: "Plasma Pistol",
					range: 12,
					attacks: 1,
					bs: 3,
					strength: 7,
					ap: 2,
					damage: 1,
					abilities: ["Pistol"],
				},
				"heavy-bolt-pistol": {
					name: "Heavy Bolt Pistol",
					range: 18,
					attacks: 1,
					bs: 3,
					strength: 4,
					ap: 1,
					damage: 1,
					abilities: ["Pistol"],
				},
				"melta-rifle": {
					name: "Melta Rifle",
					range: 12,
					attacks: 1,
					bs: 3,
					strength: 9,
					ap: 4,
					damage: "D6",
					abilities: ["Melta 2"],
				},

				// Imperial Guard weapons
				lasgun: {
					name: "Lasgun",
					range: 24,
					attacks: 1,
					bs: 4,
					strength: 3,
					ap: 0,
					damage: 1,
					abilities: ["Rapid Fire 1"],
				},
				laspistol: {
					name: "Laspistol",
					range: 12,
					attacks: 1,
					bs: 4,
					strength: 3,
					ap: 0,
					damage: 1,
					abilities: ["Pistol"],
				},
				"plasma-gun": {
					name: "Plasma Gun",
					range: 24,
					attacks: 1,
					bs: 4,
					strength: 7,
					ap: 2,
					damage: 1,
					abilities: ["Rapid Fire 1"],
				},
				meltagun: {
					name: "Meltagun",
					range: 12,
					attacks: 1,
					bs: 4,
					strength: 8,
					ap: 4,
					damage: "D6",
					abilities: ["Melta 2"],
				},
				"battle-cannon": {
					name: "Battle Cannon",
					range: 48,
					attacks: "D6+3",
					bs: 4,
					strength: 10,
					ap: 2,
					damage: 3,
					abilities: ["Blast"],
				},

				// Ork weapons
				shoota: {
					name: "Shoota",
					range: 18,
					attacks: 2,
					bs: 5,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: ["Dakka! Dakka!"],
				},
				slugga: {
					name: "Slugga",
					range: 12,
					attacks: 1,
					bs: 5,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: ["Pistol"],
				},
				choppa: {
					name: "Choppa",
					range: "Melee",
					attacks: 1,
					ws: 3,
					strength: "User",
					ap: 1,
					damage: 1,
					abilities: [],
				},
				"big-shoota": {
					name: "Big Shoota",
					range: 36,
					attacks: 3,
					bs: 5,
					strength: 5,
					ap: 0,
					damage: 1,
					abilities: ["Dakka! Dakka!"],
				},

				// Necron weapons
				"gauss-flayer": {
					name: "Gauss Flayer",
					range: 24,
					attacks: 1,
					bs: 3,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: ["Rapid Fire 1", "Lethal Hits"],
				},
				"gauss-reaper": {
					name: "Gauss Reaper",
					range: 12,
					attacks: 2,
					bs: 3,
					strength: 5,
					ap: 1,
					damage: 1,
					abilities: ["Lethal Hits"],
				},

				// T'au weapons
				"pulse-rifle": {
					name: "Pulse Rifle",
					range: 30,
					attacks: 1,
					bs: 4,
					strength: 5,
					ap: 0,
					damage: 1,
					abilities: ["Rapid Fire 1"],
				},
				"pulse-carbine": {
					name: "Pulse Carbine",
					range: 20,
					attacks: 2,
					bs: 4,
					strength: 5,
					ap: 0,
					damage: 1,
					abilities: ["Assault"],
				},

				// Tyranid weapons
				fleshborer: {
					name: "Fleshborer",
					range: 18,
					attacks: 1,
					bs: 4,
					strength: 5,
					ap: 0,
					damage: 1,
					abilities: ["Assault"],
				},
				devourer: {
					name: "Devourer",
					range: 18,
					attacks: 2,
					bs: 4,
					strength: 4,
					ap: 0,
					damage: 1,
					abilities: [],
				},
			};

			// Enhanced unit database with weapons
			const unitDatabase = {
				"space-marines": [
					{
						name: "Intercessor Squad",
						wounds: 2,
						models: 10,
						save: 3,
						leadership: 6,
						oc: 2,
						movement: 6,
						toughness: 4,
						role: "Battleline",
						weapons: ["bolt-rifle", "bolt-pistol"],
						invulnSave: null,
					},
					{
						name: "Assault Intercessors",
						wounds: 2,
						models: 10,
						save: 3,
						leadership: 6,
						oc: 2,
						movement: 6,
						toughness: 4,
						role: "Battleline",
						weapons: ["bolt-pistol", "heavy-bolt-pistol"],
						invulnSave: null,
					},
					{
						name: "Heavy Intercessors",
						wounds: 3,
						models: 5,
						save: 3,
						leadership: 6,
						oc: 1,
						movement: 5,
						toughness: 6,
						role: "Battleline",
						weapons: ["bolt-rifle", "heavy-bolt-pistol"],
						invulnSave: null,
					},
					{
						name: "Hellblasters",
						wounds: 2,
						models: 5,
						save: 3,
						leadership: 6,
						oc: 1,
						movement: 6,
						toughness: 4,
						role: "Fire Support",
						weapons: ["plasma-incinerator", "bolt-pistol"],
						invulnSave: null,
					},
					{
						name: "Captain",
						wounds: 5,
						models: 1,
						save: 3,
						leadership: 6,
						oc: 1,
						movement: 6,
						toughness: 4,
						role: "Character",
						weapons: ["bolt-rifle", "plasma-pistol"],
						invulnSave: 4,
					},
				],
				"imperial-guard": [
					{
						name: "Infantry Squad",
						wounds: 1,
						models: 10,
						save: 5,
						leadership: 7,
						oc: 2,
						movement: 6,
						toughness: 3,
						role: "Battleline",
						weapons: ["lasgun", "laspistol"],
						invulnSave: null,
					},
					{
						name: "Kasrkin",
						wounds: 1,
						models: 10,
						save: 4,
						leadership: 6,
						oc: 1,
						movement: 6,
						toughness: 3,
						role: "Elite",
						weapons: ["lasgun", "plasma-gun", "meltagun"],
						invulnSave: null,
					},
				],
				orks: [
					{
						name: "Boyz",
						wounds: 1,
						models: 10,
						save: 6,
						leadership: 7,
						oc: 2,
						movement: 6,
						toughness: 5,
						role: "Battleline",
						weapons: ["shoota", "slugga", "choppa"],
						invulnSave: null,
					},
					{
						name: "Nobz",
						wounds: 2,
						models: 5,
						save: 4,
						leadership: 7,
						oc: 1,
						movement: 6,
						toughness: 5,
						role: "Elite",
						weapons: ["shoota", "slugga", "choppa"],
						invulnSave: null,
					},
				],
				necrons: [
					{
						name: "Necron Warriors",
						wounds: 1,
						models: 10,
						save: 4,
						leadership: 10,
						oc: 2,
						movement: 5,
						toughness: 4,
						role: "Battleline",
						weapons: ["gauss-flayer", "gauss-reaper"],
						invulnSave: null,
						abilities: ["Reanimation Protocols"],
					},
					{
						name: "Immortals",
						wounds: 1,
						models: 10,
						save: 3,
						leadership: 10,
						oc: 2,
						movement: 5,
						toughness: 5,
						role: "Battleline",
						weapons: ["gauss-flayer"],
						invulnSave: null,
						abilities: ["Reanimation Protocols"],
					},
				],
				tau: [
					{
						name: "Fire Warriors",
						wounds: 1,
						models: 10,
						save: 4,
						leadership: 7,
						oc: 2,
						movement: 6,
						toughness: 3,
						role: "Battleline",
						weapons: ["pulse-rifle", "pulse-carbine"],
						invulnSave: null,
					},
				],
				tyranids: [
					{
						name: "Termagants",
						wounds: 1,
						models: 10,
						save: 5,
						leadership: 8,
						oc: 2,
						movement: 6,
						toughness: 3,
						role: "Battleline",
						weapons: ["fleshborer"],
						invulnSave: null,
					},
					{
						name: "Warriors",
						wounds: 3,
						models: 3,
						save: 4,
						leadership: 7,
						oc: 1,
						movement: 6,
						toughness: 5,
						role: "Elite",
						weapons: ["devourer"],
						invulnSave: null,
					},
				],
			};

			// Game State Management
			let gameState = {
				currentTurn: 1,
				currentPhase: "command",
				activePlayer: 1,
				phases: [
					"command",
					"movement",
					"shooting",
					"charge",
					"fight",
					"morale",
				],
				players: {
					1: {
						name: "Player 1",
						faction: "",
						cp: 0,
						vp: 0,
						units: [],
						stratagems: [],
						objectives: [],
						activeCommandEffects: [],
					},
					2: {
						name: "Player 2",
						faction: "",
						cp: 0,
						vp: 0,
						units: [],
						stratagems: [],
						objectives: [],
						activeCommandEffects: [],
					},
				},
				log: [],
				objectives: [],
				secondaryObjectives: [],
				currentUnitSelection: null,
				selectedUnits: [],
				currentShootingAttack: null,
			};

			// Initialize objectives if not present
			if (!gameState.objectives || gameState.objectives.length === 0) {
				gameState.objectives = [
					{
						id: 1,
						name: "Objective 1",
						controlledBy: null,
						terrain: "",
						notes: "",
						vp: 0,
					},
					{
						id: 2,
						name: "Objective 2",
						controlledBy: null,
						terrain: "",
						notes: "",
						vp: 0,
					},
					{
						id: 3,
						name: "Objective 3",
						controlledBy: null,
						terrain: "",
						notes: "",
						vp: 0,
					},
					{
						id: 4,
						name: "Objective 4",
						controlledBy: null,
						terrain: "",
						notes: "",
						vp: 0,
					},
				];
			}

			// Charge Phase State Management
			let currentChargeAttempt = null;
			let chargeQueue = [];

			// Process morale tests sequentially
			let moraleTestQueue = [];
			let currentMoraleTest = null;

			// Unit selection variables
			let pendingUnitsToAssign = [];
			let pendingPlayerNum = null;
			let selectedWeaponsConfig = {};

			// Initialize
			function init() {
				logEntry(
					"Welcome to Warhammer 40,000 10th Edition Battle Assistant!",
					"system"
				);
				renderObjectivesList();
				loadGameState();
			}

			// Start Battle
			function startBattle() {
				const p1Name =
					document.getElementById("player1Name").value || "Player 1";
				const p2Name =
					document.getElementById("player2Name").value || "Player 2";
				const p1Faction = document.getElementById("player1Faction").value;
				const p2Faction = document.getElementById("player2Faction").value;

				if (!p1Faction || !p2Faction) {
					alert("Please select factions for both players!");
					return;
				}

				gameState.players[1].name = p1Name;
				gameState.players[2].name = p2Name;
				gameState.players[1].faction = p1Faction;
				gameState.players[2].faction = p2Faction;

				document.getElementById("player1NameDisplay").textContent = p1Name;
				document.getElementById("player2NameDisplay").textContent = p2Name;

				// Initial CP allocation (3 CP at game start)
				gameState.players[1].cp = 3;
				gameState.players[2].cp = 3;

				document.getElementById("setupScreen").style.display = "none";
				document.getElementById("gameScreen").style.display = "grid";

				updateDisplay();
				logEntry(
					`BATTLE COMMENCES! ${p1Name} (${p1Faction}) vs ${p2Name} (${p2Faction})`,
					"system"
				);

				// Prompt for unit selection
				setTimeout(() => {
					selectUnitsForPlayer(1);
				}, 500);
			}

			// Unit Selection
			function selectUnitsForPlayer(playerNum) {
				gameState.currentUnitSelection = playerNum;
				gameState.selectedUnits = [];

				const modal = document.getElementById("unitModal");
				const modalTitle = document.getElementById("modalTitle");
				const grid = document.getElementById("unitSelectionGrid");

				modalTitle.textContent = `Select Units for ${gameState.players[playerNum].name}`;

				const faction = gameState.players[playerNum].faction;
				const availableUnits = unitDatabase[faction] || [];

				grid.innerHTML = "";

				availableUnits.forEach((unit, index) => {
					const card = document.createElement("div");
					card.className = "unit-select-card";
					card.dataset.unitIndex = index;

					const weaponsList = unit.weapons
						? unit.weapons.map((w) => weaponProfiles[w]?.name || w).join(", ")
						: "None";

					card.innerHTML = `
															<h4 style="color: #FFD700; margin-bottom: 0.5rem;">${unit.name}</h4>
															<div style="font-size: 0.85rem; line-height: 1.5;">
																<div>Role: ${unit.role}</div>
																<div>Models: ${unit.models} | Wounds: ${unit.wounds}</div>
																<div>M: ${unit.movement}" | T: ${unit.toughness} | Sv: ${unit.save}+ | Ld: ${unit.leadership}+</div>
																<div>OC: ${unit.oc}</div>
																<div style="margin-top: 0.5rem; color: #ffa500;">Weapons: ${weaponsList}</div>
															</div>
														`;

					card.onclick = () => toggleUnitSelection(card, unit);
					grid.appendChild(card);
				});

				modal.style.display = "block";
			}

			function toggleUnitSelection(card, unit) {
				card.classList.toggle("selected");

				if (card.classList.contains("selected")) {
					gameState.selectedUnits.push(unit);
				} else {
					const index = gameState.selectedUnits.findIndex(
						(u) => u.name === unit.name
					);
					if (index > -1) {
						gameState.selectedUnits.splice(index, 1);
					}
				}
			}

			function closeUnitModal() {
				document.getElementById("unitModal").style.display = "none";
				gameState.currentUnitSelection = null;
				gameState.selectedUnits = [];
			}

			function confirmUnitSelection() {
				const playerNum = gameState.currentUnitSelection;
				if (gameState.selectedUnits.length === 0) {
					alert("Please select at least one unit!");
					return;
				}
				// Save selections for weapon configuration
				pendingUnitsToAssign = [...gameState.selectedUnits];
				pendingPlayerNum = playerNum;
				gameState.selectedUnits = [];
				closeUnitModal();
				showWeaponModal();
			}

			function showWeaponModal() {
				if (pendingUnitsToAssign.length === 0) {
					// All done, add units to player army!
					updateUnitsDisplay(pendingPlayerNum);
					logEntry(
						`${gameState.players[pendingPlayerNum].name} has deployed units!`,
						"system"
					);
					// If player 1 just finished, prompt for player 2
					if (
						pendingPlayerNum === 1 &&
						gameState.players[2].units.length === 0
					) {
						setTimeout(() => selectUnitsForPlayer(2), 500);
					}
					pendingUnitsToAssign = [];
					pendingPlayerNum = null;
					selectedWeaponsConfig = {};
					saveGameState();
					return;
				}
				// Pick the first unit to configure
				const unit = pendingUnitsToAssign[0];
				selectedWeaponsConfig = {};
				const modal = document.getElementById("weaponModal");
				const content = document.getElementById("weaponSelectionContent");
				document.getElementById(
					"weaponModalTitle"
				).textContent = `Assign Weapons for ${unit.name} (${unit.models} models)`;
				// Build weapon selection UI
				let html = `<form id="weaponForm"><div style="margin-bottom:1rem;">Assign how many models carry each weapon (total must be ${unit.models}):</div>`;
				unit.weapons.forEach((weaponKey) => {
					const weapon = weaponProfiles[weaponKey];
					if (!weapon) return;
					html += `
											  <div style="margin-bottom:8px;">
												<label>
												  <strong>${weapon.name}</strong>
												  (<span style="font-size:0.9em">${weapon.range}", S${weapon.strength}, AP-${weapon.ap}, D${weapon.damage}</span>)
												</label>
												<input
												  type="number"
												  min="0"
												  max="${unit.models}"
												  value="0"
												  id="weaponCount_${weaponKey}"
												  style="width:60px; margin-left:12px"
												  onchange="checkWeaponTotal('${unit.name}', ${unit.models})"
												>
											  </div>
											`;
				});
				html += `<div id="weaponTotalNotice" style="color:#ffd700;margin-top:8px;"></div></form>`;
				content.innerHTML = html;
				modal.style.display = "block";
				checkWeaponTotal(unit.name, unit.models);
			}

			function checkWeaponTotal(unitName, maxModels) {
				// Check if assigned counts match the required total
				let total = 0;
				const unit = pendingUnitsToAssign[0];
				unit.weapons.forEach((weaponKey) => {
					const val =
						parseInt(
							document.getElementById(`weaponCount_${weaponKey}`).value
						) || 0;
					total += val;
				});
				const notice = document.getElementById("weaponTotalNotice");
				if (total < maxModels) {
					notice.textContent = `You have assigned ${total}/${maxModels} models.`;
				} else if (total > maxModels) {
					notice.textContent = `Too many assigned! (${total}/${maxModels})`;
				} else {
					notice.textContent = `✅ Assignment complete!`;
				}
			}

			function confirmWeaponSelection() {
				const unit = pendingUnitsToAssign[0];
				// Gather selections
				let total = 0;
				let config = {};
				unit.weapons.forEach((weaponKey) => {
					const count =
						parseInt(
							document.getElementById(`weaponCount_${weaponKey}`).value
						) || 0;
					config[weaponKey] = count;
					total += count;
				});
				if (total !== unit.models) {
					alert(`Please assign exactly ${unit.models} models to weapons.`);
					return;
				}
				// Build unit with battleshock properties
				const newUnit = {
					...unit,
					id: Date.now() + Math.random(),
					currentWounds: unit.wounds * unit.models,
					maxWounds: unit.wounds * unit.models,
					currentModels: unit.models,
					startingStrength: unit.models,
					battleshocked: false,
					battleshockModifier: 0,
					engagedWith: [],
					hasCharged: false,
					madeChargeThisTurn: false,
					chargedOnTurn: null,
					status: "active",
					buffs: [],
					damageTaken: 0,
					hasShot: false,
					hasFought: false,
					weaponConfig: config,
				};
				gameState.players[pendingPlayerNum].units.push(newUnit);
				pendingUnitsToAssign.shift(); // Done with this unit, next!
				closeWeaponModal();
				showWeaponModal();
			}

			function closeWeaponModal() {
				document.getElementById("weaponModal").style.display = "none";
			}

			// Display Updates
			function updateDisplay() {
				// Update phase display
				document.querySelectorAll(".phase").forEach((phase) => {
					phase.classList.remove("active");
					if (phase.dataset.phase === gameState.currentPhase) {
						phase.classList.add("active");
					}
				});

				// Update turn and active player
				document.getElementById("currentTurn").textContent =
					gameState.currentTurn;
				document.getElementById("activePlayer").textContent =
					gameState.players[gameState.activePlayer].name;

				// Update player panels
				document
					.querySelectorAll(".player-panel")
					.forEach((panel) => panel.classList.remove("active"));
				document
					.getElementById(`player${gameState.activePlayer}Panel`)
					.classList.add("active");

				// Update CP and VP
				document.getElementById("player1CP").textContent =
					gameState.players[1].cp;
				document.getElementById("player1VP").textContent =
					gameState.players[1].vp;
				document.getElementById("player2CP").textContent =
					gameState.players[2].cp;
				document.getElementById("player2VP").textContent =
					gameState.players[2].vp;

				// Update units
				updateUnitsDisplay(1);
				updateUnitsDisplay(2);
			}

			// --- Action legality helpers ---
			function canUnitMove(unit, phase) {
				return (
					phase === "movement" && !unit.hasMoved && unit.status !== "destroyed"
				);
			}
			function canUnitAdvance(unit, phase) {
				return (
					phase === "movement" && !unit.hasMoved && unit.status !== "destroyed"
				);
			}
			function canUnitShoot(unit, phase) {
				return (
					phase === "shooting" &&
					!unit.hasShot &&
					!unit.battleshocked &&
					unit.status !== "destroyed"
				);
			}
			function canUnitCharge(unit, phase) {
				return (
					phase === "charge" &&
					!unit.hasCharged &&
					!unit.battleshocked &&
					unit.status !== "destroyed"
				);
			}
			function canUnitFight(unit, phase) {
				return (
					phase === "fight" &&
					!unit.hasFought &&
					!unit.battleshocked &&
					unit.status !== "destroyed"
				);
			}
			function canUnitBattleShock(unit, phase) {
				return (
					phase === "morale" &&
					!unit.battleshocked &&
					unit.status !== "destroyed" &&
					unit.currentModels <= unit.models / 2
				);
			}
			function canUnitRecover(unit, phase) {
				return (
					phase === "morale" &&
					unit.battleshocked &&
					unit.status !== "destroyed"
				);
			}
			function canUnitStratagem(unit, phase, playerNum) {
				// Show stratagem button if at least one is available for this phase
				const availableStrats = getAvailableStratagems(
					gameState.players[playerNum].faction,
					phase,
					gameState.players[playerNum].cp,
					unit
				);
				return availableStrats.length > 0 && unit.status !== "destroyed";
			}

			function updateUnitsDisplay(playerNum) {
				const container = document.getElementById(`player${playerNum}Units`);
				if (!container) return;

				container.innerHTML = "";

				gameState.players[playerNum].units.forEach((unit) => {
					const unitDiv = document.createElement("div");
					unitDiv.className = "unit-card";
					// Create wound display
					let woundPips = "";
					const maxPipsToShow = Math.min(unit.maxWounds, 20);
					for (let i = 0; i < maxPipsToShow; i++) {
						woundPips += `<div class="wound-pip ${
							i >= unit.currentWounds ? "lost" : ""
						}"></div>`;
					}

					// Create weapons display with counts
					let weaponsHtml = "";
					if (unit.weaponConfig) {
						weaponsHtml = '<div class="unit-weapons">';
						Object.entries(unit.weaponConfig).forEach(([weaponKey, count]) => {
							if (count > 0) {
								const weapon = weaponProfiles[weaponKey];
								weaponsHtml += `<div class="weapon-profile">• ${weapon.name} x${count} (${weapon.range}", S${weapon.strength}, AP-${weapon.ap})</div>`;
							}
						});
						weaponsHtml += "</div>";
					} else if (unit.weapons && unit.weapons.length > 0) {
						weaponsHtml = '<div class="unit-weapons">';
						unit.weapons.forEach((weaponKey) => {
							const weapon = weaponProfiles[weaponKey];
							if (weapon) {
								weaponsHtml += `<div class="weapon-profile">• ${weapon.name} (${weapon.range}", S${weapon.strength}, AP-${weapon.ap})</div>`;
							}
						});
						weaponsHtml += "</div>";
					}

					// Create buffs display
					let buffsHtml = "";
					if (unit.buffs && unit.buffs.length > 0) {
						buffsHtml = '<div class="unit-buffs">';
						unit.buffs.forEach((buff) => {
							let durLabel = buff.duration === "phase" ? "🕒 phase" : "🕒 turn";
							buffsHtml += `<span class="buff-tag">${buff.name} <span style="opacity:0.7;">(${durLabel})</span></span>`;
						});
						buffsHtml += "</div>";
					}

					// --- Contextual action buttons per phase ---
					let actionsHtml =
						'<div class="unit-actions" style="margin-top: 0.5rem;">';
					const phase = gameState.currentPhase;
					const isActivePlayer = playerNum === gameState.activePlayer;
					if (isActivePlayer && unit.status !== "destroyed") {
						// Move/Advance phase
						if (canUnitMove(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitMoveAction('${unit.id}', ${playerNum})">Move</button>
								<button class="btn-info btn-small" onclick="showActionInfo('move')">?</button>`;
						}
						if (canUnitAdvance(unit, phase)) {
							actionsHtml += `<button class="btn btn-secondary btn-small" onclick="unitAdvanceAction('${unit.id}', ${playerNum})">Advance</button>
								<button class="btn-info btn-small" onclick="showActionInfo('advance')">?</button>`;
						}
						// Shooting phase
						if (canUnitShoot(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitShootAction('${unit.id}', ${playerNum})">Shoot</button>
								<button class="btn-info btn-small" onclick="showActionInfo('shoot')">?</button>`;
						}
						// Charge phase
						if (canUnitCharge(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitChargeAction('${unit.id}', ${playerNum})">Charge</button>
								<button class="btn-info btn-small" onclick="showActionInfo('charge')">?</button>`;
						}
						// Fight phase
						if (canUnitFight(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitFightAction('${unit.id}', ${playerNum})">Fight</button>
								<button class="btn-info btn-small" onclick="showActionInfo('fight')">?</button>`;
						}
						// Morale phase
						if (canUnitRecover(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitRecoverAction('${unit.id}', ${playerNum})">Recover</button>
								<button class="btn-info btn-small" onclick="showActionInfo('recover')">?</button>`;
						} else if (canUnitBattleShock(unit, phase)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitBattleShockAction('${unit.id}', ${playerNum})">Battle-shock Test</button>
								<button class="btn-info btn-small" onclick="showActionInfo('battle-shock')">?</button>`;
						}
						// Stratagems (phase smart)
						if (canUnitStratagem(unit, phase, playerNum)) {
							actionsHtml += `<button class="btn btn-small" onclick="unitStratagemAction('${unit.id}', ${playerNum})">Use Stratagem</button>
								<button class="btn-info btn-small" onclick="showActionInfo('stratagem')">?</button>`;
						}
					}
					actionsHtml += "</div>";

					// Action status and engagement
					let statusIcons = "";
					if (gameState.currentPhase === "shooting" && unit.hasShot) {
						statusIcons += " 🎯";
					}
					if (gameState.currentPhase === "fight" && unit.hasFought) {
						statusIcons += " ⚔️";
					}
					if (unit.hasCharged && gameState.currentTurn === unit.chargedOnTurn) {
						statusIcons += " ⚡";
					}

					// Engagement display
					let engagementHtml = "";
					if (unit.engagedWith && unit.engagedWith.length > 0) {
						const engagedNames = unit.engagedWith
							.map((id) => {
								const engagedUnit = findUnitById(id);
								return engagedUnit ? engagedUnit.name : "Unknown";
							})
							.join(", ");
						engagementHtml = `<div style="color: #ff6666; font-size: 0.8rem; margin-top: 0.25rem;">⚔️ Engaged with: ${engagedNames}</div>`;
					}

					unitDiv.innerHTML = `
						<div class="unit-header">
							<span class="unit-name">${unit.name}${
						unit.battleshocked
							? '<span class="battleshock-badge">BATTLE-SHOCKED</span>'
							: ""
					}${statusIcons}</span>
							<span>${unit.currentModels}/${unit.models} models</span>
						</div>
						<div class="unit-stats-row">
							M: ${unit.movement}" | T: ${unit.toughness} | Sv: ${unit.save}+${
						unit.invulnSave ? `/${unit.invulnSave}++` : ""
					} | W: ${unit.wounds} | Ld: ${unit.leadership}+ | OC: ${unit.oc}
						</div>
						<div class="unit-wounds">${woundPips}</div>
						<div style="font-size: 0.8rem; margin-top: 0.5rem; color: #ccc;">
							Wounds: ${unit.currentWounds}/${unit.maxWounds} | ${unit.role}
							${unit.battleshocked ? " | Cannot control objectives" : ""}
						</div>
						${engagementHtml}
						${weaponsHtml}
						${buffsHtml}
						${actionsHtml}
					`;

					unitDiv.onclick = (e) => {
						e.stopPropagation();
						showUnitActionsModal(unit, playerNum);
					};
					container.appendChild(unitDiv);
				});
			}
			// --- Per-unit action button placeholder functions ---
			function unitMoveAction(unitId, playerNum) {
				logEntry("Move action for unit: " + unitId, "system");
				// TODO: Implement move logic/modal
			}
			function unitAdvanceAction(unitId, playerNum) {
				logEntry("Advance action for unit: " + unitId, "system");
				// TODO: Implement advance logic/modal
			}
			function unitShootAction(unitId, playerNum) {
				logEntry("Shoot action for unit: " + unitId, "system");
				// Could call existing shooting sequence/modal with this unit
			}
			function unitChargeAction(unitId, playerNum) {
				logEntry("Charge action for unit: " + unitId, "system");
				// TODO: Implement charge logic/modal
			}
			function unitFightAction(unitId, playerNum) {
				logEntry("Fight action for unit: " + unitId, "system");
				// TODO: Implement fight logic/modal
			}
			function unitBattleShockAction(unitId, playerNum) {
				logEntry("Battle-shock test for unit: " + unitId, "system");
				// TODO: Implement test logic/modal
			}
			function unitRecoverAction(unitId, playerNum) {
				logEntry("Recover action for unit: " + unitId, "system");
				// TODO: Implement recovery logic/modal
			}
			function unitStratagemAction(unitId, playerNum) {
				logEntry("Use Stratagem for unit: " + unitId, "system");
				// TODO: Show eligible stratagems for this unit
			}
			// (Optional) Info button CSS
			// Add this to the style section if not present:
			// .btn-info {
			//   background: #ffd700;
			//   color: #222;
			//   border: none;
			//   border-radius: 50%;
			//   font-size: 1em;
			//   width: 2em;
			//   height: 2em;
			//   margin-left: 0.25em;
			//   cursor: pointer;
			//   display: inline-block;
			//   font-weight: bold;
			//   vertical-align: middle;
			//   transition: background 0.2s;
			// }
			// .btn-info:hover {
			//   background: #ffa500;
			// }

			// Enhanced Natural Language Processing
			function processAction(playerNum) {
				const input = document
					.getElementById(`player${playerNum}Input`)
					.value.trim();
				if (!input) return;

				const lowerInput = input.toLowerCase();

				// Check for battle-shock related commands
				if (
					lowerInput.includes("battle-shock") ||
					lowerInput.includes("battleshock") ||
					lowerInput.includes("morale") ||
					lowerInput.includes("leadership test")
				) {
					if (lowerInput.includes("test") || lowerInput.includes("check")) {
						const unitMatch = input.match(/(.+?)\s+(?:takes?|makes?|test)/i);
						if (unitMatch) {
							const unitName = unitMatch[1].trim();
							const unit = findUnit(unitName, playerNum);
							if (unit && !unit.battleshocked) {
								processMoraleTests([{ unit, playerNum }]);
								document.getElementById(`player${playerNum}Input`).value = "";
								return;
							}
						}
					} else if (
						lowerInput.includes("recover") ||
						lowerInput.includes("rally")
					) {
						const unitMatch = input.match(/(.+?)\s+(?:recovers?|rallies)/i);
						if (unitMatch) {
							const unitName = unitMatch[1].trim();
							const unit = findUnit(unitName, playerNum);
							if (unit && unit.battleshocked) {
								unit.battleshocked = false;
								logEntry(
									`${unit.name} recovers from being Battle-shocked`,
									"morale"
								);
								updateDisplay();
								saveGameState();
							}
						}
					}
					document.getElementById(`player${playerNum}Input`).value = "";
					return;
				}

				// Process different types of commands
				if (
					lowerInput.includes("shoot") ||
					lowerInput.includes("fire") ||
					lowerInput.includes("attack")
				) {
					processShooting(input, playerNum);
				} else if (
					lowerInput.includes("takes") ||
					lowerInput.includes("suffers") ||
					lowerInput.includes("loses")
				) {
					processDamage(input, playerNum);
				} else if (
					lowerInput.includes("heals") ||
					lowerInput.includes("regains")
				) {
					processHealing(input, playerNum);
				} else if (lowerInput.includes("spend") && lowerInput.includes("cp")) {
					processCP(input, playerNum, "spend");
				} else if (
					lowerInput.includes("gain") &&
					(lowerInput.includes("cp") || lowerInput.includes("command"))
				) {
					processCP(input, playerNum, "gain");
				} else if (
					lowerInput.includes("score") ||
					lowerInput.includes("vp") ||
					lowerInput.includes("victory")
				) {
					processVP(input, playerNum);
				} else if (
					lowerInput.includes("use") ||
					lowerInput.includes("stratagem")
				) {
					processStratagem(input, playerNum);
				} else if (lowerInput.includes("roll")) {
					processDiceRoll(input, playerNum);
				} else if (lowerInput.includes("charge")) {
					processCharge(input, playerNum);
				} else if (
					lowerInput.includes("+") &&
					(lowerInput.includes("hit") ||
						lowerInput.includes("wound") ||
						lowerInput.includes("save"))
				) {
					processBuff(input, playerNum);
				} else {
					// Generic action logging
					logEntry(`${gameState.players[playerNum].name}: ${input}`, "action");
				}

				// Clear input
				document.getElementById(`player${playerNum}Input`).value = "";
				updateDisplay();
				saveGameState();
			}

			// New Shooting Functions
			function processShooting(input, playerNum) {
				if (gameState.currentPhase !== "shooting") {
					logEntry(
						"Shooting attacks can only be made in the Shooting phase!",
						"error"
					);
					return;
				}

				const match = input.match(
					/(.+?)\s+(?:shoots?|fires?|attacks?)\s+(?:at\s+)?(.+)/i
				);

				if (match) {
					const shooterName = match[1].trim();
					const targetName = match[2].trim();

					const shooter = findUnit(shooterName, playerNum);
					const target = findUnitAnyPlayer(targetName);

					if (!shooter) {
						logEntry(
							`Unit "${shooterName}" not found for ${gameState.players[playerNum].name}`,
							"error"
						);
						return;
					}

					if (!target) {
						logEntry(`Target unit "${targetName}" not found`, "error");
						return;
					}

					if (shooter.hasShot) {
						logEntry(`${shooter.name} has already shot this phase!`, "error");
						return;
					}

					if (shooter.status === "destroyed") {
						logEntry(`${shooter.name} is destroyed and cannot shoot!`, "error");
						return;
					}

					// Start shooting sequence
					startShootingSequence(shooter, target, playerNum);
				} else {
					logEntry(
						"Invalid shooting command. Use format: '[Unit] shoots [Target]'",
						"error"
					);
				}
			}

			function startShootingSequence(shooter, target, shooterPlayer) {
				gameState.currentShootingAttack = {
					shooter: shooter,
					target: target,
					shooterPlayer: shooterPlayer,
					selectedWeapon: null,
					hits: 0,
					wounds: 0,
					saves: 0,
					damage: 0,
				};
				showShootingModal();
			}

			// Show the shooting modal and allow multi-weapon selection
			function showShootingModal() {
				const modal = document.getElementById("shootingModal");
				const content = document.getElementById("shootingContent");
				const attack = gameState.currentShootingAttack;
				const shooter = attack.shooter;

				// Build list of eligible ranged weapons
				let weaponChoices = [];
				const alive = shooter.currentModels || shooter.models || 1;

				if (shooter.weaponConfig) {
					for (const [weaponKey, count] of Object.entries(
						shooter.weaponConfig
					)) {
						const weapon = weaponProfiles[weaponKey];
						if (weapon && weapon.range !== "Melee" && count > 0) {
							weaponChoices.push({
								weaponKey,
								weapon,
								count: alive,
							});
						}
					}
				} else if (shooter.weapons) {
					shooter.weapons.forEach((weaponKey) => {
						const weapon = weaponProfiles[weaponKey];
						if (weapon && weapon.range !== "Melee") {
							weaponChoices.push({
								weaponKey,
								weapon,
								count: alive,
							});
						}
					});
				}

				// Modal content
				let html = `
									<div class="shooting-step">
									<h3>Target: ${attack.target.name}</h3>
									<label>Terrain:
										<select id="shootingTerrainSelect" style="width:70%;margin-bottom:1rem;">
											<option value="">None</option>
											<option value="Light Cover (+1 Save)">Light Cover (+1 Save)</option>
											<option value="Dense Cover (-1 to Hit)">Dense Cover (-1 to Hit)</option>
											<option value="Obscuring (Block if rules apply)">Obscuring (Block if rules apply)</option>
											<option value="Heavy Cover">Heavy Cover</option>
										</select>
									</label>
									<h3>Select Weapons to Fire</h3>
									<div id="weaponSelectMulti">
									`;

				weaponChoices.forEach((w, i) => {
					html += `
										<div style="margin-bottom:10px;">
											<input type="checkbox" id="weaponChk_${w.weaponKey}" value="${
						w.weaponKey
					}" onchange="updateModelFireCountMulti('${shooter.name}')">
											<label for="weaponChk_${w.weaponKey}" style="font-weight:bold;">${
						w.weapon.name
					}</label>
											<span style="font-size:0.9em;">(${w.weapon.range}", A${w.weapon.attacks}, S${
						w.weapon.strength
					}, AP-${w.weapon.ap}, D${w.weapon.damage})</span>
											<br>
											<span style="margin-left:24px;">
												Models firing:
									<input type="number" id="fireCount_${w.weaponKey}" value="0" min="0" max="${
						shooter.currentModels || shooter.models || 1
					}" disabled style="width:40px;">
									<span style="color:#888;font-size:0.85em;">(max ${
										shooter.currentModels || shooter.models || 1
									})</span>
											</span>
										</div>
									`;
				});

				html += `
									</div>
									<div id="multiWeaponCountNotice" style="color:#FFD700;margin:8px 0;"></div>
									<div style="text-align:center; margin-top:1rem;">
										<button class="btn" onclick="selectWeaponsAndFire()">Fire!</button>
										<button class="btn btn-secondary" onclick="closeShootingModal()">Cancel</button>
									</div>
									<div id="shootingProgress"></div>
									</div>
									`;

				content.innerHTML = html;
				modal.style.display = "block";
				// Attach event handlers for number input enabling
				setTimeout(() => {
					weaponChoices.forEach((w) => {
						const chk = document.getElementById(`weaponChk_${w.weaponKey}`);
						const num = document.getElementById(`fireCount_${w.weaponKey}`);
						if (chk && num) {
							chk.addEventListener("change", () => {
								num.disabled = !chk.checked;
								if (!chk.checked) num.value = 0;
								updateModelFireCountMulti(shooter.name);
							});
							num.addEventListener("input", () => {
								updateModelFireCountMulti(shooter.name);
							});
						}
					});
				}, 20);
				updateModelFireCountMulti(shooter.name);
			}

			function closeShootingModal() {
				const modal = document.getElementById("shootingModal");
				if (modal) modal.style.display = "none";
				// Optionally, clear out modal contents for cleanliness
				const content = document.getElementById("shootingContent");
				if (content) content.innerHTML = "";
				gameState.currentShootingAttack = null;
			}

			// Keeps the total assigned models across all weapons <= alive
			function updateModelFireCountMulti(unitName) {
				// Find the shooter
				let shooter = null;
				for (const player of [gameState.players[1], gameState.players[2]]) {
					shooter = player.units.find((u) => u.name === unitName);
					if (shooter) break;
				}
				if (!shooter) return;

				const alive = shooter.currentModels || shooter.models || 1;
				let total = 0;
				let weaponOverLimit = false;

				if (shooter.weaponConfig) {
					for (const weaponKey of Object.keys(shooter.weaponConfig)) {
						const chk = document.getElementById(`weaponChk_${weaponKey}`);
						const num = document.getElementById(`fireCount_${weaponKey}`);
						if (chk && num && chk.checked) {
							const val = parseInt(num.value) || 0;
							if (val > parseInt(num.max)) {
								num.value = num.max;
							}
							total += val;
						}
					}
				}
				let notice = document.getElementById("multiWeaponCountNotice");
				if (total > alive) {
					notice.textContent = `❌ Assigned too many models (${total}/${alive})`;
					weaponOverLimit = true;
				} else {
					notice.textContent = `Assigned: ${total}/${alive} models`;
				}
				// Optionally: disable Fire! button if over limit
				const fireBtn = document.querySelector("#shootingContent .btn");
				if (fireBtn) fireBtn.disabled = weaponOverLimit || total === 0;
			}

			// Handle when Fire! is clicked for multi-weapon shooting
			function selectWeaponsAndFire() {
				const attack = gameState.currentShootingAttack;
				const shooter = attack.shooter;
				const alive = shooter.currentModels || shooter.models || 1;
				let selectedWeapons = [];

				if (shooter.weaponConfig) {
					for (const weaponKey of Object.keys(shooter.weaponConfig)) {
						const chk = document.getElementById(`weaponChk_${weaponKey}`);
						const num = document.getElementById(`fireCount_${weaponKey}`);
						if (chk && num && chk.checked) {
							const count = parseInt(num.value) || 0;
							if (count > 0) {
								const weapon = weaponProfiles[weaponKey];
								selectedWeapons.push({
									weaponKey,
									weapon,
									count,
								});
							}
						}
					}
				}
				if (selectedWeapons.length === 0) return;

				// Store selected weapons and terrain for attack
				const terrainSel = document.getElementById("shootingTerrainSelect");
				attack.selectedWeapons = selectedWeapons;
				attack.targetTerrain = terrainSel ? terrainSel.value : "";

				attack.weaponResults = []; // Results per weapon
				attack.currentWeaponIndex = 0; // Track which weapon is being resolved

				// Proceed to multi-weapon roll
				rollToHitMulti();
			}

			// Core multi-weapon rolling and result rendering
			function rollToHitMulti() {
				const attack = gameState.currentShootingAttack;
				if (!attack.selectedWeapons || attack.selectedWeapons.length === 0)
					return;
				const wi = attack.currentWeaponIndex;
				const { weapon, count, weaponKey } = attack.selectedWeapons[wi];
				const modelsFiring = count;

				// Calculate number of attacks per model
				let numAttacksPerModel = weapon.attacks;
				if (typeof numAttacksPerModel === "string") {
					numAttacksPerModel = rollVariableDice(numAttacksPerModel);
				}
				let numAttacks = numAttacksPerModel * modelsFiring;

				// Abilities example: Rapid Fire (improve this logic for other abilities as needed)
				if (
					weapon.abilities &&
					weapon.abilities.includes("Rapid Fire 1") &&
					attack.shooter.weapons.includes(weaponKey)
				) {
					numAttacks *= 2;
				}

				// Hit target and modifiers
				let hitTarget = weapon.bs || 3;
				let modifierMsg = "";

				// Apply Battle-shocked penalty
				if (attack.shooter.battleshocked) {
					hitTarget += 1;
					modifierMsg +=
						"<span style='color:#ff00ff;'>-1 to hit (Battle-shocked)</span> ";
				}

				if (
					attack.targetTerrain &&
					attack.targetTerrain.includes("Dense Cover")
				) {
					hitTarget += 1;
					modifierMsg +=
						"<span style='color:#ffa500;'>-1 to hit due to Dense Cover</span>";
				}

				if (
					attack.targetTerrain &&
					attack.targetTerrain.includes("Obscuring")
				) {
					updateShootingProgressMulti(
						`
						<div class="roll-result">
							<h4>${weapon.name} (${modelsFiring} models firing)</h4>
							<p style="color:orange;font-weight:bold;">Obscuring terrain: This shot may be blocked depending on scenario/rules.</p>
							<button class="btn btn-secondary btn-small" onclick="advanceWeaponMulti()">Skip</button>
						</div>
					`,
						wi
					);
					return;
				}

				// --- Oath of Moment reroll logic ---
				const defenderPlayerNum = findUnitOwner(attack.target);
				const attackerPlayerNum = attack.shooterPlayer;
				let rerollOath = checkOathOfMoment(attackerPlayerNum, attack.target.id);

				// Roll dice
				const rolls = [];
				let hits = 0;
				for (let i = 0; i < numAttacks; i++) {
					const roll = Math.floor(Math.random() * 6) + 1;
					rolls.push(roll);
					if (roll >= hitTarget || roll === 6) hits++;
				}
				// Oath of Moment: reroll all failed hits
				if (rerollOath) {
					let failed = rolls.filter((r) => r < hitTarget);
					let rerolls = failed.map((_) => Math.floor(Math.random() * 6) + 1);
					let newHits = rerolls.filter((r) => r >= hitTarget).length;
					hits += newHits;
					logEntry(
						`Oath of Moment active: rerolled misses for ${newHits} more hits!`,
						"stratagem"
					);
				}

				attack.weaponResults[wi] = {
					hits: hits,
					rolls: rolls,
					wounds: null,
					saves: null,
					damage: null,
				};

				updateShootingProgressMulti(
					`
					<div class="roll-result">
						<h4>${
							weapon.name
						} (${modelsFiring} models firing) — Hit Rolls (${hitTarget}+ to hit) ${modifierMsg}</h4>
						<div class="dice-visual">${rolls
							.map(
								(r) =>
									`<div class="die ${
										r >= hitTarget || r === 6 ? "success" : "fail"
									}">${r}</div>`
							)
							.join("")}</div>
						<p>${hits} hits from ${numAttacks} attacks</p>
						${
							hits > 0
								? `<button class="btn btn-small" onclick="rollToWoundMulti()">Roll to Wound</button>`
								: `<button class="btn btn-secondary btn-small" onclick="advanceWeaponMulti()">No Hits - Next Weapon</button>`
						}
					</div>
					`,
					wi
				);
			}

			function rollToWoundMulti() {
				const attack = gameState.currentShootingAttack;
				const wi = attack.currentWeaponIndex;
				const { weapon } = attack.selectedWeapons[wi];
				const hits = attack.weaponResults[wi].hits;
				const target = attack.target;

				// Calculate wound roll needed
				const strength = weapon.strength;
				const toughness = target.toughness;
				let woundTarget;

				if (strength >= toughness * 2) woundTarget = 2;
				else if (strength > toughness) woundTarget = 3;
				else if (strength === toughness) woundTarget = 4;
				else if (strength * 2 <= toughness) woundTarget = 6;
				else woundTarget = 5;

				// --- Transhuman Physiology logic ---
				const defenderPlayerNum = findUnitOwner(target);
				if (checkTranshumanPhysiology(defenderPlayerNum, target.id)) {
					woundTarget = Math.max(woundTarget, 4);
					logEntry(
						"Transhuman Physiology active: can't wound on better than 4+!",
						"stratagem"
					);
				}

				// --- Oath of Moment reroll wounds ---
				const attackerPlayerNum = attack.shooterPlayer;
				let rerollOath = checkOathOfMoment(attackerPlayerNum, target.id);

				const rolls = [];
				let wounds = 0;
				for (let i = 0; i < hits; i++) {
					const roll = Math.floor(Math.random() * 6) + 1;
					rolls.push(roll);
					if (roll >= woundTarget || roll === 6) wounds++;
				}
				// Oath of Moment: reroll all failed wounds
				if (rerollOath) {
					let failed = rolls.filter((r) => r < woundTarget);
					let rerolls = failed.map((_) => Math.floor(Math.random() * 6) + 1);
					let newWounds = rerolls.filter((r) => r >= woundTarget).length;
					wounds += newWounds;
					logEntry(
						`Oath of Moment active: rerolled failed wounds for ${newWounds} more wounds!`,
						"stratagem"
					);
				}

				attack.weaponResults[wi].wounds = wounds;
				attack.weaponResults[wi].woundRolls = rolls;

				updateShootingProgressMulti(
					`
					<div class="roll-result">
						<h4>${weapon.name} — Wound Rolls (${woundTarget}+ to wound)</h4>
						<p>S${strength} vs T${toughness}</p>
						<div class="dice-visual">${rolls
							.map(
								(r) =>
									`<div class="die ${
										r >= woundTarget || r === 6 ? "success" : "fail"
									}">${r}</div>`
							)
							.join("")}</div>
						<p>${wounds} wounds from ${hits} hits</p>
						${
							wounds > 0
								? `<button class="btn btn-small" onclick="rollSavesMulti()">Roll Saves</button>`
								: `<button class="btn btn-secondary btn-small" onclick="advanceWeaponMulti()">No Wounds - Next Weapon</button>`
						}
					</div>
					`,
					wi
				);
			}

			function rollSavesMulti() {
				const attack = gameState.currentShootingAttack;
				const wi = attack.currentWeaponIndex;
				const { weapon } = attack.selectedWeapons[wi];
				const wounds = attack.weaponResults[wi].wounds;
				const target = attack.target;

				// Calculate save
				let saveTarget = target.save - weapon.ap;
				let modifierMsg = "";
				if (
					attack.targetTerrain &&
					attack.targetTerrain.includes("Light Cover")
				) {
					saveTarget -= 1;
					modifierMsg =
						"<span style='color:#ffd700;'>+1 to save due to Light Cover</span>";
				}
				if (target.invulnSave && target.invulnSave < saveTarget) {
					saveTarget = target.invulnSave;
				}

				// --- Armor of Contempt logic ---
				const defenderPlayerNum = findUnitOwner(target);
				if (checkArmorOfContempt(defenderPlayerNum, target.id)) {
					saveTarget -= 1;
					logEntry("Armor of Contempt active: AP reduced by 1!", "stratagem");
				}

				const rolls = [];
				let failedSaves = 0;
				for (let i = 0; i < wounds; i++) {
					const roll = Math.floor(Math.random() * 6) + 1;
					rolls.push(roll);
					if (roll < saveTarget && roll !== 6) {
						failedSaves++;
					}
				}
				attack.weaponResults[wi].saves = failedSaves;
				attack.weaponResults[wi].saveRolls = rolls;

				updateShootingProgressMulti(
					`
					<div class="roll-result">
						<h4>${weapon.name} — Save Rolls (${saveTarget}+ to save) ${modifierMsg}</h4>
						<p>Sv ${target.save}+ with AP-${weapon.ap}${
						target.invulnSave ? ` (${target.invulnSave}++ invuln)` : ""
					}</p>
						<div class="dice-visual">${rolls
							.map(
								(r) =>
									`<div class="die ${
										r >= saveTarget || r === 6 ? "success" : "fail"
									}">${r}</div>`
							)
							.join("")}</div>
						<p>${failedSaves} failed saves from ${wounds} wounds</p>
						${
							failedSaves > 0
								? `<button class="btn btn-small" onclick="rollDamageMulti()">Roll Damage</button>`
								: `<button class="btn btn-secondary btn-small" onclick="advanceWeaponMulti()">All Saved - Next Weapon</button>`
						}
					</div>
					`,
					wi
				);
			}

			function rollDamageMulti() {
				const attack = gameState.currentShootingAttack;
				const wi = attack.currentWeaponIndex;
				const { weapon } = attack.selectedWeapons[wi];
				const saves = attack.weaponResults[wi].saves;

				let totalDamage = 0;
				const damageRolls = [];

				for (let i = 0; i < saves; i++) {
					let damage = weapon.damage;
					if (typeof damage === "string") {
						damage = rollVariableDice(damage);
						damageRolls.push(damage);
					} else {
						totalDamage += damage;
					}
				}

				if (damageRolls.length > 0) {
					totalDamage = damageRolls.reduce((sum, roll) => sum + roll, 0);
				}

				attack.weaponResults[wi].damage = totalDamage;
				attack.weaponResults[wi].damageRolls = damageRolls;

				updateShootingProgressMulti(
					`
					<div class="roll-result">
						<h4>${weapon.name} — Damage</h4>
						<p>Weapon Damage: ${weapon.damage}</p>
						${
							damageRolls.length > 0
								? `<p>Damage rolls: ${damageRolls.join(", ")}</p>`
								: ""
						}
						<p style="font-size: 1.2rem; font-weight: bold;">Total Damage: ${totalDamage}</p>
						<button class="btn" onclick="applyDamageMulti()">Apply Damage</button>
					</div>
					`,
					wi
				);
			}

			// Apply damage for the current weapon and allow moving to the next
			function applyDamageMulti() {
				const attack = gameState.currentShootingAttack;
				const wi = attack.currentWeaponIndex;
				const { weapon } = attack.selectedWeapons[wi];
				const target = attack.target;
				const totalDamage = attack.weaponResults[wi].damage || 0;

				// Apply damage
				target.currentWounds = Math.max(0, target.currentWounds - totalDamage);
				target.damageTaken += totalDamage;

				// Calculate models lost
				const modelsLost = Math.floor(
					(target.maxWounds - target.currentWounds) / target.wounds
				);
				target.currentModels = target.models - modelsLost;

				// Log and show
				if (target.currentWounds === 0) {
					target.status = "destroyed";
					logEntry(
						`${target.name} has been DESTROYED by ${attack.shooter.name}'s ${weapon.name}!`,
						"damage"
					);
				} else {
					logEntry(
						`${target.name} takes ${totalDamage} damage from ${attack.shooter.name}'s ${weapon.name} (${target.currentWounds}/${target.maxWounds} remaining)`,
						"damage"
					);
					// Check for morale if at half strength
					if (
						target.currentModels <= target.models / 2 &&
						target.currentModels > 0
					) {
						logEntry(
							`${target.name} is below half strength - Battle-shock test required!`,
							"morale"
						);
					}
				}

				// Advance to next weapon or finish
				advanceWeaponMulti();
			}

			// Go to next weapon, or finish up modal if done
			function advanceWeaponMulti() {
				const attack = gameState.currentShootingAttack;
				attack.currentWeaponIndex += 1;
				if (attack.currentWeaponIndex < attack.selectedWeapons.length) {
					// More weapons to resolve
					rollToHitMulti();
				} else {
					// All weapons resolved
					attack.shooter.hasShot = true;
					updateDisplay();
					saveGameState();
					updateShootingProgressMulti(
						`
										<div class="roll-result">
											<p>All selected weapons fired.</p>
											<button class="btn" onclick="closeShootingModal()">Close</button>
										</div>
									`,
						attack.selectedWeapons.length - 1
					);
				}
			}

			// Updates the modal content for the current weapon
			function updateShootingProgressMulti(innerHtml, wi) {
				// Render all previous weapons as collapsed, current as open
				const attack = gameState.currentShootingAttack;
				let html = "";
				attack.selectedWeapons.forEach((sw, idx) => {
					if (idx < wi) {
						html += `<div class="roll-result"><h4>${sw.weapon.name} — Done</h4></div>`;
					} else if (idx === wi) {
						html += innerHtml;
					}
				});
				document.getElementById("shootingProgress").innerHTML = html;
			}

			function processDamage(input, playerNum) {
				const match = input.match(
					/(.+?)\s+(?:takes?|suffers?|loses?)\s+(\d+)\s*(?:wounds?|damage)?/i
				);

				if (match) {
					const unitName = match[1].trim();
					const damage = parseInt(match[2]);

					const unit = findUnit(unitName, playerNum);
					if (unit && unit.status !== "destroyed") {
						unit.currentWounds = Math.max(0, unit.currentWounds - damage);
						unit.damageTaken = (unit.damageTaken || 0) + damage;

						// Calculate models lost
						const modelsLost = Math.floor(
							(unit.maxWounds - unit.currentWounds) / unit.wounds
						);
						unit.currentModels = unit.models - modelsLost;

						if (unit.currentWounds === 0) {
							unit.status = "destroyed";
							logEntry(`${unit.name} has been DESTROYED!`, "damage");
						} else {
							logEntry(
								`${unit.name} takes ${damage} damage (${unit.currentWounds}/${unit.maxWounds} remaining)`,
								"damage"
							);
							// Check for morale
							if (
								unit.currentModels < unit.startingStrength &&
								unit.currentModels > 0
							) {
								logEntry(
									`${unit.name} is below starting strength - Battle-shock test may be required!`,
									"morale"
								);
							}
						}
					}
				}
			}

			function processHealing(input, playerNum) {
				const match = input.match(
					/(.+?)\s+(?:heals?|regains?|restores?)\s+(\d+)\s*(?:wounds?)?/i
				);

				if (match) {
					const unitName = match[1].trim();
					const healing = parseInt(match[2]);

					const unit = findUnit(unitName, playerNum);
					if (unit && unit.status !== "destroyed") {
						const actualHealing = Math.min(
							healing,
							unit.maxWounds - unit.currentWounds
						);
						unit.currentWounds += actualHealing;

						logEntry(
							`${unit.name} heals ${actualHealing} wounds (${unit.currentWounds}/${unit.maxWounds})`,
							"heal"
						);
					}
				}
			}

			function processCP(input, playerNum, action) {
				const match = input.match(/(\d+)\s*cp/i);
				const amount = match ? parseInt(match[1]) : 1;

				if (action === "spend") {
					if (gameState.players[playerNum].cp >= amount) {
						gameState.players[playerNum].cp -= amount;
						logEntry(
							`${gameState.players[playerNum].name} spends ${amount} CP (${gameState.players[playerNum].cp} remaining)`,
							"stratagem"
						);
					} else {
						logEntry(
							`Insufficient CP! ${gameState.players[playerNum].name} has only ${gameState.players[playerNum].cp} CP`,
							"error"
						);
					}
				} else {
					gameState.players[playerNum].cp += amount;
					logEntry(
						`${gameState.players[playerNum].name} gains ${amount} CP (${gameState.players[playerNum].cp} total)`,
						"system"
					);
				}
			}

			function processVP(input, playerNum) {
				const match = input.match(/(\d+)\s*(?:vp|victory|points?)/i);
				const amount = match ? parseInt(match[1]) : 1;

				gameState.players[playerNum].vp += amount;
				logEntry(
					`${gameState.players[playerNum].name} scores ${amount} VP (${gameState.players[playerNum].vp} total)`,
					"objective"
				);
			}

			function processStratagem(input, playerNum) {
				const stratagemName = input.replace(/use\s+/i, "").trim();
				gameState.players[playerNum].stratagems.push({
					name: stratagemName,
					phase: gameState.currentPhase,
					turn: gameState.currentTurn,
				});

				logEntry(
					`${gameState.players[playerNum].name} uses stratagem: ${stratagemName}`,
					"stratagem"
				);
			}

			function processBuff(input, playerNum) {
				// Try to parse a duration phrase (defaults to "turn" if not specified)
				const durationMatch = input.match(/until end of (phase|turn)/i);
				let duration = "turn";
				if (durationMatch) {
					duration = durationMatch[1].toLowerCase();
				}

				// Parse: "[unit] gets [buff] [until end of ...]"
				const match = input.match(/(.+?)\s+gets?\s+(.+?)(?:\s+until.+)?$/i);
				if (match) {
					const unitName = match[1].trim();
					const buffDescription = match[2].trim();

					const unit = findUnit(unitName, playerNum);
					if (unit) {
						if (!unit.buffs) unit.buffs = [];
						unit.buffs.push({
							name: buffDescription,
							appliedTurn: gameState.currentTurn,
							appliedPhase: gameState.currentPhase,
							duration: duration, // 'phase' or 'turn'
						});
						logEntry(
							`${unit.name} gains buff: ${buffDescription} (until end of ${duration})`,
							"buff"
						);
					}
				}
			}

			function findUnitAnyPlayer(unitName) {
				// Try Player 1 first
				let found = findUnit(unitName, 1);
				if (found) return found;
				// Then Player 2
				return findUnit(unitName, 2);
			}

			function findUnit(unitName, playerNum) {
				const units = gameState.players[playerNum].units;
				return units.find(
					(unit) =>
						unit.name.toLowerCase().includes(unitName.toLowerCase()) ||
						unitName.toLowerCase().includes(unit.name.toLowerCase())
				);
			}

			// Quick Actions
			function quickAction(playerNum, action) {
				switch (action) {
					case "spend-cp":
						processCP("spend 1 CP", playerNum, "spend");
						break;
					case "gain-vp":
						processVP("score 1 VP", playerNum);
						break;
				}
				updateDisplay();
				saveGameState();
			}

			// Dice Rolling
			function rollDice(inputOverride = null) {
				const input =
					inputOverride || document.getElementById("diceInput").value.trim();
				if (!input) return;

				let numDice = 1;
				let diceType = 6;
				let modifier = 0;

				// Parse various dice notations
				const diceMatch = input.match(/(\d+)?d(\d+)([+-]\d+)?/i);
				const rollMatch = input.match(/roll\s+(\d+)/i);

				if (diceMatch) {
					numDice = parseInt(diceMatch[1]) || 1;
					diceType = parseInt(diceMatch[2]);
					modifier = diceMatch[3] ? parseInt(diceMatch[3]) : 0;
				} else if (rollMatch) {
					numDice = parseInt(rollMatch[1]);
				} else {
					const simpleMatch = input.match(/(\d+)/);
					if (simpleMatch) {
						numDice = parseInt(simpleMatch[1]);
					}
				}

				// Roll the dice
				const rolls = [];
				let total = 0;

				for (let i = 0; i < numDice; i++) {
					const roll = Math.floor(Math.random() * diceType) + 1;
					rolls.push(roll);
					total += roll;
				}

				total += modifier;

				// Display results
				const resultsDiv = document.getElementById("diceResults");
				let html = '<div class="dice-visual">';

				rolls.forEach((roll) => {
					let dieClass = "die";
					if (diceType === 6) {
						if (roll >= 5) dieClass += " success";
						else if (roll === 1) dieClass += " fail";
					}
					html += `<div class="${dieClass}">${roll}</div>`;
				});

				html += "</div>";
				html += `<div style="text-align: center; margin-top: 1rem;">`;
				html += `<div style="font-size: 1.2rem; font-weight: bold;">Total: ${total}</div>`;

				if (modifier !== 0) {
					html += `<div style="font-size: 0.9rem; color: #888;">Base: ${
						total - modifier
					} ${modifier > 0 ? "+" : ""}${modifier}</div>`;
				}

				// Count successes for d6 rolls
				if (diceType === 6) {
					const successes = rolls.filter((r) => r >= 4).length;
					const sixes = rolls.filter((r) => r === 6).length;
					html += `<div style="margin-top: 0.5rem; font-size: 0.9rem;">`;
					html += `Successes (4+): ${successes}<br>`;
					if (sixes > 0) html += `Natural 6s: ${sixes}`;
					html += `</div>`;
				}

				html += "</div>";
				resultsDiv.innerHTML = html;

				// Log the roll
				logEntry(
					`Dice Roll: ${numDice}d${diceType}${
						modifier !== 0 ? (modifier > 0 ? "+" : "") + modifier : ""
					} = [${rolls.join(", ")}] = ${total}`,
					"dice"
				);

				// Clear input
				document.getElementById("diceInput").value = "";
			}

			function rollDiceFor(playerNum) {
				const input = prompt(
					`Enter dice to roll for ${gameState.players[playerNum].name}:`,
					"2d6"
				);
				if (input) {
					rollDice(input);
				}
			}

			// Phase Management
			function nextPhase() {
				const currentIndex = gameState.phases.indexOf(gameState.currentPhase);

				if (currentIndex < gameState.phases.length - 1) {
					gameState.currentPhase = gameState.phases[currentIndex + 1];
					logEntry(
						`Entering ${gameState.currentPhase.toUpperCase()} PHASE`,
						"phase"
					);

					// Phase-specific actions
					handlePhaseStart();
				} else {
					endTurn();
				}

				updateDisplay();
				saveGameState();
			}

			function handlePhaseStart() {
				// Remove phase-duration buffs
				[1, 2].forEach((playerNum) => {
					gameState.players[playerNum].units.forEach((unit) => {
						if (!unit.buffs) unit.buffs = [];
						unit.buffs = unit.buffs.filter((buff) => {
							// Remove "phase" buffs applied in the *previous* phase
							if (
								buff.duration === "phase" &&
								buff.appliedPhase !== gameState.currentPhase
							) {
								logEntry(`${unit.name} loses buff: ${buff.name}`, "system");
								return false;
							}
							return true;
						});
					});
				});

				switch (gameState.currentPhase) {
					case "command":
						// Clear Battle-shocked status for active player
						let clearedCount = 0;
						gameState.players[gameState.activePlayer].units.forEach((unit) => {
							if (unit.battleshocked) {
								unit.battleshocked = false;
								clearedCount++;
								logEntry(
									`${unit.name} recovers from being Battle-shocked`,
									"system"
								);
							}
						});

						if (clearedCount > 0) {
							logEntry(
								`${clearedCount} unit(s) recovered from Battle-shock`,
								"system"
							);
						}

						// Existing CP gain
						gameState.players[gameState.activePlayer].cp += 1;
						logEntry(
							`${
								gameState.players[gameState.activePlayer].name
							} gains 1 CP in Command Phase`,
							"system"
						);
						break;

					case "movement":
						logEntry(
							"Units may now move up to their Movement characteristic",
							"system"
						);
						break;

					case "shooting":
						logEntry("Eligible units may now make ranged attacks", "system");
						// Reset shooting flags for active player
						gameState.players[gameState.activePlayer].units.forEach((unit) => {
							unit.hasShot = false;
						});
						break;

					case "charge":
						logEntry(
							"Eligible units may attempt to charge enemy units",
							"system"
						);
						// Reset charge flags for active player's units
						gameState.players[gameState.activePlayer].units.forEach((unit) => {
							unit.hasCharged = false;
						});
						break;

					case "fight":
						logEntry(
							"Units in engagement range make close combat attacks",
							"system"
						);
						// Reset fight flags
						gameState.players[gameState.activePlayer].units.forEach((unit) => {
							unit.hasFought = false;
						});
						break;

					case "morale":
						logEntry(
							"Check for Battle-shock tests on units below half strength",
							"system"
						);
						checkMorale();
						break;
				}
			}

			// Check which units need Battle-shock tests
			function checkMorale() {
				const unitsNeedingTests = [];

				[1, 2].forEach((playerNum) => {
					gameState.players[playerNum].units.forEach((unit) => {
						if (
							unit.status === "active" &&
							unit.currentModels < unit.startingStrength &&
							unit.currentModels > 0 &&
							!unit.battleshocked
						) {
							unitsNeedingTests.push({ unit, playerNum });
						}
					});
				});

				if (unitsNeedingTests.length > 0) {
					logEntry(
						"Units below Starting Strength must take Battle-shock tests!",
						"morale"
					);
					// Process tests one by one
					processMoraleTests(unitsNeedingTests);
				} else {
					logEntry("No Battle-shock tests required this phase", "morale");
				}
			}

			function processMoraleTests(unitsNeedingTests) {
				moraleTestQueue = [...unitsNeedingTests];
				processNextMoraleTest();
			}

			function processNextMoraleTest() {
				if (moraleTestQueue.length === 0) {
					updateDisplay();
					saveGameState();
					return;
				}

				currentMoraleTest = moraleTestQueue.shift();
				showMoraleModal(currentMoraleTest.unit, currentMoraleTest.playerNum);
			}

			// Show the morale test modal
			function showMoraleModal(unit, playerNum) {
				const modal = document.getElementById("moraleModal");
				const content = document.getElementById("moraleTestContent");

				const modelsLost = unit.startingStrength - unit.currentModels;
				const percentLost = Math.round(
					(modelsLost / unit.startingStrength) * 100
				);

				content.innerHTML = `
									<div class="test-info">
										<h3>${unit.name}</h3>
										<p>Current Strength: ${unit.currentModels}/${
					unit.startingStrength
				} models (${percentLost}% casualties)</p>
										<p>Leadership: ${unit.leadership}+</p>
										${
											unit.battleshockModifier !== 0
												? `<p style="color: #ffa500;">Modifier: ${
														unit.battleshockModifier > 0 ? "+" : ""
												  }${unit.battleshockModifier}</p>`
												: ""
										}
										<p style="margin-top: 1rem;">Unit must roll 2D6 and score ${
											unit.leadership
										} or higher to pass.</p>
									</div>
									<div style="text-align: center; margin-top: 1.5rem;">
										<button class="btn" onclick="rollBattleshockTest()">Roll Battle-shock Test</button>
										<button class="btn btn-secondary" onclick="skipBattleshockTest()">Skip (Auto-fail)</button>
									</div>
									<div id="moraleTestResult"></div>
									`;

				modal.style.display = "block";
			}

			// Roll the Battle-shock test
			function rollBattleshockTest() {
				const unit = currentMoraleTest.unit;
				const playerNum = currentMoraleTest.playerNum;

				// Roll 2D6
				const die1 = Math.floor(Math.random() * 6) + 1;
				const die2 = Math.floor(Math.random() * 6) + 1;
				const baseRoll = die1 + die2;
				const modifiedRoll = baseRoll + (unit.battleshockModifier || 0);
				const target = unit.leadership;
				const passed = modifiedRoll >= target;

				// Update UI
				const resultDiv = document.getElementById("moraleTestResult");
				resultDiv.innerHTML = `
									<div class="test-result ${passed ? "passed" : "failed"}">
										<div class="dice-visual" style="justify-content: center; margin-bottom: 1rem;">
											<div class="die">${die1}</div>
											<div class="die">${die2}</div>
										</div>
										<p style="font-size: 1.2rem;">
											Roll: ${baseRoll}
											${
												(unit.battleshockModifier || 0) !== 0
													? ` ${
															(unit.battleshockModifier || 0) > 0 ? "+" : ""
													  }${unit.battleshockModifier} = ${modifiedRoll}`
													: ""
											}
										</p>
										<p style="font-size: 1.4rem; font-weight: bold; margin-top: 0.5rem;">
											${passed ? "✅ PASSED!" : "❌ FAILED!"}
										</p>
										${
											!passed
												? '<p style="color: #ff00ff; margin-top: 0.5rem;">Unit is Battle-shocked!</p>'
												: ""
										}
									</div>
									<div style="text-align: center; margin-top: 1rem;">
										<button class="btn" onclick="closeMoraleModal()">Continue</button>
									</div>
									`;

				// Apply results
				if (!passed) {
					unit.battleshocked = true;
					logEntry(
						`${unit.name} fails Battle-shock test (rolled ${modifiedRoll}, needed ${target}) and is Battle-shocked!`,
						"morale"
					);
				} else {
					logEntry(
						`${unit.name} passes Battle-shock test (rolled ${modifiedRoll}, needed ${target})`,
						"morale"
					);
				}

				updateDisplay();
				saveGameState();
			}

			// Skip test (auto-fail)
			function skipBattleshockTest() {
				const unit = currentMoraleTest.unit;
				unit.battleshocked = true;
				logEntry(
					`${unit.name} automatically fails Battle-shock test and is Battle-shocked!`,
					"morale"
				);
				closeMoraleModal();
			}

			// Close morale modal and continue
			function closeMoraleModal() {
				document.getElementById("moraleModal").style.display = "none";
				processNextMoraleTest();
			}

			function endTurn() {
				// Clear charges for the turn
				clearEngagements();

				// Remove turn-duration buffs
				[1, 2].forEach((playerNum) => {
					gameState.players[playerNum].units.forEach((unit) => {
						if (!unit.buffs) unit.buffs = [];
						unit.buffs = unit.buffs.filter((buff) => {
							// Remove "turn" buffs applied before this turn
							if (
								buff.duration === "turn" &&
								buff.appliedTurn < gameState.currentTurn
							) {
								logEntry(`${unit.name} loses buff: ${buff.name}`, "system");
								return false;
							}
							return true;
						});
					});
				});

				// Switch active player
				gameState.activePlayer = gameState.activePlayer === 1 ? 2 : 1;

				// If back to player 1, increment turn
				if (gameState.activePlayer === 1) {
					gameState.currentTurn++;
				}

				// Reset to Command Phase
				gameState.currentPhase = "command";

				logEntry(
					`--- TURN ${gameState.currentTurn} - ${
						gameState.players[gameState.activePlayer].name
					}'s turn begins ---`,
					"turn"
				);

				handlePhaseStart();
				updateDisplay();
				saveGameState();
			}

			// --- OBJECTIVES MODULE ---

			// List of possible terrain tags (edit as needed)
			const terrainTags = [
				"",
				"Light Cover",
				"Heavy Cover",
				"Dense Cover",
				"Obscuring",
				"Inspiring",
			];

			function renderObjectivesList() {
				const list = document.getElementById("objectivesList");
				if (!list) return;

				list.innerHTML = "";

				gameState.objectives.forEach((obj, i) => {
					let players = [
						`<option value="">Uncontrolled</option>`,
						`<option value="1"${obj.controlledBy === 1 ? " selected" : ""}>${
							gameState.players[1].name
						}</option>`,
						`<option value="2"${obj.controlledBy === 2 ? " selected" : ""}>${
							gameState.players[2].name
						}</option>`,
					].join("");
					let terrains = terrainTags
						.map(
							(tag) =>
								`<option value="${tag}"${
									obj.terrain === tag ? " selected" : ""
								}>${tag}</option>`
						)
						.join("");

					list.innerHTML += `
											  <div class="objective-card">
												<div style="font-weight:bold">${obj.name}</div>
												<div>
												  <label style="color:#ffd700;">Control: </label>
												  <select class="objective-control-select" onchange="setObjectiveControl(${i}, this.value)">
													${players}
												  </select>
												  <label style="color:#ffd700;">Terrain: </label>
												  <select class="objective-terrain-select" onchange="setObjectiveTerrain(${i}, this.value)">
													${terrains}
												  </select>
												</div>
												<div>
												  <label style="color:#ffd700;">VP: </label>
												  <input type="number" min="0" value="${
														obj.vp || 0
													}" style="width:50px;" onchange="setObjectiveVP(${i}, this.value)" />
												</div>
												<div>
												  <input type="text" placeholder="Add note..." value="${
														obj.notes || ""
													}" style="width:75%;" onblur="setObjectiveNote(${i}, this.value)" />
												</div>
												<button class="btn btn-secondary btn-small" onclick="removeObjective(${i})">Remove</button>
											  </div>
											`;
				});
			}

			function addObjective() {
				let n = gameState.objectives.length + 1;
				gameState.objectives.push({
					id: n,
					name: `Objective ${n}`,
					controlledBy: null,
					terrain: "",
					notes: "",
					vp: 0,
				});
				renderObjectivesList();
				saveGameState();
			}

			function removeObjective(idx) {
				if (confirm("Remove this objective?")) {
					gameState.objectives.splice(idx, 1);
					renderObjectivesList();
					saveGameState();
				}
			}

			function setObjectiveControl(idx, val) {
				if (val) {
					// Check if controlling player has any non-battleshocked units
					const hasValidUnits = gameState.players[val].units.some(
						(u) => u.status === "active" && !u.battleshocked
					);
					if (!hasValidUnits) {
						alert("Battle-shocked units cannot control objectives!");
						return;
					}
				}
				gameState.objectives[idx].controlledBy = val ? Number(val) : null;
				logEntry(
					`${gameState.objectives[idx].name} is now controlled by ${
						val ? gameState.players[val].name : "no one"
					}`,
					"objective"
				);
				renderObjectivesList();
				saveGameState();
			}

			function setObjectiveTerrain(idx, val) {
				gameState.objectives[idx].terrain = val;
				logEntry(
					`${gameState.objectives[idx].name} terrain set to: ${val || "None"}`,
					"system"
				);
				renderObjectivesList();
				saveGameState();
			}

			function setObjectiveNote(idx, val) {
				gameState.objectives[idx].notes = val;
				renderObjectivesList();
				saveGameState();
			}

			function setObjectiveVP(idx, val) {
				gameState.objectives[idx].vp = Number(val) || 0;
				renderObjectivesList();
				saveGameState();
			}

			// Process charge declarations
			function processCharge(input, playerNum) {
				if (gameState.currentPhase !== "charge") {
					logEntry(
						"Charge declarations can only be made in the Charge phase!",
						"error"
					);
					return;
				}

				const match = input.match(/(.+?)\s+charges?\s+(.+)/i);
				if (match) {
					const chargingUnitName = match[1].trim();
					const targetNames = match[2].split(/\s+and\s+|\s*,\s*/i); // Support multiple targets

					const chargingUnit = findUnit(chargingUnitName, playerNum);
					if (!chargingUnit) {
						logEntry(`Unit "${chargingUnitName}" not found`, "error");
						return;
					}

					if (chargingUnit.hasCharged) {
						logEntry(
							`${chargingUnit.name} has already charged this turn!`,
							"error"
						);
						return;
					}

					if (chargingUnit.status === "destroyed") {
						logEntry(
							`${chargingUnit.name} is destroyed and cannot charge!`,
							"error"
						);
						return;
					}

					// Find all target units
					const targets = [];
					for (const targetName of targetNames) {
						const target = findUnitAnyPlayer(targetName.trim());
						if (target) {
							targets.push(target);
						} else {
							logEntry(`Target unit "${targetName}" not found`, "error");
							return;
						}
					}

					// Start charge sequence
					startChargeSequence(chargingUnit, targets, playerNum);
				} else {
					logEntry(
						"Invalid charge command. Use format: '[Unit] charges [Target(s)]'",
						"error"
					);
				}
			}

			// Start the charge sequence
			function startChargeSequence(chargingUnit, targets, playerNum) {
				currentChargeAttempt = {
					chargingUnit: chargingUnit,
					targets: targets,
					playerNum: playerNum,
					overwatchUsed: [],
					chargeDistance: null,
					chargeRoll: null,
					requiredDistance: 12, // Max charge range
					success: false,
				};

				logEntry(
					`${chargingUnit.name} declares a charge against ${targets
						.map((t) => t.name)
						.join(" and ")}!`,
					"charge"
				);

				// Show charge modal
				showChargeModal();
			}

			// Show the charge modal
			function showChargeModal() {
				const modal = document.getElementById("chargeModal");
				const content = document.getElementById("chargeContent");
				const attempt = currentChargeAttempt;

				let html = `
									<div class="charge-step">
										<h3>Charging Unit: ${attempt.chargingUnit.name}</h3>
										<p>Target${attempt.targets.length > 1 ? "s" : ""}: ${attempt.targets
					.map((t) => t.name)
					.join(", ")}</p>

										<div class="charge-info">
											<p>⚡ Charge Range: 12"</p>
											<p>📏 Required Distance: ${
												attempt.requiredDistance
											}" (would be calculated based on positions)</p>
											${
												attempt.chargingUnit.battleshocked
													? '<p style="color: #ff00ff;">⚠️ Unit is Battle-shocked (-2" to charge roll)</p>'
													: ""
											}
										</div>

										<div id="chargeProgress">
											${attempt.targets
												.map(
													(target, idx) => `
												<div class="overwatch-option" id="overwatch-${idx}">
													<h4>${target.name} - Overwatch Opportunity</h4>
													<p>Cost: 1 CP (Hits on 6s only)</p>
													<button class="btn btn-small" onclick="declareOverwatch(${idx})">Use Overwatch</button>
													<button class="btn btn-secondary btn-small" onclick="skipOverwatch(${idx})">Skip</button>
												</div>
											`
												)
												.join("")}
										</div>

										<div style="text-align: center; margin-top: 1rem;">
											<button class="btn btn-secondary" onclick="cancelCharge()">Cancel Charge</button>
										</div>
									</div>
									`;

				content.innerHTML = html;
				modal.style.display = "block";
			}

			// Handle Overwatch declaration
			function declareOverwatch(targetIndex) {
				const attempt = currentChargeAttempt;
				const target = attempt.targets[targetIndex];
				const targetPlayer = findUnitOwner(target);

				if (gameState.players[targetPlayer].cp < 1) {
					alert(
						`${gameState.players[targetPlayer].name} doesn't have enough CP for Overwatch!`
					);
					return;
				}

				// Deduct CP
				gameState.players[targetPlayer].cp -= 1;
				logEntry(
					`${gameState.players[targetPlayer].name} spends 1 CP for Overwatch with ${target.name}`,
					"stratagem"
				);

				// Mark overwatch used
				attempt.overwatchUsed.push(targetIndex);

				// Start overwatch shooting
				startOverwatchSequence(target, attempt.chargingUnit, targetIndex);
			}

			// Skip overwatch for a target
			function skipOverwatch(targetIndex) {
				const overwatchDiv = document.getElementById(
					`overwatch-${targetIndex}`
				);
				overwatchDiv.innerHTML = `<p style="color: #888;">${currentChargeAttempt.targets[targetIndex].name} - Overwatch declined</p>`;

				checkAllOverwatchResolved();
			}

			// Check if all overwatch decisions are made
			function checkAllOverwatchResolved() {
				const attempt = currentChargeAttempt;
				const allResolved = attempt.targets.every((_, idx) => {
					const div = document.getElementById(`overwatch-${idx}`);
					return (
						div.innerHTML.includes("declined") ||
						div.innerHTML.includes("completed") ||
						attempt.overwatchUsed.includes(idx)
					);
				});

				if (allResolved) {
					// Proceed to charge roll
					showChargeRoll();
				}
			}

			// Start Overwatch shooting sequence
			function startOverwatchSequence(shooter, target, overwatchIndex) {
				const progress = document.getElementById(`overwatch-${overwatchIndex}`);

				// Get ranged weapons
				let weaponChoices = [];
				if (shooter.weaponConfig) {
					for (const [weaponKey, count] of Object.entries(
						shooter.weaponConfig
					)) {
						const weapon = weaponProfiles[weaponKey];
						if (weapon && weapon.range !== "Melee" && count > 0) {
							weaponChoices.push({ weaponKey, weapon, count });
						}
					}
				}

				if (weaponChoices.length === 0) {
					progress.innerHTML = `<p style="color: #888;">${shooter.name} has no ranged weapons for Overwatch</p>`;
					checkAllOverwatchResolved();
					return;
				}

				// Simplified overwatch UI
				progress.innerHTML = `
									<div class="overwatch-shooting">
										<h4>${shooter.name} - Overwatch Fire!</h4>
										<p style="color: #ffa500;">⚠️ Overwatch hits only on 6s</p>
										<p>Select weapon for Overwatch:</p>
										<select id="overwatchWeapon-${overwatchIndex}" style="margin-bottom: 0.5rem;">
											${weaponChoices
												.map(
													(w) =>
														`<option value="${w.weaponKey}">${w.weapon.name} (${w.weapon.attacks} attacks)</option>`
												)
												.join("")}
										</select>
										<br>
										<button class="btn btn-small" onclick="rollOverwatchHits(${overwatchIndex})">Roll to Hit</button>
									</div>
									`;
			}

			// Skip charge declaration
			function skipCharge() {
				logEntry(
					`${currentChargeAttempt.chargingUnit.name} charge declaration skipped`,
					"system"
				);
				closeChargeModal();
			}

			// Roll Overwatch hits
			function rollOverwatchHits(overwatchIndex) {
				const attempt = currentChargeAttempt;
				const shooter = attempt.targets[overwatchIndex];
				const target = attempt.chargingUnit;
				const weaponKey = document.getElementById(
					`overwatchWeapon-${overwatchIndex}`
				).value;
				const weapon = weaponProfiles[weaponKey];

				// Calculate attacks
				let numAttacks = weapon.attacks;
				if (typeof numAttacks === "string") {
					numAttacks = rollVariableDice(numAttacks);
				}
				const modelsFiring = shooter.currentModels || shooter.models;
				numAttacks *= modelsFiring;

				// Roll dice - only hit on 6s
				const rolls = [];
				let hits = 0;
				for (let i = 0; i < numAttacks; i++) {
					const roll = Math.floor(Math.random() * 6) + 1;
					rolls.push(roll);
					if (roll === 6) hits++;
				}

				const progress = document.getElementById(`overwatch-${overwatchIndex}`);
				progress.innerHTML += `
									<div class="roll-result" style="margin-top: 1rem;">
										<h5>Overwatch Hit Rolls (6s to hit)</h5>
										<div class="dice-visual">${rolls
											.map(
												(r) =>
													`<div class="die ${
														r === 6 ? "success" : "fail"
													}">${r}</div>`
											)
											.join("")}</div>
										<p>${hits} hits from ${numAttacks} shots</p>
										${
											hits > 0
												? `<button class="btn btn-small" onclick="resolveOverwatchDamage(${overwatchIndex}, ${hits}, '${weaponKey}')">Continue</button>`
												: `<button class="btn btn-small" onclick="completeOverwatch(${overwatchIndex})">No Hits - Continue</button>`
										}
									</div>
									`;
			}

			// Resolve overwatch damage (simplified)
			function resolveOverwatchDamage(overwatchIndex, hits, weaponKey) {
				const weapon = weaponProfiles[weaponKey];
				const target = currentChargeAttempt.chargingUnit;

				// For simplicity, auto-resolve wounds and saves
				logEntry(
					`Overwatch fire: Resolve ${hits} hit(s) with ${weapon.name} against ${target.name}`,
					"shooting"
				);
				logEntry(
					`Players should now roll to wound and save for Overwatch fire`,
					"system"
				);

				completeOverwatch(overwatchIndex);
			}

			// Complete overwatch for this target
			function completeOverwatch(overwatchIndex) {
				const progress = document.getElementById(`overwatch-${overwatchIndex}`);
				progress.innerHTML = `<p style="color: #00ff00;">✓ ${currentChargeAttempt.targets[overwatchIndex].name} - Overwatch completed</p>`;
				checkAllOverwatchResolved();
			}

			// Show charge roll interface
			function showChargeRoll() {
				const attempt = currentChargeAttempt;
				const progress = document.getElementById("chargeProgress");

				progress.innerHTML = `
									<div class="charge-roll-section">
										<h3>🎲 Charge Roll Required</h3>
										<p>Roll 2D6 to determine charge distance</p>
										<p>You need ${attempt.requiredDistance}" or more to make the charge</p>
										${
											attempt.chargingUnit.battleshocked
												? '<p style="color: #ff00ff;">Remember: -2" for being Battle-shocked</p>'
												: ""
										}

										<div style="text-align: center; margin-top: 1rem;">
											<button class="btn" onclick="makeChargeRoll()">Roll 2D6</button>
										</div>

										<div id="chargeRollResult"></div>
									</div>
									`;
			}

			// Make the charge roll
			function makeChargeRoll() {
				const attempt = currentChargeAttempt;

				// Roll 2D6
				const die1 = Math.floor(Math.random() * 6) + 1;
				const die2 = Math.floor(Math.random() * 6) + 1;
				let chargeDistance = die1 + die2;

				// Apply modifiers
				let modifier = 0;
				let modifierText = "";
				if (attempt.chargingUnit.battleshocked) {
					modifier -= 2;
					modifierText = " -2 (Battle-shocked)";
				}

				const modifiedDistance = Math.max(0, chargeDistance + modifier);
				attempt.chargeRoll = chargeDistance;
				attempt.chargeDistance = modifiedDistance;
				attempt.success = modifiedDistance >= attempt.requiredDistance;

				const resultDiv = document.getElementById("chargeRollResult");
				resultDiv.innerHTML = `
									<div class="roll-result ${
										attempt.success ? "charge-success" : "charge-failed"
									}">
										<div class="dice-visual" style="justify-content: center;">
											<div class="die">${die1}</div>
											<div class="die">${die2}</div>
										</div>
										<p style="font-size: 1.2rem;">
											Roll: ${chargeDistance}"${modifierText}
											${modifier !== 0 ? ` = ${modifiedDistance}"` : ""}

										</p>
										<p style="font-size: 1.4rem; font-weight: bold;">
											${attempt.success ? "⚔️ CHARGE SUCCESSFUL!" : "❌ CHARGE FAILED!"}
										</p>
										<div style="margin-top: 1rem;">
											<button class="btn" onclick="resolveCharge()">Continue</button>
										</div>
									</div>
									`;

				// Log the result
				logEntry(
					`${attempt.chargingUnit.name} charges ${modifiedDistance}" (rolled ${chargeDistance}${modifierText})`,
					"charge"
				);
			}

			// Resolve the charge
			function resolveCharge() {
				const attempt = currentChargeAttempt;

				if (attempt.success) {
					// Mark unit as having charged
					attempt.chargingUnit.hasCharged = true;
					attempt.chargingUnit.madeChargeThisTurn = true;
					attempt.chargingUnit.chargedOnTurn = gameState.currentTurn;

					// Set up engagement
					if (!attempt.chargingUnit.engagedWith) {
						attempt.chargingUnit.engagedWith = [];
					}

					attempt.targets.forEach((target) => {
						// Add to engaged lists
						if (!attempt.chargingUnit.engagedWith.includes(target.id)) {
							attempt.chargingUnit.engagedWith.push(target.id);
						}

						if (!target.engagedWith) {
							target.engagedWith = [];
						}
						if (!target.engagedWith.includes(attempt.chargingUnit.id)) {
							target.engagedWith.push(attempt.chargingUnit.id);
						}

						logEntry(
							`${attempt.chargingUnit.name} is now engaged with ${target.name}`,
							"charge"
						);
					});

					logEntry(
						`${attempt.chargingUnit.name} successfully completes the charge!`,
						"charge"
					);
				} else {
					logEntry(
						`${attempt.chargingUnit.name} fails the charge and remains stationary`,
						"charge"
					);
				}

				closeChargeModal();
				updateDisplay();
				saveGameState();
			}

			// Cancel charge
			function cancelCharge() {
				logEntry(
					`${currentChargeAttempt.chargingUnit.name} cancels the charge attempt`,
					"system"
				);
				closeChargeModal();
			}

			// Close charge modal
			function closeChargeModal() {
				document.getElementById("chargeModal").style.display = "none";
				currentChargeAttempt = null;
			}

			// Find which player owns a unit
			function findUnitOwner(unit) {
				for (let playerNum = 1; playerNum <= 2; playerNum++) {
					if (
						gameState.players[playerNum].units.find((u) => u.id === unit.id)
					) {
						return playerNum;
					}
				}
				return null;
			}

			// Helper to find unit by ID
			function findUnitById(unitId) {
				for (let playerNum = 1; playerNum <= 2; playerNum++) {
					const unit = gameState.players[playerNum].units.find(
						(u) => u.id === unitId
					);
					if (unit) return unit;
				}
				return null;
			}

			// Clear engagement at start of turn
			function clearEngagements() {
				[1, 2].forEach((playerNum) => {
					gameState.players[playerNum].units.forEach((unit) => {
						unit.hasCharged = false;
						if (
							unit.madeChargeThisTurn &&
							gameState.currentTurn !== unit.chargedOnTurn
						) {
							unit.madeChargeThisTurn = false;
						}
					});
				});
			}

			// Helper function for variable dice
			function rollVariableDice(diceString) {
				if (diceString === "D3") return Math.floor(Math.random() * 3) + 1;
				if (diceString === "D6") return Math.floor(Math.random() * 6) + 1;
				if (diceString.includes("D6+")) {
					const modifier = parseInt(diceString.split("+")[1]);
					const rolls = Math.floor(Math.random() * 6) + 1;
					return rolls + modifier;
				}
				return parseInt(diceString) || 1;
			}

			// Process various natural language inputs
			function processDiceRoll(input, playerNum) {
				const match = input.match(/roll\s+(.+)/i);
				if (match) {
					rollDice(match[1]);
				}
			}

			// Logging
			function logEntry(message, type = "normal") {
				const timestamp = new Date().toLocaleTimeString();
				const phase = gameState.currentPhase;

				const entry = {
					timestamp,
					turn: gameState.currentTurn,
					phase,
					message,
					type,
				};

				gameState.log.push(entry);

				const logDiv = document.getElementById("gameLog");
				if (!logDiv) return;

				const entryDiv = document.createElement("div");
				entryDiv.className = "log-entry";

				let messageClass = "";
				if (type === "damage") messageClass = "log-damage";
				else if (type === "heal") messageClass = "log-heal";
				else if (type === "stratagem") messageClass = "log-stratagem";
				else if (type === "phase") messageClass = "log-phase";
				else if (type === "shooting") messageClass = "log-shooting";
				else if (type === "morale") messageClass = "log-morale";
				else if (type === "charge") messageClass = "log-charge";

				entryDiv.innerHTML = `
														<div class="log-timestamp">Turn ${entry.turn} - ${
					phase.charAt(0).toUpperCase() + phase.slice(1)
				} - ${timestamp}</div>
														<div class="${messageClass}">${message}</div>
													`;

				logDiv.appendChild(entryDiv);
				logDiv.scrollTop = logDiv.scrollHeight;
			}

			function clearLog() {
				if (confirm("Clear the battle log? This cannot be undone.")) {
					gameState.log = [];
					const logDiv = document.getElementById("gameLog");
					if (logDiv) logDiv.innerHTML = "";
					logEntry("Battle log cleared", "system");
				}
			}

			function exportLog() {
				const logText = gameState.log
					.map(
						(entry) =>
							`[Turn ${entry.turn} - ${entry.phase} - ${entry.timestamp}] ${entry.message}`
					)
					.join("\n");

				const blob = new Blob([logText], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = `battle_log_turn${gameState.currentTurn}.txt`;
				a.click();
				URL.revokeObjectURL(url);
			}

			// Game State Persistence
			function saveGameState() {
				try {
					localStorage.setItem("wh40k_gamestate", JSON.stringify(gameState));
				} catch (e) {
					console.error("Failed to save game state:", e);
				}
			}

			function loadGameState() {
				try {
					const saved = localStorage.getItem("wh40k_gamestate");
					if (saved) {
						const loadedState = JSON.parse(saved);

						// Check if there's an active game
						if (
							loadedState.players[1].faction &&
							loadedState.players[2].faction
						) {
							if (confirm("Resume previous battle?")) {
								gameState = loadedState;
								document.getElementById("setupScreen").style.display = "none";
								document.getElementById("gameScreen").style.display = "grid";

								// Update display with loaded names
								document.getElementById("player1NameDisplay").textContent =
									gameState.players[1].name;
								document.getElementById("player2NameDisplay").textContent =
									gameState.players[2].name;

								updateDisplay();
								renderObjectivesList();
								logEntry("Battle resumed from saved state", "system");
							} else {
								localStorage.removeItem("wh40k_gamestate");
							}
						}
					}
				} catch (e) {
					console.error("Failed to load game state:", e);
				}
			}

			function resetGame() {
				if (confirm("Reset the entire battle? This will clear all data!")) {
					localStorage.removeItem("wh40k_gamestate");
					location.reload();
				}
			}

			// Initialize the app
			window.onload = init;

			// Prevent modal close on escape
			window.onclick = function (event) {
				const modal = document.getElementById("unitModal");
				const shootingModal = document.getElementById("shootingModal");
				const moraleModal = document.getElementById("moraleModal");
				const chargeModal = document.getElementById("chargeModal");

				if (
					event.target == modal ||
					event.target == shootingModal ||
					event.target == moraleModal ||
					event.target == chargeModal
				) {
					// Allow closing modals by clicking outside
					if (event.target == modal) {
						closeUnitModal();
					} else if (event.target == shootingModal) {
						closeShootingModal();
					} else if (event.target == moraleModal) {
						closeMoraleModal();
					} else if (event.target == chargeModal) {
						closeChargeModal();
					}
				}
			};
			function getAvailableActionsForUnit(unit, playerNum) {
				const actions = [];
				const phase = gameState.currentPhase;
				const player = gameState.players[playerNum];
				const enemyNum = playerNum === 1 ? 2 : 1;
				const enemyUnits = gameState.players[enemyNum].units.filter(
					(u) => u.status !== "destroyed"
				);

				// Always available
				actions.push({
					label: `Take wounds: ${unit.name} takes X wounds`,
					fill: `${unit.name} takes X wounds`,
					tooltip: "Apply wounds to this unit.",
				});
				actions.push({
					label: `Heal wounds: ${unit.name} heals X wounds`,
					fill: `${unit.name} heals X wounds`,
					tooltip: "Heal wounds for this unit.",
				});
				actions.push({
					label: `Add buff: ${unit.name} gets +1 to hit`,
					fill: `${unit.name} gets +1 to hit until end of turn`,
					tooltip: "Add a buff to this unit.",
				});
				actions.push({
					label: `Use ability: ${unit.name} uses [ability name]`,
					fill: `${unit.name} uses [ability name]`,
					tooltip: "Use a named ability or stratagem for this unit.",
				});
				// Add available faction commands as actions
				const faction = gameState.players[playerNum].faction;

				if (phase === "command" && factionCommands[faction]) {
					factionCommands[faction].forEach((cmd) => {
						actions.push({
							label: `Command: ${cmd.name}`,
							fill: `${unit.name} uses ${cmd.name}`,
							tooltip: cmd.description,
						});
					});
				}

				// Phase-based actions
				if (phase === "command") {
					if (unit.abilities && unit.abilities.length > 0) {
						unit.abilities.forEach((ability) => {
							actions.push({
								label: `Use Command Ability: ${unit.name} uses "${ability}"`,
								fill: `${unit.name} uses ${ability}`,
								tooltip: `Use "${ability}" during the command phase.`,
							});
						});
					}
				}
				if (phase === "movement") {
					actions.push({
						label: `Move: ${unit.name} moves`,
						fill: `${unit.name} moves`,
						tooltip: "Move this unit normally.",
					});
					actions.push({
						label: `Advance: ${unit.name} advances`,
						fill: `${unit.name} advances`,
						tooltip: "Advance this unit.",
					});
					if (unit.engagedWith && unit.engagedWith.length > 0) {
						actions.push({
							label: `Fall Back: ${unit.name} falls back`,
							fill: `${unit.name} falls back`,
							tooltip: "Fall back from melee.",
						});
					}
				}
				if (phase === "shooting" && !unit.hasShot) {
					enemyUnits.forEach((enemy) => {
						actions.push({
							label: `Shoot: ${unit.name} shoots ${enemy.name}`,
							fill: `${unit.name} shoots ${enemy.name}`,
							tooltip: `Start a shooting attack against ${enemy.name}.`,
						});
					});
				}
				if (phase === "charge") {
					enemyUnits.forEach((enemy) => {
						actions.push({
							label: `Charge: ${unit.name} charges ${enemy.name}`,
							fill: `${unit.name} charges ${enemy.name}`,
							tooltip: `Declare a charge against ${enemy.name}.`,
						});
					});
				}
				if (
					phase === "fight" &&
					unit.engagedWith &&
					unit.engagedWith.length > 0 &&
					!unit.hasFought
				) {
					unit.engagedWith.forEach((enemyId) => {
						const enemy = findUnitById(enemyId);
						if (enemy) {
							actions.push({
								label: `Fight: ${unit.name} fights ${enemy.name}`,
								fill: `${unit.name} fights ${enemy.name}`,
								tooltip: `Fight combat against ${enemy.name}.`,
							});
						}
					});
				}
				if (phase === "morale") {
					actions.push({
						label: `Take Battle-shock Test: ${unit.name} takes a test`,
						fill: `${unit.name} takes battle-shock test`,
						tooltip: "Test for battle-shock.",
					});
				}
				return actions;
			}
			function showUnitActionsModal(unit, playerNum) {
				const actions = getAvailableActionsForUnit(unit, playerNum);
				const list = actions.length
					? actions
							.map((a) => {
								// If this is a faction command, show info on click
								const isCommand =
									a.tooltip &&
									Object.values(factionCommands)
										.flat()
										.some(
											(cmd) => cmd.name === a.label.replace(/^Command: /, "")
										);
								if (isCommand) {
									// Use a custom handler to show command info
									return `<button class="btn btn-small" style="margin:6px 0;display:block;width:100%;text-align:left;" title="${a.tooltip.replace(
										/"/g,
										"&quot;"
									)}" onclick="showCommandInfoModal('${a.label.replace(
										/^Command: /,
										""
									)}', ${playerNum}, '${unit.id}')">${a.label}</button>`;
								} else {
									// Normal actions fill input immediately
									return `<button class="btn btn-small" style="margin:6px 0;display:block;width:100%;text-align:left;" title="${a.tooltip.replace(
										/"/g,
										"&quot;"
									)}" onclick="fillPlayerActionInput(${playerNum}, '${a.fill.replace(
										/'/g,
										"&#39;"
									)}'); closeUnitActionsModal();">${a.label}</button>`;
								}
							})
							.join("")
					: '<div style="color:#888;text-align:center;">No actions available.</div>';
				document.getElementById("unitActionTitle").textContent =
					unit.name + " — Available Actions";
				document.getElementById("unitActionsList").innerHTML = list;
				document.getElementById("unitActionsModal").style.display = "block";
			}

			// Add a modal for command info (re-use unitActionsModal for simplicity)
			function showCommandInfoModal(commandName, playerNum, unitId) {
				// Find the command object
				const faction = gameState.players[playerNum].faction;
				const command =
					(factionCommands[faction] || []).find(
						(cmd) => cmd.name === commandName
					) ||
					Object.values(factionCommands)
						.flat()
						.find((cmd) => cmd.name === commandName);

				if (!command) {
					document.getElementById("unitActionsList").innerHTML =
						'<div style="color:#ff0000;">Command not found.</div>';
					return;
				}

				document.getElementById("unitActionsList").innerHTML = `
				<div style="padding:1rem;">
					<h3 style="color:#ffd700;">${command.name}</h3>
					<p style="margin:1rem 0; color:#ccc;">${command.description}</p>
					<button class="btn" onclick="selectCommandAction('${command.name}', ${playerNum}, '${unitId}')">Select</button>
					<button class="btn btn-secondary" style="margin-left:1rem;" onclick="closeUnitActionsModal()">Cancel</button>
				</div>
			`;
			}

			// When "Select" is clicked, fill the input and close the modal
			function selectCommandAction(commandName, playerNum, unitId) {
				const unit = findUnitById(unitId);
				const text = unit
					? `${unit.name} uses ${commandName}`
					: `Use ${commandName}`;
				fillPlayerActionInput(playerNum, text);
				closeUnitActionsModal();
			}

			function fillPlayerActionInput(playerNum, text) {
				const input = document.getElementById(`player${playerNum}Input`);
				if (input) input.value = text;
			}

			function closeUnitActionsModal() {
				const modal = document.getElementById("unitActionsModal");
				if (modal) modal.style.display = "none";
			}

			// Returns true if Oath of Moment is active for the attacker against the target unit this turn
			function checkOathOfMoment(attackerPlayerNum, targetUnitId) {
				const player = gameState.players[attackerPlayerNum];
				if (!player || !player.stratagems) return false;
				return player.stratagems.some(
					(s) =>
						s.name === "Oath of Moment" &&
						s.turn === gameState.currentTurn &&
						s.phase === "shooting" &&
						// Optionally, you could store the target id in the stratagem object for more accuracy
						// For now, just check if used this turn/phase
						true
				);
			}

			// Returns true if Transhuman Physiology is active for the defender unit this turn
			function checkTranshumanPhysiology(defenderPlayerNum, unitId) {
				const player = gameState.players[defenderPlayerNum];
				if (!player || !player.stratagems) return false;
				return player.stratagems.some(
					(s) =>
						s.name === "Transhuman Physiology" &&
						s.turn === gameState.currentTurn &&
						s.phase === "fight"
				);
			}

			// Returns true if Armor of Contempt is active for the defender unit this turn
			function checkArmorOfContempt(defenderPlayerNum, unitId) {
				// If you add this stratagem, implement similar logic
				return false;
			}
			// --- Enforced Stratagem Logic ---

			function unitStratagemAction(unitId, playerNum) {
				const unit = findUnitById(unitId);
				const player = gameState.players[playerNum];
				const availableStratagems = getAvailableStratagems(
					player.faction,
					gameState.currentPhase,
					player.cp,
					unit
				);

				if (availableStratagems.length === 0) {
					alert(
						"No eligible stratagems available for this unit in this phase."
					);
					return;
				}

				const modal = document.getElementById("unitActionsModal");
				const title = document.getElementById("unitActionTitle");
				const list = document.getElementById("unitActionsList");

				title.textContent = `Use Stratagem for ${unit.name}`;
				list.innerHTML = "";

				availableStratagems.forEach((strat, i) => {
					const usedKey = getStratagemUsageKey(strat, playerNum, unitId);
					const alreadyUsed = !!gameState.players[
						playerNum
					].activeCommandEffects.find((eff) => eff.key === usedKey);
					const canUse = player.cp >= strat.cost && !alreadyUsed;

					const stratDiv = document.createElement("div");
					stratDiv.style.marginBottom = "1rem";
					stratDiv.style.opacity = canUse ? 1 : 0.4;

					stratDiv.innerHTML = `
			<strong style="color:#ffd700;">${strat.name}</strong>
			<span style="margin-left:8px; color:#ffa500;">[${strat.cost} CP]</span>
			<br>
			<span style="font-size:0.92em;">${strat.description}</span>
			<br>
			${
				canUse
					? `<button class="btn btn-small" onclick="applyStratagem('${strat.name.replace(
							/'/g,
							""
					  )}', '${unitId}', ${playerNum})">Use</button>`
					: `<span style="color:#888;">${
							alreadyUsed ? "Already used this phase" : "Insufficient CP"
					  }</span>`
			}
		`;
					list.appendChild(stratDiv);
				});

				modal.style.display = "block";
			}

			function getAvailableStratagems(faction, phase, cp, unit) {
				const strats = factionCommands[faction] || [];
				return strats.filter((strat) => {
					if (strat.phase !== phase) return false;
					if (cp < strat.cost) return false;
					return true;
				});
			}

			function getStratagemUsageKey(strat, playerNum, unitId) {
				return `${playerNum}_${unitId}_${strat.name}_${gameState.currentTurn}_${gameState.currentPhase}`;
			}

			function applyStratagem(stratName, unitId, playerNum) {
				const player = gameState.players[playerNum];
				const unit = findUnitById(unitId);
				const strat = (factionCommands[player.faction] || []).find(
					(s) => s.name.replace(/'/g, "") === stratName
				);

				if (!strat || player.cp < strat.cost) {
					alert("Stratagem unavailable or insufficient CP.");
					return;
				}

				const usedKey = getStratagemUsageKey(strat, playerNum, unitId);
				player.activeCommandEffects.push({
					key: usedKey,
					name: strat.name,
					unitId: unitId,
					startTurn: gameState.currentTurn,
					startPhase: gameState.currentPhase,
					duration: strat.frequency === "once" ? "phase" : "turn",
				});

				player.cp -= strat.cost;

				if (strat.name === "Oath of Moment") {
					let allEnemies = gameState.players[
						playerNum === 1 ? 2 : 1
					].units.filter((u) => u.status !== "destroyed");
					let target = allEnemies[0];
					if (allEnemies.length > 1) {
						let targetName = prompt(
							"Select enemy unit for Oath of Moment (type full name):\n" +
								allEnemies.map((u) => u.name).join(", "),
							allEnemies[0].name
						);
						target =
							allEnemies.find((u) => u.name === targetName) || allEnemies[0];
					}
					target.buffs = target.buffs || [];
					target.buffs.push({ name: "Oath of Moment", duration: "turn" });
					gameState.oathOfMomentTarget = {
						playerNum,
						unitId: target.id,
						turn: gameState.currentTurn,
					};
					logEntry(
						`${player.name} uses Oath of Moment on ${target.name}!`,
						"stratagem"
					);
				} else if (strat.name === "Transhuman Physiology") {
					unit.buffs = unit.buffs || [];
					unit.buffs.push({ name: "Transhuman Physiology", duration: "turn" });
					logEntry(`${unit.name} gains Transhuman Physiology!`, "stratagem");
				}
				// ...other stratagems as needed

				updateDisplay();
				saveGameState();
				closeUnitActionsModal();
			}

			// Effect logic for rerolls and transhuman
			function checkOathOfMoment(playerNum, targetUnitId) {
				const effect = gameState.oathOfMomentTarget;
				return (
					effect &&
					effect.playerNum === playerNum &&
					effect.unitId === targetUnitId &&
					effect.turn === gameState.currentTurn
				);
			}
			function checkTranshumanPhysiology(playerNum, unitId) {
				const units = gameState.players[playerNum].units;
				const unit = units.find((u) => u.id === unitId);
				return (
					unit &&
					unit.buffs &&
					unit.buffs.some((b) => b.name === "Transhuman Physiology")
				);
			}

			// Clean up buffs at end of phase/turn
			function cleanupBuffsAndStratagems() {
				[1, 2].forEach((playerNum) => {
					const player = gameState.players[playerNum];
					player.units.forEach((unit) => {
						if (unit.buffs) {
							unit.buffs = unit.buffs.filter((b) => {
								if (
									b.duration === "phase" &&
									b.phase !== gameState.currentPhase
								)
									return false;
								if (b.duration === "turn" && b.turn !== gameState.currentTurn)
									return false;
								return true;
							});
						}
					});
					player.activeCommandEffects = player.activeCommandEffects.filter(
						(eff) => {
							if (
								eff.duration === "phase" &&
								eff.startPhase !== gameState.currentPhase
							)
								return false;
							if (
								eff.duration === "turn" &&
								eff.startTurn !== gameState.currentTurn
							)
								return false;
							return true;
						}
					);
				});
			}
			const originalNextPhase = nextPhase;
			nextPhase = function () {
				originalNextPhase();
				cleanupBuffsAndStratagems();
			};
			const originalEndTurn = endTurn;
			endTurn = function () {
				originalEndTurn();
				cleanupBuffsAndStratagems();
			};
		</script>
	</body>
</html>
